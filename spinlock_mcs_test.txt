
build/debug/spinlock_mcs_test_18.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <base::TestRegistry::TestRegistry()>:
  void runSomeCases(int* errors, const string& cases);

  TestRegistry();
};

TestRegistry::TestRegistry() {
       0:	55                   	push   %rbp
       1:	48 89 e5             	mov    %rsp,%rbp
       4:	53                   	push   %rbx
       5:	48 83 ec 78          	sub    $0x78,%rsp
       9:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
       d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
      11:	48 89 c7             	mov    %rax,%rdi
      14:	e8 00 00 00 00       	callq  19 <base::TestRegistry::TestRegistry()+0x19>
      19:	48 8b 45 88          	mov    -0x78(%rbp),%rax
      1d:	48 83 c0 18          	add    $0x18,%rax
      21:	48 89 c7             	mov    %rax,%rdi
      24:	e8 00 00 00 00       	callq  29 <base::TestRegistry::TestRegistry()+0x29>
  args_.addParam("case", "all", "csv list of test cases to run");
      29:	48 8d 45 ec          	lea    -0x14(%rbp),%rax
      2d:	48 89 c7             	mov    %rax,%rdi
      30:	e8 00 00 00 00       	callq  35 <base::TestRegistry::TestRegistry()+0x35>
      35:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
      39:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
      3d:	be 00 00 00 00       	mov    $0x0,%esi
      42:	48 89 c7             	mov    %rax,%rdi
      45:	e8 00 00 00 00       	callq  4a <base::TestRegistry::TestRegistry()+0x4a>
      4a:	48 8d 45 eb          	lea    -0x15(%rbp),%rax
      4e:	48 89 c7             	mov    %rax,%rdi
      51:	e8 00 00 00 00       	callq  56 <base::TestRegistry::TestRegistry()+0x56>
      56:	48 8d 55 eb          	lea    -0x15(%rbp),%rdx
      5a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
      5e:	be 00 00 00 00       	mov    $0x0,%esi
      63:	48 89 c7             	mov    %rax,%rdi
      66:	e8 00 00 00 00       	callq  6b <base::TestRegistry::TestRegistry()+0x6b>
      6b:	48 8d 45 ea          	lea    -0x16(%rbp),%rax
      6f:	48 89 c7             	mov    %rax,%rdi
      72:	e8 00 00 00 00       	callq  77 <base::TestRegistry::TestRegistry()+0x77>
      77:	48 8d 55 ea          	lea    -0x16(%rbp),%rdx
      7b:	48 8d 45 90          	lea    -0x70(%rbp),%rax
      7f:	be 00 00 00 00       	mov    $0x0,%esi
      84:	48 89 c7             	mov    %rax,%rdi
      87:	e8 00 00 00 00       	callq  8c <base::TestRegistry::TestRegistry()+0x8c>
      8c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
      90:	48 8d 78 18          	lea    0x18(%rax),%rdi
      94:	48 8d 4d b0          	lea    -0x50(%rbp),%rcx
      98:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
      9c:	48 8d 45 90          	lea    -0x70(%rbp),%rax
      a0:	48 89 c6             	mov    %rax,%rsi
      a3:	e8 00 00 00 00       	callq  a8 <base::TestRegistry::TestRegistry()+0xa8>
      a8:	48 8d 45 90          	lea    -0x70(%rbp),%rax
      ac:	48 89 c7             	mov    %rax,%rdi
      af:	e8 00 00 00 00       	callq  b4 <base::TestRegistry::TestRegistry()+0xb4>
      b4:	48 8d 45 ea          	lea    -0x16(%rbp),%rax
      b8:	48 89 c7             	mov    %rax,%rdi
      bb:	e8 00 00 00 00       	callq  c0 <base::TestRegistry::TestRegistry()+0xc0>
      c0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
      c4:	48 89 c7             	mov    %rax,%rdi
      c7:	e8 00 00 00 00       	callq  cc <base::TestRegistry::TestRegistry()+0xcc>
      cc:	48 8d 45 eb          	lea    -0x15(%rbp),%rax
      d0:	48 89 c7             	mov    %rax,%rdi
      d3:	e8 00 00 00 00       	callq  d8 <base::TestRegistry::TestRegistry()+0xd8>
      d8:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
      dc:	48 89 c7             	mov    %rax,%rdi
      df:	e8 00 00 00 00       	callq  e4 <base::TestRegistry::TestRegistry()+0xe4>
      e4:	48 8d 45 ec          	lea    -0x14(%rbp),%rax
      e8:	48 89 c7             	mov    %rax,%rdi
      eb:	e8 00 00 00 00       	callq  f0 <base::TestRegistry::TestRegistry()+0xf0>
  args_.addParam("listcases", "false", "list the test cases for this test");
      f0:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
      f4:	48 89 c7             	mov    %rax,%rdi
      f7:	e8 00 00 00 00       	callq  fc <base::TestRegistry::TestRegistry()+0xfc>
      fc:	48 8d 55 ef          	lea    -0x11(%rbp),%rdx
     100:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
     104:	be 00 00 00 00       	mov    $0x0,%esi
     109:	48 89 c7             	mov    %rax,%rdi
     10c:	e8 00 00 00 00       	callq  111 <base::TestRegistry::TestRegistry()+0x111>
     111:	48 8d 45 ee          	lea    -0x12(%rbp),%rax
     115:	48 89 c7             	mov    %rax,%rdi
     118:	e8 00 00 00 00       	callq  11d <base::TestRegistry::TestRegistry()+0x11d>
     11d:	48 8d 55 ee          	lea    -0x12(%rbp),%rdx
     121:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
     125:	be 00 00 00 00       	mov    $0x0,%esi
     12a:	48 89 c7             	mov    %rax,%rdi
     12d:	e8 00 00 00 00       	callq  132 <base::TestRegistry::TestRegistry()+0x132>
     132:	48 8d 45 ed          	lea    -0x13(%rbp),%rax
     136:	48 89 c7             	mov    %rax,%rdi
     139:	e8 00 00 00 00       	callq  13e <base::TestRegistry::TestRegistry()+0x13e>
     13e:	48 8d 55 ed          	lea    -0x13(%rbp),%rdx
     142:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
     146:	be 00 00 00 00       	mov    $0x0,%esi
     14b:	48 89 c7             	mov    %rax,%rdi
     14e:	e8 00 00 00 00       	callq  153 <base::TestRegistry::TestRegistry()+0x153>
     153:	48 8b 45 88          	mov    -0x78(%rbp),%rax
     157:	48 8d 78 18          	lea    0x18(%rax),%rdi
     15b:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
     15f:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
     163:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
     167:	48 89 c6             	mov    %rax,%rsi
     16a:	e8 00 00 00 00       	callq  16f <base::TestRegistry::TestRegistry()+0x16f>
     16f:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
     173:	48 89 c7             	mov    %rax,%rdi
     176:	e8 00 00 00 00       	callq  17b <base::TestRegistry::TestRegistry()+0x17b>
     17b:	48 8d 45 ed          	lea    -0x13(%rbp),%rax
     17f:	48 89 c7             	mov    %rax,%rdi
     182:	e8 00 00 00 00       	callq  187 <base::TestRegistry::TestRegistry()+0x187>
     187:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
     18b:	48 89 c7             	mov    %rax,%rdi
     18e:	e8 00 00 00 00       	callq  193 <base::TestRegistry::TestRegistry()+0x193>
     193:	48 8d 45 ee          	lea    -0x12(%rbp),%rax
     197:	48 89 c7             	mov    %rax,%rdi
     19a:	e8 00 00 00 00       	callq  19f <base::TestRegistry::TestRegistry()+0x19f>
     19f:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
     1a3:	48 89 c7             	mov    %rax,%rdi
     1a6:	e8 00 00 00 00       	callq  1ab <base::TestRegistry::TestRegistry()+0x1ab>
     1ab:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
     1af:	48 89 c7             	mov    %rax,%rdi
     1b2:	e8 00 00 00 00       	callq  1b7 <base::TestRegistry::TestRegistry()+0x1b7>
}
     1b7:	48 83 c4 78          	add    $0x78,%rsp
     1bb:	5b                   	pop    %rbx
     1bc:	5d                   	pop    %rbp
     1bd:	c3                   	retq   
     1be:	48 89 c3             	mov    %rax,%rbx

  TestRegistry();
};

TestRegistry::TestRegistry() {
  args_.addParam("case", "all", "csv list of test cases to run");
     1c1:	48 8d 45 90          	lea    -0x70(%rbp),%rax
     1c5:	48 89 c7             	mov    %rax,%rdi
     1c8:	e8 00 00 00 00       	callq  1cd <base::TestRegistry::TestRegistry()+0x1cd>
     1cd:	eb 03                	jmp    1d2 <base::TestRegistry::TestRegistry()+0x1d2>
     1cf:	48 89 c3             	mov    %rax,%rbx
     1d2:	48 8d 45 ea          	lea    -0x16(%rbp),%rax
     1d6:	48 89 c7             	mov    %rax,%rdi
     1d9:	e8 00 00 00 00       	callq  1de <base::TestRegistry::TestRegistry()+0x1de>
     1de:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
     1e2:	48 89 c7             	mov    %rax,%rdi
     1e5:	e8 00 00 00 00       	callq  1ea <base::TestRegistry::TestRegistry()+0x1ea>
     1ea:	eb 03                	jmp    1ef <base::TestRegistry::TestRegistry()+0x1ef>
     1ec:	48 89 c3             	mov    %rax,%rbx
     1ef:	48 8d 45 eb          	lea    -0x15(%rbp),%rax
     1f3:	48 89 c7             	mov    %rax,%rdi
     1f6:	e8 00 00 00 00       	callq  1fb <base::TestRegistry::TestRegistry()+0x1fb>
     1fb:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
     1ff:	48 89 c7             	mov    %rax,%rdi
     202:	e8 00 00 00 00       	callq  207 <base::TestRegistry::TestRegistry()+0x207>
     207:	eb 03                	jmp    20c <base::TestRegistry::TestRegistry()+0x20c>
     209:	48 89 c3             	mov    %rax,%rbx
     20c:	48 8d 45 ec          	lea    -0x14(%rbp),%rax
     210:	48 89 c7             	mov    %rax,%rdi
     213:	e8 00 00 00 00       	callq  218 <base::TestRegistry::TestRegistry()+0x218>
     218:	eb 5a                	jmp    274 <base::TestRegistry::TestRegistry()+0x274>
     21a:	48 89 c3             	mov    %rax,%rbx
  args_.addParam("listcases", "false", "list the test cases for this test");
     21d:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
     221:	48 89 c7             	mov    %rax,%rdi
     224:	e8 00 00 00 00       	callq  229 <base::TestRegistry::TestRegistry()+0x229>
     229:	eb 03                	jmp    22e <base::TestRegistry::TestRegistry()+0x22e>
     22b:	48 89 c3             	mov    %rax,%rbx
     22e:	48 8d 45 ed          	lea    -0x13(%rbp),%rax
     232:	48 89 c7             	mov    %rax,%rdi
     235:	e8 00 00 00 00       	callq  23a <base::TestRegistry::TestRegistry()+0x23a>
     23a:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
     23e:	48 89 c7             	mov    %rax,%rdi
     241:	e8 00 00 00 00       	callq  246 <base::TestRegistry::TestRegistry()+0x246>
     246:	eb 03                	jmp    24b <base::TestRegistry::TestRegistry()+0x24b>
     248:	48 89 c3             	mov    %rax,%rbx
     24b:	48 8d 45 ee          	lea    -0x12(%rbp),%rax
     24f:	48 89 c7             	mov    %rax,%rdi
     252:	e8 00 00 00 00       	callq  257 <base::TestRegistry::TestRegistry()+0x257>
     257:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
     25b:	48 89 c7             	mov    %rax,%rdi
     25e:	e8 00 00 00 00       	callq  263 <base::TestRegistry::TestRegistry()+0x263>
     263:	eb 03                	jmp    268 <base::TestRegistry::TestRegistry()+0x268>
     265:	48 89 c3             	mov    %rax,%rbx
     268:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
     26c:	48 89 c7             	mov    %rax,%rdi
     26f:	e8 00 00 00 00       	callq  274 <base::TestRegistry::TestRegistry()+0x274>
  void runSomeCases(int* errors, const string& cases);

  TestRegistry();
};

TestRegistry::TestRegistry() {
     274:	48 8b 45 88          	mov    -0x78(%rbp),%rax
     278:	48 83 c0 18          	add    $0x18,%rax
     27c:	48 89 c7             	mov    %rax,%rdi
     27f:	e8 00 00 00 00       	callq  284 <base::TestRegistry::TestRegistry()+0x284>
     284:	eb 03                	jmp    289 <base::TestRegistry::TestRegistry()+0x289>
     286:	48 89 c3             	mov    %rax,%rbx
     289:	48 8b 45 88          	mov    -0x78(%rbp),%rax
     28d:	48 89 c7             	mov    %rax,%rdi
     290:	e8 00 00 00 00       	callq  295 <base::TestRegistry::TestRegistry()+0x295>
     295:	48 89 d8             	mov    %rbx,%rax
     298:	48 89 c7             	mov    %rax,%rdi
     29b:	e8 00 00 00 00       	callq  2a0 <base::TestRegistry::getInstance()>

00000000000002a0 <base::TestRegistry::getInstance()>:
  args_.addParam("listcases", "false", "list the test cases for this test");
}

TestRegistry* TestRegistry::instance_ = NULL;

TestRegistry* TestRegistry::getInstance() {
     2a0:	55                   	push   %rbp
     2a1:	48 89 e5             	mov    %rsp,%rbp
     2a4:	41 54                	push   %r12
     2a6:	53                   	push   %rbx
  if (instance_ == NULL) instance_ = new TestRegistry;
     2a7:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 2ae <base::TestRegistry::getInstance()+0xe>
     2ae:	48 85 c0             	test   %rax,%rax
     2b1:	75 1c                	jne    2cf <base::TestRegistry::getInstance()+0x2f>
     2b3:	bf 80 00 00 00       	mov    $0x80,%edi
     2b8:	e8 00 00 00 00       	callq  2bd <base::TestRegistry::getInstance()+0x1d>
     2bd:	48 89 c3             	mov    %rax,%rbx
     2c0:	48 89 df             	mov    %rbx,%rdi
     2c3:	e8 00 00 00 00       	callq  2c8 <base::TestRegistry::getInstance()+0x28>
     2c8:	48 89 1d 00 00 00 00 	mov    %rbx,0x0(%rip)        # 2cf <base::TestRegistry::getInstance()+0x2f>
  return instance_;
     2cf:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 2d6 <base::TestRegistry::getInstance()+0x36>
}
     2d6:	5b                   	pop    %rbx
     2d7:	41 5c                	pop    %r12
     2d9:	5d                   	pop    %rbp
     2da:	c3                   	retq   
     2db:	49 89 c4             	mov    %rax,%r12
}

TestRegistry* TestRegistry::instance_ = NULL;

TestRegistry* TestRegistry::getInstance() {
  if (instance_ == NULL) instance_ = new TestRegistry;
     2de:	48 89 df             	mov    %rbx,%rdi
     2e1:	e8 00 00 00 00       	callq  2e6 <base::TestRegistry::getInstance()+0x46>
     2e6:	4c 89 e0             	mov    %r12,%rax
     2e9:	48 89 c7             	mov    %rax,%rdi
     2ec:	e8 00 00 00 00       	callq  2f1 <base::TestRegistry::getInstance()+0x51>
     2f1:	90                   	nop

00000000000002f2 <base::TestRegistry::registerCase(base::TestCase*)>:
  return instance_;
}

TestCase* TestRegistry::registerCase(TestCase* test) {
     2f2:	55                   	push   %rbp
     2f3:	48 89 e5             	mov    %rsp,%rbp
     2f6:	48 83 ec 10          	sub    $0x10,%rsp
     2fa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
     2fe:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  tests_.push_back(test);
     302:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
     306:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
     30a:	48 89 d6             	mov    %rdx,%rsi
     30d:	48 89 c7             	mov    %rax,%rdi
     310:	e8 00 00 00 00       	callq  315 <base::TestRegistry::registerCase(base::TestCase*)+0x23>
  return test;
     315:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
     319:	c9                   	leaveq 
     31a:	c3                   	retq   
     31b:	90                   	nop

000000000000031c <base::TestRegistry::runListCases(int*)>:

void TestRegistry::runListCases(int* errors) {
     31c:	55                   	push   %rbp
     31d:	48 89 e5             	mov    %rsp,%rbp
     320:	53                   	push   %rbx
     321:	48 83 ec 58          	sub    $0x58,%rsp
     325:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
     329:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  for (Tests::const_iterator it = tests_.begin(); it != tests_.end(); ++it) {
     32d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
     331:	48 89 c7             	mov    %rax,%rdi
     334:	e8 00 00 00 00       	callq  339 <base::TestRegistry::runListCases(int*)+0x1d>
     339:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
     33d:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
     341:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
     345:	48 89 d6             	mov    %rdx,%rsi
     348:	48 89 c7             	mov    %rax,%rdi
     34b:	e8 00 00 00 00       	callq  350 <base::TestRegistry::runListCases(int*)+0x34>
     350:	eb 54                	jmp    3a6 <base::TestRegistry::runListCases(int*)+0x8a>
    std::cout << (*it)->fullName() << std::endl;
     352:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
     356:	48 89 c7             	mov    %rax,%rdi
     359:	e8 00 00 00 00       	callq  35e <base::TestRegistry::runListCases(int*)+0x42>
     35e:	48 8b 10             	mov    (%rax),%rdx
     361:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
     365:	48 89 d6             	mov    %rdx,%rsi
     368:	48 89 c7             	mov    %rax,%rdi
     36b:	e8 00 00 00 00       	callq  370 <base::TestRegistry::runListCases(int*)+0x54>
     370:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
     374:	48 89 c6             	mov    %rax,%rsi
     377:	bf 00 00 00 00       	mov    $0x0,%edi
     37c:	e8 00 00 00 00       	callq  381 <base::TestRegistry::runListCases(int*)+0x65>
     381:	be 00 00 00 00       	mov    $0x0,%esi
     386:	48 89 c7             	mov    %rax,%rdi
     389:	e8 00 00 00 00       	callq  38e <base::TestRegistry::runListCases(int*)+0x72>
     38e:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
     392:	48 89 c7             	mov    %rax,%rdi
     395:	e8 00 00 00 00       	callq  39a <base::TestRegistry::runListCases(int*)+0x7e>
  tests_.push_back(test);
  return test;
}

void TestRegistry::runListCases(int* errors) {
  for (Tests::const_iterator it = tests_.begin(); it != tests_.end(); ++it) {
     39a:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
     39e:	48 89 c7             	mov    %rax,%rdi
     3a1:	e8 00 00 00 00       	callq  3a6 <base::TestRegistry::runListCases(int*)+0x8a>
     3a6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
     3aa:	48 89 c7             	mov    %rax,%rdi
     3ad:	e8 00 00 00 00       	callq  3b2 <base::TestRegistry::runListCases(int*)+0x96>
     3b2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
     3b6:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
     3ba:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
     3be:	48 89 d6             	mov    %rdx,%rsi
     3c1:	48 89 c7             	mov    %rax,%rdi
     3c4:	e8 00 00 00 00       	callq  3c9 <base::TestRegistry::runListCases(int*)+0xad>
     3c9:	84 c0                	test   %al,%al
     3cb:	75 85                	jne    352 <base::TestRegistry::runListCases(int*)+0x36>
    std::cout << (*it)->fullName() << std::endl;
  }
}
     3cd:	eb 1a                	jmp    3e9 <base::TestRegistry::runListCases(int*)+0xcd>
     3cf:	48 89 c3             	mov    %rax,%rbx
  return test;
}

void TestRegistry::runListCases(int* errors) {
  for (Tests::const_iterator it = tests_.begin(); it != tests_.end(); ++it) {
    std::cout << (*it)->fullName() << std::endl;
     3d2:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
     3d6:	48 89 c7             	mov    %rax,%rdi
     3d9:	e8 00 00 00 00       	callq  3de <base::TestRegistry::runListCases(int*)+0xc2>
     3de:	48 89 d8             	mov    %rbx,%rax
     3e1:	48 89 c7             	mov    %rax,%rdi
     3e4:	e8 00 00 00 00       	callq  3e9 <base::TestRegistry::runListCases(int*)+0xcd>
  }
}
     3e9:	48 83 c4 58          	add    $0x58,%rsp
     3ed:	5b                   	pop    %rbx
     3ee:	5d                   	pop    %rbp
     3ef:	c3                   	retq   

00000000000003f0 <base::TestRegistry::runSomeCases(int*, std::string const&)>:

void TestRegistry::runSomeCases(int* errors, const string& cases) {
     3f0:	55                   	push   %rbp
     3f1:	48 89 e5             	mov    %rsp,%rbp
     3f4:	53                   	push   %rbx
     3f5:	48 81 ec 48 01 00 00 	sub    $0x148,%rsp
     3fc:	48 89 bd d8 fe ff ff 	mov    %rdi,-0x128(%rbp)
     403:	48 89 b5 d0 fe ff ff 	mov    %rsi,-0x130(%rbp)
     40a:	48 89 95 c8 fe ff ff 	mov    %rdx,-0x138(%rbp)
  unordered_map<string, bool> filter;
     411:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
     415:	48 89 c7             	mov    %rax,%rdi
     418:	e8 00 00 00 00       	callq  41d <base::TestRegistry::runSomeCases(int*, std::string const&)+0x2d>
     41d:	48 8d 75 ef          	lea    -0x11(%rbp),%rsi
     421:	48 8d 4d ee          	lea    -0x12(%rbp),%rcx
     425:	48 8d 55 ed          	lea    -0x13(%rbp),%rdx
     429:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
     430:	49 89 f0             	mov    %rsi,%r8
     433:	be 0a 00 00 00       	mov    $0xa,%esi
     438:	48 89 c7             	mov    %rax,%rdi
     43b:	e8 00 00 00 00       	callq  440 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x50>
     440:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
     444:	48 89 c7             	mov    %rax,%rdi
     447:	e8 00 00 00 00       	callq  44c <base::TestRegistry::runSomeCases(int*, std::string const&)+0x5c>
  if (cases != "all") {
     44c:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
     453:	be 00 00 00 00       	mov    $0x0,%esi
     458:	48 89 c7             	mov    %rax,%rdi
     45b:	e8 00 00 00 00       	callq  460 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x70>
     460:	84 c0                	test   %al,%al
     462:	0f 84 36 01 00 00    	je     59e <base::TestRegistry::runSomeCases(int*, std::string const&)+0x1ae>
    string::size_type pos;
    string curr = cases;
     468:	48 8b 95 c8 fe ff ff 	mov    -0x138(%rbp),%rdx
     46f:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     476:	48 89 d6             	mov    %rdx,%rsi
     479:	48 89 c7             	mov    %rax,%rdi
     47c:	e8 00 00 00 00       	callq  481 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x91>
    do {
      pos = curr.find(",");
     481:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     488:	ba 00 00 00 00       	mov    $0x0,%edx
     48d:	be 00 00 00 00       	mov    $0x0,%esi
     492:	48 89 c7             	mov    %rax,%rdi
     495:	e8 00 00 00 00       	callq  49a <base::TestRegistry::runSomeCases(int*, std::string const&)+0xaa>
     49a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      filter.insert(make_pair(curr.substr(0, pos), false /* executed yet? */));
     49e:	48 8d 45 90          	lea    -0x70(%rbp),%rax
     4a2:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
     4a6:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
     4ad:	48 89 d1             	mov    %rdx,%rcx
     4b0:	ba 00 00 00 00       	mov    $0x0,%edx
     4b5:	48 89 c7             	mov    %rax,%rdi
     4b8:	e8 00 00 00 00       	callq  4bd <base::TestRegistry::runSomeCases(int*, std::string const&)+0xcd>
     4bd:	48 8d 85 30 ff ff ff 	lea    -0xd0(%rbp),%rax
     4c4:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
     4c8:	ba 00 00 00 00       	mov    $0x0,%edx
     4cd:	48 89 ce             	mov    %rcx,%rsi
     4d0:	48 89 c7             	mov    %rax,%rdi
     4d3:	e8 00 00 00 00       	callq  4d8 <base::TestRegistry::runSomeCases(int*, std::string const&)+0xe8>
     4d8:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
     4df:	48 8d 85 40 ff ff ff 	lea    -0xc0(%rbp),%rax
     4e6:	48 89 d6             	mov    %rdx,%rsi
     4e9:	48 89 c7             	mov    %rax,%rdi
     4ec:	e8 00 00 00 00       	callq  4f1 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x101>
     4f1:	48 8d 85 10 ff ff ff 	lea    -0xf0(%rbp),%rax
     4f8:	48 8d 95 40 ff ff ff 	lea    -0xc0(%rbp),%rdx
     4ff:	48 8d 8d e0 fe ff ff 	lea    -0x120(%rbp),%rcx
     506:	48 89 ce             	mov    %rcx,%rsi
     509:	48 89 c7             	mov    %rax,%rdi
     50c:	e8 00 00 00 00       	callq  511 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x121>
     511:	48 8d 85 40 ff ff ff 	lea    -0xc0(%rbp),%rax
     518:	48 89 c7             	mov    %rax,%rdi
     51b:	e8 00 00 00 00       	callq  520 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x130>
     520:	48 8d 85 30 ff ff ff 	lea    -0xd0(%rbp),%rax
     527:	48 89 c7             	mov    %rax,%rdi
     52a:	e8 00 00 00 00       	callq  52f <base::TestRegistry::runSomeCases(int*, std::string const&)+0x13f>
     52f:	48 8d 45 90          	lea    -0x70(%rbp),%rax
     533:	48 89 c7             	mov    %rax,%rdi
     536:	e8 00 00 00 00       	callq  53b <base::TestRegistry::runSomeCases(int*, std::string const&)+0x14b>
      curr = curr.substr(pos+1);
     53b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
     53f:	48 8d 50 01          	lea    0x1(%rax),%rdx
     543:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
     547:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
     54e:	48 c7 c1 ff ff ff ff 	mov    $0xffffffffffffffff,%rcx
     555:	48 89 c7             	mov    %rax,%rdi
     558:	e8 00 00 00 00       	callq  55d <base::TestRegistry::runSomeCases(int*, std::string const&)+0x16d>
     55d:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
     561:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     568:	48 89 d6             	mov    %rdx,%rsi
     56b:	48 89 c7             	mov    %rax,%rdi
     56e:	e8 00 00 00 00       	callq  573 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x183>
     573:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
     577:	48 89 c7             	mov    %rax,%rdi
     57a:	e8 00 00 00 00       	callq  57f <base::TestRegistry::runSomeCases(int*, std::string const&)+0x18f>
void TestRegistry::runSomeCases(int* errors, const string& cases) {
  unordered_map<string, bool> filter;
  if (cases != "all") {
    string::size_type pos;
    string curr = cases;
    do {
     57f:	48 83 7d d8 ff       	cmpq   $0xffffffffffffffff,-0x28(%rbp)
     584:	0f 95 c0             	setne  %al
     587:	84 c0                	test   %al,%al
     589:	0f 85 f2 fe ff ff    	jne    481 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x91>

void TestRegistry::runSomeCases(int* errors, const string& cases) {
  unordered_map<string, bool> filter;
  if (cases != "all") {
    string::size_type pos;
    string curr = cases;
     58f:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     596:	48 89 c7             	mov    %rax,%rdi
     599:	e8 00 00 00 00       	callq  59e <base::TestRegistry::runSomeCases(int*, std::string const&)+0x1ae>
      filter.insert(make_pair(curr.substr(0, pos), false /* executed yet? */));
      curr = curr.substr(pos+1);
    } while (pos != string::npos);
  }

  for (Tests::const_iterator itt = tests_.begin(); itt != tests_.end(); ++itt) {
     59e:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
     5a5:	48 89 c7             	mov    %rax,%rdi
     5a8:	e8 00 00 00 00       	callq  5ad <base::TestRegistry::runSomeCases(int*, std::string const&)+0x1bd>
     5ad:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
     5b1:	48 8d 55 b0          	lea    -0x50(%rbp),%rdx
     5b5:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     5bc:	48 89 d6             	mov    %rdx,%rsi
     5bf:	48 89 c7             	mov    %rax,%rdi
     5c2:	e8 00 00 00 00       	callq  5c7 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x1d7>
     5c7:	e9 d3 01 00 00       	jmpq   79f <base::TestRegistry::runSomeCases(int*, std::string const&)+0x3af>
    TestCase* test = *itt;
     5cc:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     5d3:	48 89 c7             	mov    %rax,%rdi
     5d6:	e8 00 00 00 00       	callq  5db <base::TestRegistry::runSomeCases(int*, std::string const&)+0x1eb>
     5db:	48 8b 00             	mov    (%rax),%rax
     5de:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

    // If a filter is set, check if this test should be skipped. Also
    // keep track that all requested test cases execute.
    unordered_map<string, bool>::iterator iti = filter.find(test->name());
     5e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
     5e6:	48 89 c7             	mov    %rax,%rdi
     5e9:	e8 00 00 00 00       	callq  5ee <base::TestRegistry::runSomeCases(int*, std::string const&)+0x1fe>
     5ee:	48 89 c2             	mov    %rax,%rdx
     5f1:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
     5f8:	48 89 d6             	mov    %rdx,%rsi
     5fb:	48 89 c7             	mov    %rax,%rdi
     5fe:	e8 00 00 00 00       	callq  603 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x213>
     603:	48 89 c1             	mov    %rax,%rcx
     606:	48 89 d0             	mov    %rdx,%rax
     609:	48 89 8d b0 fe ff ff 	mov    %rcx,-0x150(%rbp)
     610:	48 89 85 b8 fe ff ff 	mov    %rax,-0x148(%rbp)
     617:	48 8b 85 b0 fe ff ff 	mov    -0x150(%rbp),%rax
     61e:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
     625:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
     62c:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
    if (!filter.empty()) {
     633:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
     63a:	48 89 c7             	mov    %rax,%rdi
     63d:	e8 00 00 00 00       	callq  642 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x252>
     642:	83 f0 01             	xor    $0x1,%eax
     645:	84 c0                	test   %al,%al
     647:	74 73                	je     6bc <base::TestRegistry::runSomeCases(int*, std::string const&)+0x2cc>
      if (iti == filter.end()) {
     649:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
     650:	48 89 c7             	mov    %rax,%rdi
     653:	e8 00 00 00 00       	callq  658 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x268>
     658:	48 89 c1             	mov    %rax,%rcx
     65b:	48 89 d0             	mov    %rdx,%rax
     65e:	48 89 8d b0 fe ff ff 	mov    %rcx,-0x150(%rbp)
     665:	48 89 85 b8 fe ff ff 	mov    %rax,-0x148(%rbp)
     66c:	48 8b 85 b0 fe ff ff 	mov    -0x150(%rbp),%rax
     673:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
     67a:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
     681:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
     688:	48 8d 95 60 ff ff ff 	lea    -0xa0(%rbp),%rdx
     68f:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
     696:	48 89 d6             	mov    %rdx,%rsi
     699:	48 89 c7             	mov    %rax,%rdi
     69c:	e8 00 00 00 00       	callq  6a1 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x2b1>
     6a1:	84 c0                	test   %al,%al
     6a3:	0f 85 e6 00 00 00    	jne    78f <base::TestRegistry::runSomeCases(int*, std::string const&)+0x39f>
        continue;
      } else {
        iti->second = true /* executed */;
     6a9:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
     6b0:	48 89 c7             	mov    %rax,%rdi
     6b3:	e8 00 00 00 00       	callq  6b8 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x2c8>
     6b8:	c6 40 08 01          	movb   $0x1,0x8(%rax)
      }
    }

    std::cout << "Running " << test->fullName() << ": " << std::flush;
     6bc:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
     6c0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
     6c4:	48 89 d6             	mov    %rdx,%rsi
     6c7:	48 89 c7             	mov    %rax,%rdi
     6ca:	e8 00 00 00 00       	callq  6cf <base::TestRegistry::runSomeCases(int*, std::string const&)+0x2df>
     6cf:	be 00 00 00 00       	mov    $0x0,%esi
     6d4:	bf 00 00 00 00       	mov    $0x0,%edi
     6d9:	e8 00 00 00 00       	callq  6de <base::TestRegistry::runSomeCases(int*, std::string const&)+0x2ee>
     6de:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
     6e2:	48 89 d6             	mov    %rdx,%rsi
     6e5:	48 89 c7             	mov    %rax,%rdi
     6e8:	e8 00 00 00 00       	callq  6ed <base::TestRegistry::runSomeCases(int*, std::string const&)+0x2fd>
     6ed:	be 00 00 00 00       	mov    $0x0,%esi
     6f2:	48 89 c7             	mov    %rax,%rdi
     6f5:	e8 00 00 00 00       	callq  6fa <base::TestRegistry::runSomeCases(int*, std::string const&)+0x30a>
     6fa:	be 00 00 00 00       	mov    $0x0,%esi
     6ff:	48 89 c7             	mov    %rax,%rdi
     702:	e8 00 00 00 00       	callq  707 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x317>
     707:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
     70b:	48 89 c7             	mov    %rax,%rdi
     70e:	e8 00 00 00 00       	callq  713 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x323>
    test->testBody();
     713:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
     717:	48 8b 00             	mov    (%rax),%rax
     71a:	48 83 c0 10          	add    $0x10,%rax
     71e:	48 8b 10             	mov    (%rax),%rdx
     721:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
     725:	48 89 c7             	mov    %rax,%rdi
     728:	ff d2                	callq  *%rdx
    if (test->errors()) {
     72a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
     72e:	48 89 c7             	mov    %rax,%rdi
     731:	e8 00 00 00 00       	callq  736 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x346>
     736:	85 c0                	test   %eax,%eax
     738:	0f 95 c0             	setne  %al
     73b:	84 c0                	test   %al,%al
     73d:	74 32                	je     771 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x381>
      (*errors) += test->errors();
     73f:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
     746:	8b 18                	mov    (%rax),%ebx
     748:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
     74c:	48 89 c7             	mov    %rax,%rdi
     74f:	e8 00 00 00 00       	callq  754 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x364>
     754:	8d 14 03             	lea    (%rbx,%rax,1),%edx
     757:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
     75e:	89 10                	mov    %edx,(%rax)
      std::cout << std::endl;
     760:	be 00 00 00 00       	mov    $0x0,%esi
     765:	bf 00 00 00 00       	mov    $0x0,%edi
     76a:	e8 00 00 00 00       	callq  76f <base::TestRegistry::runSomeCases(int*, std::string const&)+0x37f>
     76f:	eb 1f                	jmp    790 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x3a0>
    } else {
      std::cout << "PASSED" << std::endl;
     771:	be 00 00 00 00       	mov    $0x0,%esi
     776:	bf 00 00 00 00       	mov    $0x0,%edi
     77b:	e8 00 00 00 00       	callq  780 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x390>
     780:	be 00 00 00 00       	mov    $0x0,%esi
     785:	48 89 c7             	mov    %rax,%rdi
     788:	e8 00 00 00 00       	callq  78d <base::TestRegistry::runSomeCases(int*, std::string const&)+0x39d>
     78d:	eb 01                	jmp    790 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x3a0>
    // If a filter is set, check if this test should be skipped. Also
    // keep track that all requested test cases execute.
    unordered_map<string, bool>::iterator iti = filter.find(test->name());
    if (!filter.empty()) {
      if (iti == filter.end()) {
        continue;
     78f:	90                   	nop
      filter.insert(make_pair(curr.substr(0, pos), false /* executed yet? */));
      curr = curr.substr(pos+1);
    } while (pos != string::npos);
  }

  for (Tests::const_iterator itt = tests_.begin(); itt != tests_.end(); ++itt) {
     790:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     797:	48 89 c7             	mov    %rax,%rdi
     79a:	e8 00 00 00 00       	callq  79f <base::TestRegistry::runSomeCases(int*, std::string const&)+0x3af>
     79f:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
     7a6:	48 89 c7             	mov    %rax,%rdi
     7a9:	e8 00 00 00 00       	callq  7ae <base::TestRegistry::runSomeCases(int*, std::string const&)+0x3be>
     7ae:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
     7b2:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
     7b6:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     7bd:	48 89 d6             	mov    %rdx,%rsi
     7c0:	48 89 c7             	mov    %rax,%rdi
     7c3:	e8 00 00 00 00       	callq  7c8 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x3d8>
     7c8:	84 c0                	test   %al,%al
     7ca:	0f 85 fc fd ff ff    	jne    5cc <base::TestRegistry::runSomeCases(int*, std::string const&)+0x1dc>
      std::cout << "PASSED" << std::endl;
    }
  }

  // Any test in --case that was not executed?
  for (unordered_map<string, bool>::iterator iti = filter.begin();
     7d0:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
     7d7:	48 89 c7             	mov    %rax,%rdi
     7da:	e8 00 00 00 00       	callq  7df <base::TestRegistry::runSomeCases(int*, std::string const&)+0x3ef>
     7df:	48 89 c1             	mov    %rax,%rcx
     7e2:	48 89 d0             	mov    %rdx,%rax
     7e5:	48 89 8d b0 fe ff ff 	mov    %rcx,-0x150(%rbp)
     7ec:	48 89 85 b8 fe ff ff 	mov    %rax,-0x148(%rbp)
     7f3:	48 8b 85 b0 fe ff ff 	mov    -0x150(%rbp),%rax
     7fa:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
     801:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
     808:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
     80f:	eb 77                	jmp    888 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x498>
       iti != filter.end();
       ++iti) {
    if (iti->second == false /* have not executed */) {
     811:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     818:	48 89 c7             	mov    %rax,%rdi
     81b:	e8 00 00 00 00       	callq  820 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x430>
     820:	0f b6 40 08          	movzbl 0x8(%rax),%eax
     824:	83 f0 01             	xor    $0x1,%eax
     827:	84 c0                	test   %al,%al
     829:	74 4e                	je     879 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x489>
      std::cout << "Wrong test case name: " << iti->first << std::endl;
     82b:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     832:	48 89 c7             	mov    %rax,%rdi
     835:	e8 00 00 00 00       	callq  83a <base::TestRegistry::runSomeCases(int*, std::string const&)+0x44a>
     83a:	48 89 c3             	mov    %rax,%rbx
     83d:	be 00 00 00 00       	mov    $0x0,%esi
     842:	bf 00 00 00 00       	mov    $0x0,%edi
     847:	e8 00 00 00 00       	callq  84c <base::TestRegistry::runSomeCases(int*, std::string const&)+0x45c>
     84c:	48 89 de             	mov    %rbx,%rsi
     84f:	48 89 c7             	mov    %rax,%rdi
     852:	e8 00 00 00 00       	callq  857 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x467>
     857:	be 00 00 00 00       	mov    $0x0,%esi
     85c:	48 89 c7             	mov    %rax,%rdi
     85f:	e8 00 00 00 00       	callq  864 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x474>
      (*errors)++;
     864:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
     86b:	8b 00                	mov    (%rax),%eax
     86d:	8d 50 01             	lea    0x1(%rax),%edx
     870:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
     877:	89 10                	mov    %edx,(%rax)
  }

  // Any test in --case that was not executed?
  for (unordered_map<string, bool>::iterator iti = filter.begin();
       iti != filter.end();
       ++iti) {
     879:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
      std::cout << "PASSED" << std::endl;
    }
  }

  // Any test in --case that was not executed?
  for (unordered_map<string, bool>::iterator iti = filter.begin();
     880:	48 89 c7             	mov    %rax,%rdi
     883:	e8 00 00 00 00       	callq  888 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x498>
       iti != filter.end();
     888:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
     88f:	48 89 c7             	mov    %rax,%rdi
     892:	e8 00 00 00 00       	callq  897 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x4a7>
     897:	48 89 c1             	mov    %rax,%rcx
     89a:	48 89 d0             	mov    %rdx,%rax
     89d:	48 89 8d b0 fe ff ff 	mov    %rcx,-0x150(%rbp)
     8a4:	48 89 85 b8 fe ff ff 	mov    %rax,-0x148(%rbp)
     8ab:	48 8b 85 b0 fe ff ff 	mov    -0x150(%rbp),%rax
     8b2:	48 89 45 80          	mov    %rax,-0x80(%rbp)
     8b6:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
     8bd:	48 89 45 88          	mov    %rax,-0x78(%rbp)
      std::cout << "PASSED" << std::endl;
    }
  }

  // Any test in --case that was not executed?
  for (unordered_map<string, bool>::iterator iti = filter.begin();
     8c1:	48 8d 55 80          	lea    -0x80(%rbp),%rdx
     8c5:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     8cc:	48 89 d6             	mov    %rdx,%rsi
     8cf:	48 89 c7             	mov    %rax,%rdi
     8d2:	e8 00 00 00 00       	callq  8d7 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x4e7>
     8d7:	84 c0                	test   %al,%al
     8d9:	0f 85 32 ff ff ff    	jne    811 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x421>
    std::cout << (*it)->fullName() << std::endl;
  }
}

void TestRegistry::runSomeCases(int* errors, const string& cases) {
  unordered_map<string, bool> filter;
     8df:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
     8e6:	48 89 c7             	mov    %rax,%rdi
     8e9:	e8 00 00 00 00       	callq  8ee <base::TestRegistry::runSomeCases(int*, std::string const&)+0x4fe>
    if (iti->second == false /* have not executed */) {
      std::cout << "Wrong test case name: " << iti->first << std::endl;
      (*errors)++;
    }
  }
}
     8ee:	48 81 c4 48 01 00 00 	add    $0x148,%rsp
     8f5:	5b                   	pop    %rbx
     8f6:	5d                   	pop    %rbp
     8f7:	c3                   	retq   
     8f8:	48 89 c3             	mov    %rax,%rbx
    std::cout << (*it)->fullName() << std::endl;
  }
}

void TestRegistry::runSomeCases(int* errors, const string& cases) {
  unordered_map<string, bool> filter;
     8fb:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
     8ff:	48 89 c7             	mov    %rax,%rdi
     902:	e8 00 00 00 00       	callq  907 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x517>
     907:	48 89 d8             	mov    %rbx,%rax
     90a:	48 89 c7             	mov    %rax,%rdi
     90d:	e8 00 00 00 00       	callq  912 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x522>
     912:	48 89 c3             	mov    %rax,%rbx
  if (cases != "all") {
    string::size_type pos;
    string curr = cases;
    do {
      pos = curr.find(",");
      filter.insert(make_pair(curr.substr(0, pos), false /* executed yet? */));
     915:	48 8d 85 40 ff ff ff 	lea    -0xc0(%rbp),%rax
     91c:	48 89 c7             	mov    %rax,%rdi
     91f:	e8 00 00 00 00       	callq  924 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x534>
     924:	eb 03                	jmp    929 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x539>
     926:	48 89 c3             	mov    %rax,%rbx
     929:	48 8d 85 30 ff ff ff 	lea    -0xd0(%rbp),%rax
     930:	48 89 c7             	mov    %rax,%rdi
     933:	e8 00 00 00 00       	callq  938 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x548>
     938:	eb 03                	jmp    93d <base::TestRegistry::runSomeCases(int*, std::string const&)+0x54d>
     93a:	48 89 c3             	mov    %rax,%rbx
     93d:	48 8d 45 90          	lea    -0x70(%rbp),%rax
     941:	48 89 c7             	mov    %rax,%rdi
     944:	e8 00 00 00 00       	callq  949 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x559>
     949:	eb 14                	jmp    95f <base::TestRegistry::runSomeCases(int*, std::string const&)+0x56f>
     94b:	48 89 c3             	mov    %rax,%rbx
      curr = curr.substr(pos+1);
     94e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
     952:	48 89 c7             	mov    %rax,%rdi
     955:	e8 00 00 00 00       	callq  95a <base::TestRegistry::runSomeCases(int*, std::string const&)+0x56a>
     95a:	eb 03                	jmp    95f <base::TestRegistry::runSomeCases(int*, std::string const&)+0x56f>
     95c:	48 89 c3             	mov    %rax,%rbx

void TestRegistry::runSomeCases(int* errors, const string& cases) {
  unordered_map<string, bool> filter;
  if (cases != "all") {
    string::size_type pos;
    string curr = cases;
     95f:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     966:	48 89 c7             	mov    %rax,%rdi
     969:	e8 00 00 00 00       	callq  96e <base::TestRegistry::runSomeCases(int*, std::string const&)+0x57e>
     96e:	eb 14                	jmp    984 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x594>
     970:	48 89 c3             	mov    %rax,%rbx
      } else {
        iti->second = true /* executed */;
      }
    }

    std::cout << "Running " << test->fullName() << ": " << std::flush;
     973:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
     977:	48 89 c7             	mov    %rax,%rdi
     97a:	e8 00 00 00 00       	callq  97f <base::TestRegistry::runSomeCases(int*, std::string const&)+0x58f>
     97f:	eb 03                	jmp    984 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x594>
     981:	48 89 c3             	mov    %rax,%rbx
    std::cout << (*it)->fullName() << std::endl;
  }
}

void TestRegistry::runSomeCases(int* errors, const string& cases) {
  unordered_map<string, bool> filter;
     984:	48 8d 85 e0 fe ff ff 	lea    -0x120(%rbp),%rax
     98b:	48 89 c7             	mov    %rax,%rdi
     98e:	e8 00 00 00 00       	callq  993 <base::TestRegistry::runSomeCases(int*, std::string const&)+0x5a3>
     993:	48 89 d8             	mov    %rbx,%rax
     996:	48 89 c7             	mov    %rax,%rdi
     999:	e8 00 00 00 00       	callq  99e <base::TestRegistry::runAndResetWithArgs(int, char**)>

000000000000099e <base::TestRegistry::runAndResetWithArgs(int, char**)>:
      (*errors)++;
    }
  }
}

int TestRegistry::runAndResetWithArgs(int argc, char* argv[]) {
     99e:	55                   	push   %rbp
     99f:	48 89 e5             	mov    %rsp,%rbp
     9a2:	41 55                	push   %r13
     9a4:	41 54                	push   %r12
     9a6:	53                   	push   %rbx
     9a7:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
     9ae:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
     9b5:	89 b5 54 ff ff ff    	mov    %esi,-0xac(%rbp)
     9bb:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  int errors = 0;
     9c2:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
  bool exit = false;
     9c9:	c6 45 df 00          	movb   $0x0,-0x21(%rbp)
  MCP_BASE_exit_on_fatal = false;
     9cd:	c6 05 00 00 00 00 00 	movb   $0x0,0x0(%rip)        # 9d4 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x36>

  if (argv > 0 && !args_.parseArgv(argc, argv)) {
     9d4:	48 83 bd 48 ff ff ff 	cmpq   $0x0,-0xb8(%rbp)
     9db:	00 
     9dc:	74 30                	je     a0e <base::TestRegistry::runAndResetWithArgs(int, char**)+0x70>
     9de:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
     9e5:	48 8d 48 18          	lea    0x18(%rax),%rcx
     9e9:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
     9f0:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
     9f6:	89 c6                	mov    %eax,%esi
     9f8:	48 89 cf             	mov    %rcx,%rdi
     9fb:	e8 00 00 00 00       	callq  a00 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x62>
     a00:	83 f0 01             	xor    $0x1,%eax
     a03:	84 c0                	test   %al,%al
     a05:	74 07                	je     a0e <base::TestRegistry::runAndResetWithArgs(int, char**)+0x70>
     a07:	b8 01 00 00 00       	mov    $0x1,%eax
     a0c:	eb 05                	jmp    a13 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x75>
     a0e:	b8 00 00 00 00       	mov    $0x0,%eax
     a13:	84 c0                	test   %al,%al
     a15:	74 20                	je     a37 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x99>
    args_.printUsage();
     a17:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
     a1e:	48 83 c0 18          	add    $0x18,%rax
     a22:	48 89 c7             	mov    %rax,%rdi
     a25:	e8 00 00 00 00       	callq  a2a <base::TestRegistry::runAndResetWithArgs(int, char**)+0x8c>
    errors += 1 /* one error, parsing */;
     a2a:	8b 45 d8             	mov    -0x28(%rbp),%eax
     a2d:	83 c0 01             	add    $0x1,%eax
     a30:	89 45 d8             	mov    %eax,-0x28(%rbp)
    exit = true;
     a33:	c6 45 df 01          	movb   $0x1,-0x21(%rbp)
  }

  // Check if we just want to learn the names of the test's cases.
  string list_only;
     a37:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
     a3e:	48 89 c7             	mov    %rax,%rdi
     a41:	e8 00 00 00 00       	callq  a46 <base::TestRegistry::runAndResetWithArgs(int, char**)+0xa8>
  if (!exit && args_.getParam("listcases", &list_only)) {
     a46:	bb 00 00 00 00       	mov    $0x0,%ebx
     a4b:	41 bc 00 00 00 00    	mov    $0x0,%r12d
     a51:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
     a55:	83 f0 01             	xor    $0x1,%eax
     a58:	84 c0                	test   %al,%al
     a5a:	74 5e                	je     aba <base::TestRegistry::runAndResetWithArgs(int, char**)+0x11c>
     a5c:	48 8d 45 dd          	lea    -0x23(%rbp),%rax
     a60:	48 89 c7             	mov    %rax,%rdi
     a63:	e8 00 00 00 00       	callq  a68 <base::TestRegistry::runAndResetWithArgs(int, char**)+0xca>
     a68:	bb 01 00 00 00       	mov    $0x1,%ebx
     a6d:	48 8d 55 dd          	lea    -0x23(%rbp),%rdx
     a71:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     a78:	be 00 00 00 00       	mov    $0x0,%esi
     a7d:	48 89 c7             	mov    %rax,%rdi
     a80:	e8 00 00 00 00       	callq  a85 <base::TestRegistry::runAndResetWithArgs(int, char**)+0xe7>
     a85:	41 bc 01 00 00 00    	mov    $0x1,%r12d
     a8b:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
     a92:	48 8d 48 18          	lea    0x18(%rax),%rcx
     a96:	48 8d 95 60 ff ff ff 	lea    -0xa0(%rbp),%rdx
     a9d:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     aa4:	48 89 c6             	mov    %rax,%rsi
     aa7:	48 89 cf             	mov    %rcx,%rdi
     aaa:	e8 00 00 00 00       	callq  aaf <base::TestRegistry::runAndResetWithArgs(int, char**)+0x111>
     aaf:	84 c0                	test   %al,%al
     ab1:	74 07                	je     aba <base::TestRegistry::runAndResetWithArgs(int, char**)+0x11c>
     ab3:	b8 01 00 00 00       	mov    $0x1,%eax
     ab8:	eb 05                	jmp    abf <base::TestRegistry::runAndResetWithArgs(int, char**)+0x121>
     aba:	b8 00 00 00 00       	mov    $0x0,%eax
     abf:	41 89 c5             	mov    %eax,%r13d
     ac2:	45 84 e4             	test   %r12b,%r12b
     ac5:	74 0f                	je     ad6 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x138>
     ac7:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     ace:	48 89 c7             	mov    %rax,%rdi
     ad1:	e8 00 00 00 00       	callq  ad6 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x138>
     ad6:	84 db                	test   %bl,%bl
     ad8:	74 0c                	je     ae6 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x148>
     ada:	48 8d 45 dd          	lea    -0x23(%rbp),%rax
     ade:	48 89 c7             	mov    %rax,%rdi
     ae1:	e8 00 00 00 00       	callq  ae6 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x148>
     ae6:	45 84 ed             	test   %r13b,%r13b
     ae9:	74 32                	je     b1d <base::TestRegistry::runAndResetWithArgs(int, char**)+0x17f>
    if (list_only == "true") {
     aeb:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
     af2:	be 00 00 00 00       	mov    $0x0,%esi
     af7:	48 89 c7             	mov    %rax,%rdi
     afa:	e8 00 00 00 00       	callq  aff <base::TestRegistry::runAndResetWithArgs(int, char**)+0x161>
     aff:	84 c0                	test   %al,%al
     b01:	74 1a                	je     b1d <base::TestRegistry::runAndResetWithArgs(int, char**)+0x17f>
      runListCases(&errors);
     b03:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
     b07:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
     b0e:	48 89 d6             	mov    %rdx,%rsi
     b11:	48 89 c7             	mov    %rax,%rdi
     b14:	e8 00 00 00 00       	callq  b19 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x17b>
      exit = true;
     b19:	c6 45 df 01          	movb   $0x1,-0x21(%rbp)
    }
  }

  // Check if we'd like to execute only some of the tests cases, as
  // indicated byt the --cases parameter.
  string cases;
     b1d:	48 8d 45 80          	lea    -0x80(%rbp),%rax
     b21:	48 89 c7             	mov    %rax,%rdi
     b24:	e8 00 00 00 00       	callq  b29 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x18b>
  if (!exit && args_.getParam("case", &cases)) {
     b29:	bb 00 00 00 00       	mov    $0x0,%ebx
     b2e:	41 bc 00 00 00 00    	mov    $0x0,%r12d
     b34:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
     b38:	83 f0 01             	xor    $0x1,%eax
     b3b:	84 c0                	test   %al,%al
     b3d:	74 55                	je     b94 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x1f6>
     b3f:	48 8d 45 de          	lea    -0x22(%rbp),%rax
     b43:	48 89 c7             	mov    %rax,%rdi
     b46:	e8 00 00 00 00       	callq  b4b <base::TestRegistry::runAndResetWithArgs(int, char**)+0x1ad>
     b4b:	bb 01 00 00 00       	mov    $0x1,%ebx
     b50:	48 8d 55 de          	lea    -0x22(%rbp),%rdx
     b54:	48 8d 45 90          	lea    -0x70(%rbp),%rax
     b58:	be 00 00 00 00       	mov    $0x0,%esi
     b5d:	48 89 c7             	mov    %rax,%rdi
     b60:	e8 00 00 00 00       	callq  b65 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x1c7>
     b65:	41 bc 01 00 00 00    	mov    $0x1,%r12d
     b6b:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
     b72:	48 8d 48 18          	lea    0x18(%rax),%rcx
     b76:	48 8d 55 80          	lea    -0x80(%rbp),%rdx
     b7a:	48 8d 45 90          	lea    -0x70(%rbp),%rax
     b7e:	48 89 c6             	mov    %rax,%rsi
     b81:	48 89 cf             	mov    %rcx,%rdi
     b84:	e8 00 00 00 00       	callq  b89 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x1eb>
     b89:	84 c0                	test   %al,%al
     b8b:	74 07                	je     b94 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x1f6>
     b8d:	b8 01 00 00 00       	mov    $0x1,%eax
     b92:	eb 05                	jmp    b99 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x1fb>
     b94:	b8 00 00 00 00       	mov    $0x0,%eax
     b99:	41 89 c5             	mov    %eax,%r13d
     b9c:	45 84 e4             	test   %r12b,%r12b
     b9f:	74 0c                	je     bad <base::TestRegistry::runAndResetWithArgs(int, char**)+0x20f>
     ba1:	48 8d 45 90          	lea    -0x70(%rbp),%rax
     ba5:	48 89 c7             	mov    %rax,%rdi
     ba8:	e8 00 00 00 00       	callq  bad <base::TestRegistry::runAndResetWithArgs(int, char**)+0x20f>
     bad:	84 db                	test   %bl,%bl
     baf:	74 0c                	je     bbd <base::TestRegistry::runAndResetWithArgs(int, char**)+0x21f>
     bb1:	48 8d 45 de          	lea    -0x22(%rbp),%rax
     bb5:	48 89 c7             	mov    %rax,%rdi
     bb8:	e8 00 00 00 00       	callq  bbd <base::TestRegistry::runAndResetWithArgs(int, char**)+0x21f>
     bbd:	45 84 ed             	test   %r13b,%r13b
     bc0:	74 1e                	je     be0 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x242>
    runSomeCases(&errors, cases);
     bc2:	48 8d 55 80          	lea    -0x80(%rbp),%rdx
     bc6:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
     bca:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
     bd1:	48 89 ce             	mov    %rcx,%rsi
     bd4:	48 89 c7             	mov    %rax,%rdi
     bd7:	e8 00 00 00 00       	callq  bdc <base::TestRegistry::runAndResetWithArgs(int, char**)+0x23e>
    exit = true;
     bdc:	c6 45 df 01          	movb   $0x1,-0x21(%rbp)
  }

  for (Tests::const_iterator it = tests_.begin(); it != tests_.end(); ++it) {
     be0:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
     be7:	48 89 c7             	mov    %rax,%rdi
     bea:	e8 00 00 00 00       	callq  bef <base::TestRegistry::runAndResetWithArgs(int, char**)+0x251>
     bef:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
     bf3:	48 8d 55 b0          	lea    -0x50(%rbp),%rdx
     bf7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
     bfb:	48 89 d6             	mov    %rdx,%rsi
     bfe:	48 89 c7             	mov    %rax,%rdi
     c01:	e8 00 00 00 00       	callq  c06 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x268>
     c06:	eb 2a                	jmp    c32 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x294>
    (*it)->clear();
     c08:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
     c0c:	48 89 c7             	mov    %rax,%rdi
     c0f:	e8 00 00 00 00       	callq  c14 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x276>
     c14:	48 8b 00             	mov    (%rax),%rax
     c17:	48 8b 10             	mov    (%rax),%rdx
     c1a:	48 83 c2 18          	add    $0x18,%rdx
     c1e:	48 8b 12             	mov    (%rdx),%rdx
     c21:	48 89 c7             	mov    %rax,%rdi
     c24:	ff d2                	callq  *%rdx
  if (!exit && args_.getParam("case", &cases)) {
    runSomeCases(&errors, cases);
    exit = true;
  }

  for (Tests::const_iterator it = tests_.begin(); it != tests_.end(); ++it) {
     c26:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
     c2a:	48 89 c7             	mov    %rax,%rdi
     c2d:	e8 00 00 00 00       	callq  c32 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x294>
     c32:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
     c39:	48 89 c7             	mov    %rax,%rdi
     c3c:	e8 00 00 00 00       	callq  c41 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x2a3>
     c41:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
     c45:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
     c49:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
     c4d:	48 89 d6             	mov    %rdx,%rsi
     c50:	48 89 c7             	mov    %rax,%rdi
     c53:	e8 00 00 00 00       	callq  c58 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x2ba>
     c58:	84 c0                	test   %al,%al
     c5a:	75 ac                	jne    c08 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x26a>
    (*it)->clear();
  }
  tests_.clear();
     c5c:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
     c63:	48 89 c7             	mov    %rax,%rdi
     c66:	e8 00 00 00 00       	callq  c6b <base::TestRegistry::runAndResetWithArgs(int, char**)+0x2cd>
  TestRegistry* me = instance_;
     c6b:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # c72 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x2d4>
     c72:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  instance_ = NULL;
     c76:	48 c7 05 00 00 00 00 	movq   $0x0,0x0(%rip)        # c81 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x2e3>
     c7d:	00 00 00 00 
  delete me;
     c81:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
     c85:	48 85 db             	test   %rbx,%rbx
     c88:	74 10                	je     c9a <base::TestRegistry::runAndResetWithArgs(int, char**)+0x2fc>
     c8a:	48 89 df             	mov    %rbx,%rdi
     c8d:	e8 00 00 00 00       	callq  c92 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x2f4>
     c92:	48 89 df             	mov    %rbx,%rdi
     c95:	e8 00 00 00 00       	callq  c9a <base::TestRegistry::runAndResetWithArgs(int, char**)+0x2fc>

  return errors;
     c9a:	8b 5d d8             	mov    -0x28(%rbp),%ebx
    }
  }

  // Check if we'd like to execute only some of the tests cases, as
  // indicated byt the --cases parameter.
  string cases;
     c9d:	48 8d 45 80          	lea    -0x80(%rbp),%rax
     ca1:	48 89 c7             	mov    %rax,%rdi
     ca4:	e8 00 00 00 00       	callq  ca9 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x30b>
    errors += 1 /* one error, parsing */;
    exit = true;
  }

  // Check if we just want to learn the names of the test's cases.
  string list_only;
     ca9:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
     cb0:	48 89 c7             	mov    %rax,%rdi
     cb3:	e8 00 00 00 00       	callq  cb8 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x31a>
  tests_.clear();
  TestRegistry* me = instance_;
  instance_ = NULL;
  delete me;

  return errors;
     cb8:	89 d8                	mov    %ebx,%eax
}
     cba:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
     cc1:	5b                   	pop    %rbx
     cc2:	41 5c                	pop    %r12
     cc4:	41 5d                	pop    %r13
     cc6:	5d                   	pop    %rbp
     cc7:	c3                   	retq   
     cc8:	49 89 c5             	mov    %rax,%r13
    exit = true;
  }

  // Check if we just want to learn the names of the test's cases.
  string list_only;
  if (!exit && args_.getParam("listcases", &list_only)) {
     ccb:	45 84 e4             	test   %r12b,%r12b
     cce:	74 0f                	je     cdf <base::TestRegistry::runAndResetWithArgs(int, char**)+0x341>
     cd0:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
     cd7:	48 89 c7             	mov    %rax,%rdi
     cda:	e8 00 00 00 00       	callq  cdf <base::TestRegistry::runAndResetWithArgs(int, char**)+0x341>
     cdf:	4d 89 ec             	mov    %r13,%r12
     ce2:	eb 03                	jmp    ce7 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x349>
     ce4:	49 89 c4             	mov    %rax,%r12
     ce7:	84 db                	test   %bl,%bl
     ce9:	74 0c                	je     cf7 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x359>
     ceb:	48 8d 45 dd          	lea    -0x23(%rbp),%rax
     cef:	48 89 c7             	mov    %rax,%rdi
     cf2:	e8 00 00 00 00       	callq  cf7 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x359>
     cf7:	4c 89 e3             	mov    %r12,%rbx
     cfa:	eb 45                	jmp    d41 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x3a3>
     cfc:	49 89 c5             	mov    %rax,%r13
  }

  // Check if we'd like to execute only some of the tests cases, as
  // indicated byt the --cases parameter.
  string cases;
  if (!exit && args_.getParam("case", &cases)) {
     cff:	45 84 e4             	test   %r12b,%r12b
     d02:	74 0c                	je     d10 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x372>
     d04:	48 8d 45 90          	lea    -0x70(%rbp),%rax
     d08:	48 89 c7             	mov    %rax,%rdi
     d0b:	e8 00 00 00 00       	callq  d10 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x372>
     d10:	4d 89 ec             	mov    %r13,%r12
     d13:	eb 03                	jmp    d18 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x37a>
     d15:	49 89 c4             	mov    %rax,%r12
     d18:	84 db                	test   %bl,%bl
     d1a:	74 0c                	je     d28 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x38a>
     d1c:	48 8d 45 de          	lea    -0x22(%rbp),%rax
     d20:	48 89 c7             	mov    %rax,%rdi
     d23:	e8 00 00 00 00       	callq  d28 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x38a>
     d28:	4c 89 e3             	mov    %r12,%rbx
     d2b:	eb 03                	jmp    d30 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x392>
     d2d:	48 89 c3             	mov    %rax,%rbx
    }
  }

  // Check if we'd like to execute only some of the tests cases, as
  // indicated byt the --cases parameter.
  string cases;
     d30:	48 8d 45 80          	lea    -0x80(%rbp),%rax
     d34:	48 89 c7             	mov    %rax,%rdi
     d37:	e8 00 00 00 00       	callq  d3c <base::TestRegistry::runAndResetWithArgs(int, char**)+0x39e>
     d3c:	eb 03                	jmp    d41 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x3a3>
     d3e:	48 89 c3             	mov    %rax,%rbx
    errors += 1 /* one error, parsing */;
    exit = true;
  }

  // Check if we just want to learn the names of the test's cases.
  string list_only;
     d41:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
     d48:	48 89 c7             	mov    %rax,%rdi
     d4b:	e8 00 00 00 00       	callq  d50 <base::TestRegistry::runAndResetWithArgs(int, char**)+0x3b2>
     d50:	48 89 d8             	mov    %rbx,%rax
     d53:	48 89 c7             	mov    %rax,%rdi
     d56:	e8 00 00 00 00       	callq  d5b <base::TestRegistry::runAndResetWithArgs(int, char**)+0x3bd>
     d5b:	90                   	nop

0000000000000d5c <(anonymous namespace)::LockTester::~LockTester()>:
//

class LockTester {
public:
  LockTester(SpinlockMcs* spin, int* counter);
  ~LockTester() { }
     d5c:	55                   	push   %rbp
     d5d:	48 89 e5             	mov    %rsp,%rbp
     d60:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
     d64:	5d                   	pop    %rbp
     d65:	c3                   	retq   

0000000000000d66 <(anonymous namespace)::LockTester::requests() const>:

  void start(int increments);
  void join();

  int requests() const { return requests_; }
     d66:	55                   	push   %rbp
     d67:	48 89 e5             	mov    %rsp,%rbp
     d6a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
     d6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
     d72:	8b 40 10             	mov    0x10(%rax),%eax
     d75:	5d                   	pop    %rbp
     d76:	c3                   	retq   
     d77:	90                   	nop

0000000000000d78 <(anonymous namespace)::LockTester::LockTester(base::SpinlockMcs*, int*)>:
  // Non-copyable, non-assignable
  LockTester(LockTester&);
  LockTester& operator=(LockTester&);
};

LockTester::LockTester(SpinlockMcs* spin, int* counter)
     d78:	55                   	push   %rbp
     d79:	48 89 e5             	mov    %rsp,%rbp
     d7c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
     d80:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
     d84:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  : spin_(spin), counter_(counter), requests_(0) {
     d88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
     d8c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
     d90:	48 89 10             	mov    %rdx,(%rax)
     d93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
     d97:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
     d9b:	48 89 50 08          	mov    %rdx,0x8(%rax)
     d9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
     da3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
}
     daa:	5d                   	pop    %rbp
     dab:	c3                   	retq   

0000000000000dac <(anonymous namespace)::LockTester::start(int)>:

void LockTester::start(int increments) {
     dac:	55                   	push   %rbp
     dad:	48 89 e5             	mov    %rsp,%rbp
     db0:	48 83 ec 30          	sub    $0x30,%rsp
     db4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
     db8:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  Callback<void>* body = makeCallableOnce(&LockTester::test, this, increments);
     dbb:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
     dc2:	00 
     dc3:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
     dca:	00 
     dcb:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
     dce:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
     dd2:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
     dd6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
     dda:	48 89 f7             	mov    %rsi,%rdi
     ddd:	48 89 c6             	mov    %rax,%rsi
     de0:	e8 3e 06 00 00       	callq  1423 <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>* base::makeCallableOnce<(anonymous namespace)::LockTester, void, int>(void ((anonymous namespace)::LockTester::*)(int), (anonymous namespace)::LockTester*, int)>
     de5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  tid_ = makeThread(body);
     de9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
     ded:	48 89 c7             	mov    %rax,%rdi
     df0:	e8 00 00 00 00       	callq  df5 <(anonymous namespace)::LockTester::start(int)+0x49>
     df5:	48 89 c2             	mov    %rax,%rdx
     df8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
     dfc:	48 89 50 18          	mov    %rdx,0x18(%rax)
}
     e00:	c9                   	leaveq 
     e01:	c3                   	retq   

0000000000000e02 <(anonymous namespace)::LockTester::join()>:

void LockTester::join() {
     e02:	55                   	push   %rbp
     e03:	48 89 e5             	mov    %rsp,%rbp
     e06:	48 83 ec 10          	sub    $0x10,%rsp
     e0a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  pthread_join(tid_, NULL);
     e0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
     e12:	48 8b 40 18          	mov    0x18(%rax),%rax
     e16:	be 00 00 00 00       	mov    $0x0,%esi
     e1b:	48 89 c7             	mov    %rax,%rdi
     e1e:	e8 00 00 00 00       	callq  e23 <(anonymous namespace)::LockTester::join()+0x21>
}
     e23:	c9                   	leaveq 
     e24:	c3                   	retq   
     e25:	90                   	nop

0000000000000e26 <(anonymous namespace)::LockTester::test(int)>:

void LockTester::test(int increments) {
     e26:	55                   	push   %rbp
     e27:	48 89 e5             	mov    %rsp,%rbp
     e2a:	48 83 ec 10          	sub    $0x10,%rsp
     e2e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
     e32:	89 75 f4             	mov    %esi,-0xc(%rbp)
  while (increments-- > 0) {
     e35:	eb 3e                	jmp    e75 <(anonymous namespace)::LockTester::test(int)+0x4f>
    spin_->lock();
     e37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
     e3b:	48 8b 00             	mov    (%rax),%rax
     e3e:	48 89 c7             	mov    %rax,%rdi
     e41:	e8 00 00 00 00       	callq  e46 <(anonymous namespace)::LockTester::test(int)+0x20>
    ++(*counter_);
     e46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
     e4a:	48 8b 40 08          	mov    0x8(%rax),%rax
     e4e:	8b 10                	mov    (%rax),%edx
     e50:	83 c2 01             	add    $0x1,%edx
     e53:	89 10                	mov    %edx,(%rax)
    ++requests_;
     e55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
     e59:	8b 40 10             	mov    0x10(%rax),%eax
     e5c:	8d 50 01             	lea    0x1(%rax),%edx
     e5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
     e63:	89 50 10             	mov    %edx,0x10(%rax)
    spin_->unlock();
     e66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
     e6a:	48 8b 00             	mov    (%rax),%rax
     e6d:	48 89 c7             	mov    %rax,%rdi
     e70:	e8 00 00 00 00       	callq  e75 <(anonymous namespace)::LockTester::test(int)+0x4f>
void LockTester::join() {
  pthread_join(tid_, NULL);
}

void LockTester::test(int increments) {
  while (increments-- > 0) {
     e75:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
     e79:	0f 9f c0             	setg   %al
     e7c:	83 6d f4 01          	subl   $0x1,-0xc(%rbp)
     e80:	84 c0                	test   %al,%al
     e82:	75 b3                	jne    e37 <(anonymous namespace)::LockTester::test(int)+0x11>
    spin_->lock();
    ++(*counter_);
    ++requests_;
    spin_->unlock();
  }
}
     e84:	c9                   	leaveq 
     e85:	c3                   	retq   

0000000000000e86 <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()>:

// ************************************************************
// Test cases
//

TEST(Basic, LockUnlock) {
     e86:	55                   	push   %rbp
     e87:	48 89 e5             	mov    %rsp,%rbp
     e8a:	53                   	push   %rbx
     e8b:	48 83 ec 38          	sub    $0x38,%rsp
     e8f:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
     e93:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
     e97:	48 89 c7             	mov    %rax,%rdi
     e9a:	e8 00 00 00 00       	callq  e9f <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0x19>
     e9f:	48 8d 55 ef          	lea    -0x11(%rbp),%rdx
     ea3:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
     ea7:	be 00 00 00 00       	mov    $0x0,%esi
     eac:	48 89 c7             	mov    %rax,%rdi
     eaf:	e8 00 00 00 00       	callq  eb4 <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0x2e>
     eb4:	48 8d 45 ee          	lea    -0x12(%rbp),%rax
     eb8:	48 89 c7             	mov    %rax,%rdi
     ebb:	e8 00 00 00 00       	callq  ec0 <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0x3a>
     ec0:	48 8d 55 ee          	lea    -0x12(%rbp),%rdx
     ec4:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
     ec8:	be 00 00 00 00       	mov    $0x0,%esi
     ecd:	48 89 c7             	mov    %rax,%rdi
     ed0:	e8 00 00 00 00       	callq  ed5 <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0x4f>
     ed5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
     ed9:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
     edd:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
     ee1:	48 89 ce             	mov    %rcx,%rsi
     ee4:	48 89 c7             	mov    %rax,%rdi
     ee7:	e8 00 00 00 00       	callq  eec <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0x66>
     eec:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
     ef0:	48 89 c7             	mov    %rax,%rdi
     ef3:	e8 00 00 00 00       	callq  ef8 <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0x72>
     ef8:	48 8d 45 ee          	lea    -0x12(%rbp),%rax
     efc:	48 89 c7             	mov    %rax,%rdi
     eff:	e8 00 00 00 00       	callq  f04 <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0x7e>
     f04:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
     f08:	48 89 c7             	mov    %rax,%rdi
     f0b:	e8 00 00 00 00       	callq  f10 <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0x8a>
     f10:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
     f14:	48 89 c7             	mov    %rax,%rdi
     f17:	e8 00 00 00 00       	callq  f1c <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0x96>
     f1c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
     f20:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
     f27:	48 83 c4 38          	add    $0x38,%rsp
     f2b:	5b                   	pop    %rbx
     f2c:	5d                   	pop    %rbp
     f2d:	c3                   	retq   
     f2e:	48 89 c3             	mov    %rax,%rbx
     f31:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
     f35:	48 89 c7             	mov    %rax,%rdi
     f38:	e8 00 00 00 00       	callq  f3d <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0xb7>
     f3d:	eb 03                	jmp    f42 <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0xbc>
     f3f:	48 89 c3             	mov    %rax,%rbx
     f42:	48 8d 45 ee          	lea    -0x12(%rbp),%rax
     f46:	48 89 c7             	mov    %rax,%rdi
     f49:	e8 00 00 00 00       	callq  f4e <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0xc8>
     f4e:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
     f52:	48 89 c7             	mov    %rax,%rdi
     f55:	e8 00 00 00 00       	callq  f5a <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0xd4>
     f5a:	eb 03                	jmp    f5f <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0xd9>
     f5c:	48 89 c3             	mov    %rax,%rbx
     f5f:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
     f63:	48 89 c7             	mov    %rax,%rdi
     f66:	e8 00 00 00 00       	callq  f6b <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()+0xe5>
     f6b:	48 89 d8             	mov    %rbx,%rax
     f6e:	48 89 c7             	mov    %rax,%rdi
     f71:	e8 00 00 00 00       	callq  f76 <(anonymous namespace)::Basic_LockUnlock_Test::clear()>

0000000000000f76 <(anonymous namespace)::Basic_LockUnlock_Test::clear()>:
     f76:	55                   	push   %rbp
     f77:	48 89 e5             	mov    %rsp,%rbp
     f7a:	48 83 ec 20          	sub    $0x20,%rsp
     f7e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
     f82:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # f89 <(anonymous namespace)::Basic_LockUnlock_Test::clear()+0x13>
     f89:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
     f8d:	48 c7 05 00 00 00 00 	movq   $0x0,0x0(%rip)        # f98 <(anonymous namespace)::Basic_LockUnlock_Test::clear()+0x22>
     f94:	00 00 00 00 
     f98:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
     f9d:	74 17                	je     fb6 <(anonymous namespace)::Basic_LockUnlock_Test::clear()+0x40>
     f9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
     fa3:	48 8b 00             	mov    (%rax),%rax
     fa6:	48 83 c0 08          	add    $0x8,%rax
     faa:	48 8b 10             	mov    (%rax),%rdx
     fad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
     fb1:	48 89 c7             	mov    %rax,%rdi
     fb4:	ff d2                	callq  *%rdx
     fb6:	c9                   	leaveq 
     fb7:	c3                   	retq   

0000000000000fb8 <(anonymous namespace)::Basic_LockUnlock_Test::testBody()>:
     fb8:	55                   	push   %rbp
     fb9:	48 89 e5             	mov    %rsp,%rbp
     fbc:	48 83 ec 20          	sub    $0x20,%rsp
     fc0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  SpinlockMcs spinlock;
     fc4:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
     fc8:	48 89 c7             	mov    %rax,%rdi
     fcb:	e8 00 00 00 00       	callq  fd0 <(anonymous namespace)::Basic_LockUnlock_Test::testBody()+0x18>

  spinlock.lock();
     fd0:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
     fd4:	48 89 c7             	mov    %rax,%rdi
     fd7:	e8 00 00 00 00       	callq  fdc <(anonymous namespace)::Basic_LockUnlock_Test::testBody()+0x24>
  spinlock.unlock();
     fdc:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
     fe0:	48 89 c7             	mov    %rax,%rdi
     fe3:	e8 00 00 00 00       	callq  fe8 <(anonymous namespace)::Basic_LockUnlock_Test::testBody()+0x30>

  EXPECT_TRUE(true);
}
     fe8:	c9                   	leaveq 
     fe9:	c3                   	retq   

0000000000000fea <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()>:

TEST(Concurrency, counters) {
     fea:	55                   	push   %rbp
     feb:	48 89 e5             	mov    %rsp,%rbp
     fee:	53                   	push   %rbx
     fef:	48 83 ec 38          	sub    $0x38,%rsp
     ff3:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
     ff7:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
     ffb:	48 89 c7             	mov    %rax,%rdi
     ffe:	e8 00 00 00 00       	callq  1003 <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0x19>
    1003:	48 8d 55 ef          	lea    -0x11(%rbp),%rdx
    1007:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
    100b:	be 00 00 00 00       	mov    $0x0,%esi
    1010:	48 89 c7             	mov    %rax,%rdi
    1013:	e8 00 00 00 00       	callq  1018 <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0x2e>
    1018:	48 8d 45 ee          	lea    -0x12(%rbp),%rax
    101c:	48 89 c7             	mov    %rax,%rdi
    101f:	e8 00 00 00 00       	callq  1024 <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0x3a>
    1024:	48 8d 55 ee          	lea    -0x12(%rbp),%rdx
    1028:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
    102c:	be 00 00 00 00       	mov    $0x0,%esi
    1031:	48 89 c7             	mov    %rax,%rdi
    1034:	e8 00 00 00 00       	callq  1039 <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0x4f>
    1039:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    103d:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
    1041:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
    1045:	48 89 ce             	mov    %rcx,%rsi
    1048:	48 89 c7             	mov    %rax,%rdi
    104b:	e8 00 00 00 00       	callq  1050 <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0x66>
    1050:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
    1054:	48 89 c7             	mov    %rax,%rdi
    1057:	e8 00 00 00 00       	callq  105c <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0x72>
    105c:	48 8d 45 ee          	lea    -0x12(%rbp),%rax
    1060:	48 89 c7             	mov    %rax,%rdi
    1063:	e8 00 00 00 00       	callq  1068 <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0x7e>
    1068:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
    106c:	48 89 c7             	mov    %rax,%rdi
    106f:	e8 00 00 00 00       	callq  1074 <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0x8a>
    1074:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
    1078:	48 89 c7             	mov    %rax,%rdi
    107b:	e8 00 00 00 00       	callq  1080 <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0x96>
    1080:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    1084:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    108b:	48 83 c4 38          	add    $0x38,%rsp
    108f:	5b                   	pop    %rbx
    1090:	5d                   	pop    %rbp
    1091:	c3                   	retq   
    1092:	48 89 c3             	mov    %rax,%rbx
    1095:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
    1099:	48 89 c7             	mov    %rax,%rdi
    109c:	e8 00 00 00 00       	callq  10a1 <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0xb7>
    10a1:	eb 03                	jmp    10a6 <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0xbc>
    10a3:	48 89 c3             	mov    %rax,%rbx
    10a6:	48 8d 45 ee          	lea    -0x12(%rbp),%rax
    10aa:	48 89 c7             	mov    %rax,%rdi
    10ad:	e8 00 00 00 00       	callq  10b2 <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0xc8>
    10b2:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
    10b6:	48 89 c7             	mov    %rax,%rdi
    10b9:	e8 00 00 00 00       	callq  10be <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0xd4>
    10be:	eb 03                	jmp    10c3 <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0xd9>
    10c0:	48 89 c3             	mov    %rax,%rbx
    10c3:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
    10c7:	48 89 c7             	mov    %rax,%rdi
    10ca:	e8 00 00 00 00       	callq  10cf <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()+0xe5>
    10cf:	48 89 d8             	mov    %rbx,%rax
    10d2:	48 89 c7             	mov    %rax,%rdi
    10d5:	e8 00 00 00 00       	callq  10da <(anonymous namespace)::Concurrency_counters_Test::clear()>

00000000000010da <(anonymous namespace)::Concurrency_counters_Test::clear()>:
    10da:	55                   	push   %rbp
    10db:	48 89 e5             	mov    %rsp,%rbp
    10de:	48 83 ec 20          	sub    $0x20,%rsp
    10e2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    10e6:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 10ed <(anonymous namespace)::Concurrency_counters_Test::clear()+0x13>
    10ed:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    10f1:	48 c7 05 00 00 00 00 	movq   $0x0,0x0(%rip)        # 10fc <(anonymous namespace)::Concurrency_counters_Test::clear()+0x22>
    10f8:	00 00 00 00 
    10fc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    1101:	74 17                	je     111a <(anonymous namespace)::Concurrency_counters_Test::clear()+0x40>
    1103:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1107:	48 8b 00             	mov    (%rax),%rax
    110a:	48 83 c0 08          	add    $0x8,%rax
    110e:	48 8b 10             	mov    (%rax),%rdx
    1111:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1115:	48 89 c7             	mov    %rax,%rdi
    1118:	ff d2                	callq  *%rdx
    111a:	c9                   	leaveq 
    111b:	c3                   	retq   

000000000000111c <(anonymous namespace)::Concurrency_counters_Test::testBody()>:
    111c:	55                   	push   %rbp
    111d:	48 89 e5             	mov    %rsp,%rbp
    1120:	53                   	push   %rbx
    1121:	48 81 ec b8 00 00 00 	sub    $0xb8,%rsp
    1128:	48 89 bd 48 ff ff ff 	mov    %rdi,-0xb8(%rbp)
  SpinlockMcs spin;
    112f:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
    1133:	48 89 c7             	mov    %rax,%rdi
    1136:	e8 00 00 00 00       	callq  113b <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x1f>
  int counter = 0;
    113b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)

  const int threads = 16;
    1142:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%rbp)
  const int incs = 5000;
    1149:	c7 45 ec 88 13 00 00 	movl   $0x1388,-0x14(%rbp)
  LockTester* testers[threads];

  for (int i = 0; i < threads; i++) {
    1150:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
    1157:	eb 31                	jmp    118a <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x6e>
    testers[i] = new LockTester(&spin, &counter);
    1159:	bf 20 00 00 00       	mov    $0x20,%edi
    115e:	e8 00 00 00 00       	callq  1163 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x47>
    1163:	48 89 c3             	mov    %rax,%rbx
    1166:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
    116a:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
    116e:	48 89 c6             	mov    %rax,%rsi
    1171:	48 89 df             	mov    %rbx,%rdi
    1174:	e8 ff fb ff ff       	callq  d78 <(anonymous namespace)::LockTester::LockTester(base::SpinlockMcs*, int*)>
    1179:	8b 45 dc             	mov    -0x24(%rbp),%eax
    117c:	48 98                	cltq   
    117e:	48 89 9c c5 50 ff ff 	mov    %rbx,-0xb0(%rbp,%rax,8)
    1185:	ff 

  const int threads = 16;
  const int incs = 5000;
  LockTester* testers[threads];

  for (int i = 0; i < threads; i++) {
    1186:	83 45 dc 01          	addl   $0x1,-0x24(%rbp)
    118a:	83 7d dc 0f          	cmpl   $0xf,-0x24(%rbp)
    118e:	0f 9e c0             	setle  %al
    1191:	84 c0                	test   %al,%al
    1193:	75 c4                	jne    1159 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x3d>
    testers[i] = new LockTester(&spin, &counter);
  }
  for (int i = 0; i < threads; i++) {
    1195:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    119c:	eb 1e                	jmp    11bc <(anonymous namespace)::Concurrency_counters_Test::testBody()+0xa0>
    testers[i]->start(incs);
    119e:	8b 45 e0             	mov    -0x20(%rbp),%eax
    11a1:	48 98                	cltq   
    11a3:	48 8b 84 c5 50 ff ff 	mov    -0xb0(%rbp,%rax,8),%rax
    11aa:	ff 
    11ab:	be 88 13 00 00       	mov    $0x1388,%esi
    11b0:	48 89 c7             	mov    %rax,%rdi
    11b3:	e8 f4 fb ff ff       	callq  dac <(anonymous namespace)::LockTester::start(int)>
  LockTester* testers[threads];

  for (int i = 0; i < threads; i++) {
    testers[i] = new LockTester(&spin, &counter);
  }
  for (int i = 0; i < threads; i++) {
    11b8:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
    11bc:	83 7d e0 0f          	cmpl   $0xf,-0x20(%rbp)
    11c0:	0f 9e c0             	setle  %al
    11c3:	84 c0                	test   %al,%al
    11c5:	75 d7                	jne    119e <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x82>
    testers[i]->start(incs);
  }
  for (int i = 0; i < threads; i++) {
    11c7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
    11ce:	e9 3b 01 00 00       	jmpq   130e <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x1f2>
    testers[i]->join();
    11d3:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    11d6:	48 98                	cltq   
    11d8:	48 8b 84 c5 50 ff ff 	mov    -0xb0(%rbp,%rax,8),%rax
    11df:	ff 
    11e0:	48 89 c7             	mov    %rax,%rdi
    11e3:	e8 1a fc ff ff       	callq  e02 <(anonymous namespace)::LockTester::join()>
    EXPECT_EQ(testers[i]->requests(), incs);
    11e8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    11eb:	48 98                	cltq   
    11ed:	48 8b 84 c5 50 ff ff 	mov    -0xb0(%rbp,%rax,8),%rax
    11f4:	ff 
    11f5:	48 89 c7             	mov    %rax,%rdi
    11f8:	e8 69 fb ff ff       	callq  d66 <(anonymous namespace)::LockTester::requests() const>
    11fd:	3d 88 13 00 00       	cmp    $0x1388,%eax
    1202:	0f 95 c0             	setne  %al
    1205:	84 c0                	test   %al,%al
    1207:	0f 84 db 00 00 00    	je     12e8 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x1cc>
    120d:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
    1214:	48 89 c7             	mov    %rax,%rdi
    1217:	e8 00 00 00 00       	callq  121c <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x100>
    121c:	85 c0                	test   %eax,%eax
    121e:	0f 94 c0             	sete   %al
    1221:	84 c0                	test   %al,%al
    1223:	74 0f                	je     1234 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x118>
    1225:	be 00 00 00 00       	mov    $0x0,%esi
    122a:	bf 00 00 00 00       	mov    $0x0,%edi
    122f:	e8 00 00 00 00       	callq  1234 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x118>
    1234:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    1237:	48 98                	cltq   
    1239:	48 8b 84 c5 50 ff ff 	mov    -0xb0(%rbp,%rax,8),%rax
    1240:	ff 
    1241:	48 89 c7             	mov    %rax,%rdi
    1244:	e8 1d fb ff ff       	callq  d66 <(anonymous namespace)::LockTester::requests() const>
    1249:	89 c3                	mov    %eax,%ebx
    124b:	be 00 00 00 00       	mov    $0x0,%esi
    1250:	bf 00 00 00 00       	mov    $0x0,%edi
    1255:	e8 00 00 00 00       	callq  125a <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x13e>
    125a:	be 5c 00 00 00       	mov    $0x5c,%esi
    125f:	48 89 c7             	mov    %rax,%rdi
    1262:	e8 00 00 00 00       	callq  1267 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x14b>
    1267:	be 00 00 00 00       	mov    $0x0,%esi
    126c:	48 89 c7             	mov    %rax,%rdi
    126f:	e8 00 00 00 00       	callq  1274 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x158>
    1274:	be 00 00 00 00       	mov    $0x0,%esi
    1279:	48 89 c7             	mov    %rax,%rdi
    127c:	e8 00 00 00 00       	callq  1281 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x165>
    1281:	be 00 00 00 00       	mov    $0x0,%esi
    1286:	48 89 c7             	mov    %rax,%rdi
    1289:	e8 00 00 00 00       	callq  128e <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x172>
    128e:	be 00 00 00 00       	mov    $0x0,%esi
    1293:	48 89 c7             	mov    %rax,%rdi
    1296:	e8 00 00 00 00       	callq  129b <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x17f>
    129b:	be 00 00 00 00       	mov    $0x0,%esi
    12a0:	48 89 c7             	mov    %rax,%rdi
    12a3:	e8 00 00 00 00       	callq  12a8 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x18c>
    12a8:	89 de                	mov    %ebx,%esi
    12aa:	48 89 c7             	mov    %rax,%rdi
    12ad:	e8 00 00 00 00       	callq  12b2 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x196>
    12b2:	be 00 00 00 00       	mov    $0x0,%esi
    12b7:	48 89 c7             	mov    %rax,%rdi
    12ba:	e8 00 00 00 00       	callq  12bf <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x1a3>
    12bf:	be 88 13 00 00       	mov    $0x1388,%esi
    12c4:	48 89 c7             	mov    %rax,%rdi
    12c7:	e8 00 00 00 00       	callq  12cc <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x1b0>
    12cc:	be 00 00 00 00       	mov    $0x0,%esi
    12d1:	48 89 c7             	mov    %rax,%rdi
    12d4:	e8 00 00 00 00       	callq  12d9 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x1bd>
    12d9:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
    12e0:	48 89 c7             	mov    %rax,%rdi
    12e3:	e8 00 00 00 00       	callq  12e8 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x1cc>
    delete testers[i];
    12e8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    12eb:	48 98                	cltq   
    12ed:	48 8b 9c c5 50 ff ff 	mov    -0xb0(%rbp,%rax,8),%rbx
    12f4:	ff 
    12f5:	48 85 db             	test   %rbx,%rbx
    12f8:	74 10                	je     130a <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x1ee>
    12fa:	48 89 df             	mov    %rbx,%rdi
    12fd:	e8 5a fa ff ff       	callq  d5c <(anonymous namespace)::LockTester::~LockTester()>
    1302:	48 89 df             	mov    %rbx,%rdi
    1305:	e8 00 00 00 00       	callq  130a <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x1ee>
    testers[i] = new LockTester(&spin, &counter);
  }
  for (int i = 0; i < threads; i++) {
    testers[i]->start(incs);
  }
  for (int i = 0; i < threads; i++) {
    130a:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
    130e:	83 7d e4 0f          	cmpl   $0xf,-0x1c(%rbp)
    1312:	0f 9e c0             	setle  %al
    1315:	84 c0                	test   %al,%al
    1317:	0f 85 b6 fe ff ff    	jne    11d3 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0xb7>
    testers[i]->join();
    EXPECT_EQ(testers[i]->requests(), incs);
    delete testers[i];
  }

  EXPECT_EQ(counter, threads*incs);
    131d:	8b 45 d8             	mov    -0x28(%rbp),%eax
    1320:	3d 80 38 01 00       	cmp    $0x13880,%eax
    1325:	0f 84 c7 00 00 00    	je     13f2 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x2d6>
    132b:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
    1332:	48 89 c7             	mov    %rax,%rdi
    1335:	e8 00 00 00 00       	callq  133a <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x21e>
    133a:	85 c0                	test   %eax,%eax
    133c:	0f 94 c0             	sete   %al
    133f:	84 c0                	test   %al,%al
    1341:	74 0f                	je     1352 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x236>
    1343:	be 00 00 00 00       	mov    $0x0,%esi
    1348:	bf 00 00 00 00       	mov    $0x0,%edi
    134d:	e8 00 00 00 00       	callq  1352 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x236>
    1352:	8b 5d d8             	mov    -0x28(%rbp),%ebx
    1355:	be 00 00 00 00       	mov    $0x0,%esi
    135a:	bf 00 00 00 00       	mov    $0x0,%edi
    135f:	e8 00 00 00 00       	callq  1364 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x248>
    1364:	be 60 00 00 00       	mov    $0x60,%esi
    1369:	48 89 c7             	mov    %rax,%rdi
    136c:	e8 00 00 00 00       	callq  1371 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x255>
    1371:	be 00 00 00 00       	mov    $0x0,%esi
    1376:	48 89 c7             	mov    %rax,%rdi
    1379:	e8 00 00 00 00       	callq  137e <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x262>
    137e:	be 00 00 00 00       	mov    $0x0,%esi
    1383:	48 89 c7             	mov    %rax,%rdi
    1386:	e8 00 00 00 00       	callq  138b <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x26f>
    138b:	be 00 00 00 00       	mov    $0x0,%esi
    1390:	48 89 c7             	mov    %rax,%rdi
    1393:	e8 00 00 00 00       	callq  1398 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x27c>
    1398:	be 00 00 00 00       	mov    $0x0,%esi
    139d:	48 89 c7             	mov    %rax,%rdi
    13a0:	e8 00 00 00 00       	callq  13a5 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x289>
    13a5:	be 00 00 00 00       	mov    $0x0,%esi
    13aa:	48 89 c7             	mov    %rax,%rdi
    13ad:	e8 00 00 00 00       	callq  13b2 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x296>
    13b2:	89 de                	mov    %ebx,%esi
    13b4:	48 89 c7             	mov    %rax,%rdi
    13b7:	e8 00 00 00 00       	callq  13bc <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x2a0>
    13bc:	be 00 00 00 00       	mov    $0x0,%esi
    13c1:	48 89 c7             	mov    %rax,%rdi
    13c4:	e8 00 00 00 00       	callq  13c9 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x2ad>
    13c9:	be 80 38 01 00       	mov    $0x13880,%esi
    13ce:	48 89 c7             	mov    %rax,%rdi
    13d1:	e8 00 00 00 00       	callq  13d6 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x2ba>
    13d6:	be 00 00 00 00       	mov    $0x0,%esi
    13db:	48 89 c7             	mov    %rax,%rdi
    13de:	e8 00 00 00 00       	callq  13e3 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x2c7>
    13e3:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
    13ea:	48 89 c7             	mov    %rax,%rdi
    13ed:	e8 00 00 00 00       	callq  13f2 <(anonymous namespace)::Concurrency_counters_Test::testBody()+0x2d6>
}
    13f2:	48 81 c4 b8 00 00 00 	add    $0xb8,%rsp
    13f9:	5b                   	pop    %rbx
    13fa:	5d                   	pop    %rbp
    13fb:	c3                   	retq   

00000000000013fc <main>:

}  // unnamed namespace

int main(int argc, char *argv[]) {
    13fc:	55                   	push   %rbp
    13fd:	48 89 e5             	mov    %rsp,%rbp
    1400:	48 83 ec 10          	sub    $0x10,%rsp
    1404:	89 7d fc             	mov    %edi,-0x4(%rbp)
    1407:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  return RUN_TESTS(argc, argv);
    140b:	e8 00 00 00 00       	callq  1410 <main+0x14>
    1410:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
    1414:	8b 4d fc             	mov    -0x4(%rbp),%ecx
    1417:	89 ce                	mov    %ecx,%esi
    1419:	48 89 c7             	mov    %rax,%rdi
    141c:	e8 00 00 00 00       	callq  1421 <main+0x25>
}
    1421:	c9                   	leaveq 
    1422:	c3                   	retq   

0000000000001423 <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>* base::makeCallableOnce<(anonymous namespace)::LockTester, void, int>(void ((anonymous namespace)::LockTester::*)(int), (anonymous namespace)::LockTester*, int)>:
  Bind1 bind1_;
};

template<typename Target, typename Res, typename Bind1>
CallableOnce_1_1<Target, Res, Bind1>*
makeCallableOnce(
    1423:	55                   	push   %rbp
    1424:	48 89 e5             	mov    %rsp,%rbp
    1427:	41 54                	push   %r12
    1429:	53                   	push   %rbx
    142a:	48 83 ec 20          	sub    $0x20,%rsp
    142e:	48 89 f0             	mov    %rsi,%rax
    1431:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    1435:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
    1438:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
    143c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    Target* obj,
    Bind1 bind1) {
  return new CallableOnce_1_1<Target,Res, Bind1>(
    f,
    obj,
    bind1);
    1440:	bf 28 00 00 00       	mov    $0x28,%edi
    1445:	e8 00 00 00 00       	callq  144a <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>* base::makeCallableOnce<(anonymous namespace)::LockTester, void, int>(void ((anonymous namespace)::LockTester::*)(int), (anonymous namespace)::LockTester*, int)+0x27>
    144a:	48 89 c3             	mov    %rax,%rbx
    144d:	8b 75 d4             	mov    -0x2c(%rbp),%esi
    1450:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
    1454:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
    1458:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    145c:	41 89 f0             	mov    %esi,%r8d
    145f:	48 89 d6             	mov    %rdx,%rsi
    1462:	48 89 c2             	mov    %rax,%rdx
    1465:	48 89 df             	mov    %rbx,%rdi
    1468:	e8 23 00 00 00       	callq  1490 <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::CallableOnce_1_1(void ((anonymous namespace)::LockTester::*)(int), (anonymous namespace)::LockTester*, int)>
    146d:	48 89 d8             	mov    %rbx,%rax
}
    1470:	48 83 c4 20          	add    $0x20,%rsp
    1474:	5b                   	pop    %rbx
    1475:	41 5c                	pop    %r12
    1477:	5d                   	pop    %rbp
    1478:	c3                   	retq   
    1479:	49 89 c4             	mov    %rax,%r12
    Target* obj,
    Bind1 bind1) {
  return new CallableOnce_1_1<Target,Res, Bind1>(
    f,
    obj,
    bind1);
    147c:	48 89 df             	mov    %rbx,%rdi
    147f:	e8 00 00 00 00       	callq  1484 <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>* base::makeCallableOnce<(anonymous namespace)::LockTester, void, int>(void ((anonymous namespace)::LockTester::*)(int), (anonymous namespace)::LockTester*, int)+0x61>
    1484:	4c 89 e0             	mov    %r12,%rax
    1487:	48 89 c7             	mov    %rax,%rdi
    148a:	e8 00 00 00 00       	callq  148f <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>* base::makeCallableOnce<(anonymous namespace)::LockTester, void, int>(void ((anonymous namespace)::LockTester::*)(int), (anonymous namespace)::LockTester*, int)+0x6c>
    148f:	90                   	nop

0000000000001490 <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::CallableOnce_1_1(void ((anonymous namespace)::LockTester::*)(int), (anonymous namespace)::LockTester*, int)>:
  public Callback<void> {

public:
  typedef void(Target::*TargetFunc)(Bind1);

  CallableOnce_1_1(TargetFunc target_func,
    1490:	55                   	push   %rbp
    1491:	48 89 e5             	mov    %rsp,%rbp
    1494:	48 83 ec 30          	sub    $0x30,%rsp
    1498:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    149c:	48 89 d0             	mov    %rdx,%rax
    149f:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
    14a3:	44 89 45 dc          	mov    %r8d,-0x24(%rbp)
    14a7:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
    14ab:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    Target* obj,
    Bind1 bind1)
    : target_func_(target_func),
      obj_(obj),
      bind1_(bind1) { }
    14af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    14b3:	48 89 c7             	mov    %rax,%rdi
    14b6:	e8 00 00 00 00       	callq  14bb <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::CallableOnce_1_1(void ((anonymous namespace)::LockTester::*)(int), (anonymous namespace)::LockTester*, int)+0x2b>
    14bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    14bf:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    14c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    14ca:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
    14ce:	48 89 50 08          	mov    %rdx,0x8(%rax)
    14d2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
    14d6:	48 89 50 10          	mov    %rdx,0x10(%rax)
    14da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    14de:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
    14e2:	48 89 50 18          	mov    %rdx,0x18(%rax)
    14e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    14ea:	8b 55 dc             	mov    -0x24(%rbp),%edx
    14ed:	89 50 20             	mov    %edx,0x20(%rax)
    14f0:	c9                   	leaveq 
    14f1:	c3                   	retq   

00000000000014f2 <(anonymous namespace)::Concurrency_counters_Test::~Concurrency_counters_Test()>:
  spinlock.unlock();

  EXPECT_TRUE(true);
}

TEST(Concurrency, counters) {
    14f2:	55                   	push   %rbp
    14f3:	48 89 e5             	mov    %rsp,%rbp
    14f6:	48 83 ec 10          	sub    $0x10,%rsp
    14fa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    14fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1502:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    1509:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    150d:	48 89 c7             	mov    %rax,%rdi
    1510:	e8 00 00 00 00       	callq  1515 <(anonymous namespace)::Concurrency_counters_Test::~Concurrency_counters_Test()+0x23>
    1515:	b8 00 00 00 00       	mov    $0x0,%eax
    151a:	83 e0 01             	and    $0x1,%eax
    151d:	84 c0                	test   %al,%al
    151f:	74 0c                	je     152d <(anonymous namespace)::Concurrency_counters_Test::~Concurrency_counters_Test()+0x3b>
    1521:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1525:	48 89 c7             	mov    %rax,%rdi
    1528:	e8 00 00 00 00       	callq  152d <(anonymous namespace)::Concurrency_counters_Test::~Concurrency_counters_Test()+0x3b>
    152d:	c9                   	leaveq 
    152e:	c3                   	retq   
    152f:	90                   	nop

0000000000001530 <(anonymous namespace)::Concurrency_counters_Test::~Concurrency_counters_Test()>:
    1530:	55                   	push   %rbp
    1531:	48 89 e5             	mov    %rsp,%rbp
    1534:	48 83 ec 10          	sub    $0x10,%rsp
    1538:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    153c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1540:	48 89 c7             	mov    %rax,%rdi
    1543:	e8 aa ff ff ff       	callq  14f2 <(anonymous namespace)::Concurrency_counters_Test::~Concurrency_counters_Test()>
    1548:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    154c:	48 89 c7             	mov    %rax,%rdi
    154f:	e8 00 00 00 00       	callq  1554 <(anonymous namespace)::Concurrency_counters_Test::~Concurrency_counters_Test()+0x24>
    1554:	c9                   	leaveq 
    1555:	c3                   	retq   

0000000000001556 <(anonymous namespace)::Basic_LockUnlock_Test::~Basic_LockUnlock_Test()>:

// ************************************************************
// Test cases
//

TEST(Basic, LockUnlock) {
    1556:	55                   	push   %rbp
    1557:	48 89 e5             	mov    %rsp,%rbp
    155a:	48 83 ec 10          	sub    $0x10,%rsp
    155e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    1562:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1566:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    156d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1571:	48 89 c7             	mov    %rax,%rdi
    1574:	e8 00 00 00 00       	callq  1579 <(anonymous namespace)::Basic_LockUnlock_Test::~Basic_LockUnlock_Test()+0x23>
    1579:	b8 00 00 00 00       	mov    $0x0,%eax
    157e:	83 e0 01             	and    $0x1,%eax
    1581:	84 c0                	test   %al,%al
    1583:	74 0c                	je     1591 <(anonymous namespace)::Basic_LockUnlock_Test::~Basic_LockUnlock_Test()+0x3b>
    1585:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1589:	48 89 c7             	mov    %rax,%rdi
    158c:	e8 00 00 00 00       	callq  1591 <(anonymous namespace)::Basic_LockUnlock_Test::~Basic_LockUnlock_Test()+0x3b>
    1591:	c9                   	leaveq 
    1592:	c3                   	retq   
    1593:	90                   	nop

0000000000001594 <(anonymous namespace)::Basic_LockUnlock_Test::~Basic_LockUnlock_Test()>:
    1594:	55                   	push   %rbp
    1595:	48 89 e5             	mov    %rsp,%rbp
    1598:	48 83 ec 10          	sub    $0x10,%rsp
    159c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    15a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    15a4:	48 89 c7             	mov    %rax,%rdi
    15a7:	e8 aa ff ff ff       	callq  1556 <(anonymous namespace)::Basic_LockUnlock_Test::~Basic_LockUnlock_Test()>
    15ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    15b0:	48 89 c7             	mov    %rax,%rdi
    15b3:	e8 00 00 00 00       	callq  15b8 <(anonymous namespace)::Basic_LockUnlock_Test::~Basic_LockUnlock_Test()+0x24>
    15b8:	c9                   	leaveq 
    15b9:	c3                   	retq   

00000000000015ba <__static_initialization_and_destruction_0(int, int)>:

}  // unnamed namespace

int main(int argc, char *argv[]) {
  return RUN_TESTS(argc, argv);
}
    15ba:	55                   	push   %rbp
    15bb:	48 89 e5             	mov    %rsp,%rbp
    15be:	41 54                	push   %r12
    15c0:	53                   	push   %rbx
    15c1:	48 83 ec 10          	sub    $0x10,%rsp
    15c5:	89 7d ec             	mov    %edi,-0x14(%rbp)
    15c8:	89 75 e8             	mov    %esi,-0x18(%rbp)
    15cb:	83 7d ec 01          	cmpl   $0x1,-0x14(%rbp)
    15cf:	0f 85 b4 00 00 00    	jne    1689 <__static_initialization_and_destruction_0(int, int)+0xcf>
    15d5:	81 7d e8 ff ff 00 00 	cmpl   $0xffff,-0x18(%rbp)
    15dc:	0f 85 a7 00 00 00    	jne    1689 <__static_initialization_and_destruction_0(int, int)+0xcf>
  extern wostream wclog;	/// Linked to standard error (buffered)
#endif
  //@}

  // For construction of filebuffers for cout, cin, cerr, clog et. al.
  static ios_base::Init __ioinit;
    15e2:	bf 00 00 00 00       	mov    $0x0,%edi
    15e7:	e8 00 00 00 00       	callq  15ec <__static_initialization_and_destruction_0(int, int)+0x32>
    15ec:	b8 00 00 00 00       	mov    $0x0,%eax
    15f1:	ba 00 00 00 00       	mov    $0x0,%edx
    15f6:	be 00 00 00 00       	mov    $0x0,%esi
    15fb:	48 89 c7             	mov    %rax,%rdi
    15fe:	e8 00 00 00 00       	callq  1603 <__static_initialization_and_destruction_0(int, int)+0x49>

// ************************************************************
// Test cases
//

TEST(Basic, LockUnlock) {
    1603:	bf 20 00 00 00       	mov    $0x20,%edi
    1608:	e8 00 00 00 00       	callq  160d <__static_initialization_and_destruction_0(int, int)+0x53>
    160d:	48 89 c3             	mov    %rax,%rbx
    1610:	48 89 df             	mov    %rbx,%rdi
    1613:	e8 6e f8 ff ff       	callq  e86 <(anonymous namespace)::Basic_LockUnlock_Test::Basic_LockUnlock_Test()>
    1618:	e8 00 00 00 00       	callq  161d <__static_initialization_and_destruction_0(int, int)+0x63>
    161d:	48 89 de             	mov    %rbx,%rsi
    1620:	48 89 c7             	mov    %rax,%rdi
    1623:	e8 00 00 00 00       	callq  1628 <__static_initialization_and_destruction_0(int, int)+0x6e>
    1628:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 162f <__static_initialization_and_destruction_0(int, int)+0x75>
  spinlock.unlock();

  EXPECT_TRUE(true);
}

TEST(Concurrency, counters) {
    162f:	bf 20 00 00 00       	mov    $0x20,%edi
    1634:	e8 00 00 00 00       	callq  1639 <__static_initialization_and_destruction_0(int, int)+0x7f>
    1639:	48 89 c3             	mov    %rax,%rbx
    163c:	48 89 df             	mov    %rbx,%rdi
    163f:	e8 a6 f9 ff ff       	callq  fea <(anonymous namespace)::Concurrency_counters_Test::Concurrency_counters_Test()>
    1644:	e8 00 00 00 00       	callq  1649 <__static_initialization_and_destruction_0(int, int)+0x8f>
    1649:	48 89 de             	mov    %rbx,%rsi
    164c:	48 89 c7             	mov    %rax,%rdi
    164f:	e8 00 00 00 00       	callq  1654 <__static_initialization_and_destruction_0(int, int)+0x9a>
    1654:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 165b <__static_initialization_and_destruction_0(int, int)+0xa1>
    165b:	eb 2c                	jmp    1689 <__static_initialization_and_destruction_0(int, int)+0xcf>
    165d:	49 89 c4             	mov    %rax,%r12

// ************************************************************
// Test cases
//

TEST(Basic, LockUnlock) {
    1660:	48 89 df             	mov    %rbx,%rdi
    1663:	e8 00 00 00 00       	callq  1668 <__static_initialization_and_destruction_0(int, int)+0xae>
    1668:	4c 89 e0             	mov    %r12,%rax
    166b:	48 89 c7             	mov    %rax,%rdi
    166e:	e8 00 00 00 00       	callq  1673 <__static_initialization_and_destruction_0(int, int)+0xb9>
    1673:	49 89 c4             	mov    %rax,%r12
  spinlock.unlock();

  EXPECT_TRUE(true);
}

TEST(Concurrency, counters) {
    1676:	48 89 df             	mov    %rbx,%rdi
    1679:	e8 00 00 00 00       	callq  167e <__static_initialization_and_destruction_0(int, int)+0xc4>
    167e:	4c 89 e0             	mov    %r12,%rax
    1681:	48 89 c7             	mov    %rax,%rdi
    1684:	e8 00 00 00 00       	callq  1689 <__static_initialization_and_destruction_0(int, int)+0xcf>

}  // unnamed namespace

int main(int argc, char *argv[]) {
  return RUN_TESTS(argc, argv);
}
    1689:	48 83 c4 10          	add    $0x10,%rsp
    168d:	5b                   	pop    %rbx
    168e:	41 5c                	pop    %r12
    1690:	5d                   	pop    %rbp
    1691:	c3                   	retq   

0000000000001692 <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::~CallableOnce_1_1()>:

  virtual ~CallableOnce_1_1() {}
    1692:	55                   	push   %rbp
    1693:	48 89 e5             	mov    %rsp,%rbp
    1696:	48 83 ec 10          	sub    $0x10,%rsp
    169a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    169e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    16a2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    16a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    16ad:	48 89 c7             	mov    %rax,%rdi
    16b0:	e8 00 00 00 00       	callq  16b5 <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::~CallableOnce_1_1()+0x23>
    16b5:	b8 00 00 00 00       	mov    $0x0,%eax
    16ba:	83 e0 01             	and    $0x1,%eax
    16bd:	84 c0                	test   %al,%al
    16bf:	74 0c                	je     16cd <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::~CallableOnce_1_1()+0x3b>
    16c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    16c5:	48 89 c7             	mov    %rax,%rdi
    16c8:	e8 00 00 00 00       	callq  16cd <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::~CallableOnce_1_1()+0x3b>
    16cd:	c9                   	leaveq 
    16ce:	c3                   	retq   
    16cf:	90                   	nop

00000000000016d0 <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::~CallableOnce_1_1()>:
    16d0:	55                   	push   %rbp
    16d1:	48 89 e5             	mov    %rsp,%rbp
    16d4:	48 83 ec 10          	sub    $0x10,%rsp
    16d8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    16dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    16e0:	48 89 c7             	mov    %rax,%rdi
    16e3:	e8 aa ff ff ff       	callq  1692 <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::~CallableOnce_1_1()>
    16e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    16ec:	48 89 c7             	mov    %rax,%rdi
    16ef:	e8 00 00 00 00       	callq  16f4 <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::~CallableOnce_1_1()+0x24>
    16f4:	c9                   	leaveq 
    16f5:	c3                   	retq   

00000000000016f6 <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::operator()()>:

  virtual void operator()() {
    16f6:	55                   	push   %rbp
    16f7:	48 89 e5             	mov    %rsp,%rbp
    16fa:	48 83 ec 10          	sub    $0x10,%rsp
    16fe:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    ((*obj_).*target_func_)(bind1_);
    1702:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1706:	48 8b 40 08          	mov    0x8(%rax),%rax
    170a:	83 e0 01             	and    $0x1,%eax
    170d:	84 c0                	test   %al,%al
    170f:	74 2a                	je     173b <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::operator()()+0x45>
    1711:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    1715:	48 8b 50 18          	mov    0x18(%rax),%rdx
    1719:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    171d:	48 8b 40 10          	mov    0x10(%rax),%rax
    1721:	48 01 d0             	add    %rdx,%rax
    1724:	48 8b 10             	mov    (%rax),%rdx
    1727:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    172b:	48 8b 40 08          	mov    0x8(%rax),%rax
    172f:	48 83 e8 01          	sub    $0x1,%rax
    1733:	48 01 d0             	add    %rdx,%rax
    1736:	48 8b 00             	mov    (%rax),%rax
    1739:	eb 08                	jmp    1743 <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::operator()()+0x4d>
    173b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    173f:	48 8b 40 08          	mov    0x8(%rax),%rax
    1743:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    1747:	8b 52 20             	mov    0x20(%rdx),%edx
    174a:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
    174e:	48 8b 71 18          	mov    0x18(%rcx),%rsi
    1752:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
    1756:	48 8b 49 10          	mov    0x10(%rcx),%rcx
    175a:	48 01 f1             	add    %rsi,%rcx
    175d:	89 d6                	mov    %edx,%esi
    175f:	48 89 cf             	mov    %rcx,%rdi
    1762:	ff d0                	callq  *%rax
    delete this;
    1764:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
    1769:	74 17                	je     1782 <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::operator()()+0x8c>
    176b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    176f:	48 8b 00             	mov    (%rax),%rax
    1772:	48 83 c0 08          	add    $0x8,%rax
    1776:	48 8b 10             	mov    (%rax),%rdx
    1779:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    177d:	48 89 c7             	mov    %rax,%rdi
    1780:	ff d2                	callq  *%rdx
  }
    1782:	c9                   	leaveq 
    1783:	c3                   	retq   

0000000000001784 <base::CallableOnce_1_1<(anonymous namespace)::LockTester, void, int>::once() const>:

  virtual bool once() const {
    1784:	55                   	push   %rbp
    1785:	48 89 e5             	mov    %rsp,%rbp
    1788:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return true;
    178c:	b8 01 00 00 00       	mov    $0x1,%eax
  }
    1791:	5d                   	pop    %rbp
    1792:	c3                   	retq   

0000000000001793 <_GLOBAL__sub_I__ZN4base12TestRegistryC2Ev>:
    1793:	55                   	push   %rbp
    1794:	48 89 e5             	mov    %rsp,%rbp
    1797:	be ff ff 00 00       	mov    $0xffff,%esi
    179c:	bf 01 00 00 00       	mov    $0x1,%edi
    17a1:	e8 14 fe ff ff       	callq  15ba <__static_initialization_and_destruction_0(int, int)>
    17a6:	5d                   	pop    %rbp
    17a7:	c3                   	retq   

Disassembly of section .text._ZNSt11char_traitsIcE7compareEPKcS2_m:

0000000000000000 <std::char_traits<char>::compare(char const*, char const*, unsigned long)>:
      static _GLIBCXX_CONSTEXPR bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      { return __builtin_memcmp(__s1, __s2, __n); }
  14:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  18:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  20:	48 89 ce             	mov    %rcx,%rsi
  23:	48 89 c7             	mov    %rax,%rdi
  26:	e8 00 00 00 00       	callq  2b <std::char_traits<char>::compare(char const*, char const*, unsigned long)+0x2b>
  2b:	c9                   	leaveq 
  2c:	c3                   	retq   

Disassembly of section .text._ZnwmPv:

0000000000000000 <operator new(unsigned long, void*)>:
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();

// Default placement versions of operator new.
inline void* operator new(std::size_t, void* __p) throw() { return __p; }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  10:	5d                   	pop    %rbp
  11:	c3                   	retq   

Disassembly of section .text._ZdlPvS_:

0000000000000000 <operator delete(void*, void*)>:
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }

// Default placement versions of operator delete.
inline void  operator delete  (void*, void*) throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   c:	5d                   	pop    %rbp
   d:	c3                   	retq   

Disassembly of section .text._ZN4base4NodeC2Ev:

0000000000000000 <base::Node::Node()>:
public:
  bool locked;
  Node* next;
  unsigned int thread_id;

  Node() : locked(true), next(NULL) {}
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	c6 00 01             	movb   $0x1,(%rax)
   f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  13:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  1a:	00 
  1b:	5d                   	pop    %rbp
  1c:	c3                   	retq   

Disassembly of section .text._ZNVK4base4Node13loadLockStateEv:

0000000000000000 <base::Node::loadLockState() const volatile>:
 
  bool loadLockState() const volatile {
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return locked;
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	0f b6 00             	movzbl (%rax),%eax
  }
   f:	5d                   	pop    %rbp
  10:	c3                   	retq   

Disassembly of section .text._ZN4base11SpinlockMcsC2Ev:

0000000000000000 <base::SpinlockMcs::SpinlockMcs()>:
};

class SpinlockMcs {
public:
  SpinlockMcs()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    : tail(NULL) { }
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  13:	5d                   	pop    %rbp
  14:	c3                   	retq   

Disassembly of section .text._ZN4base11SpinlockMcs4lockEv:

0000000000000000 <base::SpinlockMcs::lock()>:

  void lock() {
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 28          	sub    $0x28,%rsp
   9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    Node* previous;
    Node* temp = new Node();
   d:	bf 18 00 00 00       	mov    $0x18,%edi
  12:	e8 00 00 00 00       	callq  17 <base::SpinlockMcs::lock()+0x17>
  17:	48 89 c3             	mov    %rax,%rbx
  1a:	48 89 df             	mov    %rbx,%rdi
  1d:	e8 00 00 00 00       	callq  22 <base::SpinlockMcs::lock()+0x22>
  22:	48 89 5d e0          	mov    %rbx,-0x20(%rbp)

    temp->thread_id = (unsigned int)pthread_self();
  26:	e8 00 00 00 00       	callq  2b <base::SpinlockMcs::lock()+0x2b>
  2b:	89 c2                	mov    %eax,%edx
  2d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  31:	89 50 10             	mov    %edx,0x10(%rax)

    previous = __sync_lock_test_and_set(&tail, temp);
  34:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  38:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  3c:	48 87 02             	xchg   %rax,(%rdx)
  3f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    if (previous != NULL) {
  43:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  48:	74 1e                	je     68 <base::SpinlockMcs::lock()+0x68>
      previous->next = temp;
  4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  52:	48 89 50 08          	mov    %rdx,0x8(%rax)
      
      while (temp->loadLockState());
  56:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  5a:	48 89 c7             	mov    %rax,%rdi
  5d:	e8 00 00 00 00       	callq  62 <base::SpinlockMcs::lock()+0x62>
  62:	84 c0                	test   %al,%al
  64:	75 f0                	jne    56 <base::SpinlockMcs::lock()+0x56>
  66:	eb 07                	jmp    6f <base::SpinlockMcs::lock()+0x6f>
    } else {
      temp->locked = false;
  68:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  6c:	c6 00 00             	movb   $0x0,(%rax)
    }
  }
  6f:	48 83 c4 28          	add    $0x28,%rsp
  73:	5b                   	pop    %rbx
  74:	5d                   	pop    %rbp
  75:	c3                   	retq   

Disassembly of section .text._ZN4base11SpinlockMcs6unlockEv:

0000000000000000 <base::SpinlockMcs::unlock()>:

  void unlock() {
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Node* lock_holder = tail;
   c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  10:	48 8b 00             	mov    (%rax),%rax
  13:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    while (lock_holder->loadLockState()) {  // traverse the queue to find unlocked node
  17:	eb 1e                	jmp    37 <base::SpinlockMcs::unlock()+0x37>
      while (lock_holder->next == NULL);    // wait for list to become consistent 
  19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1d:	48 8b 40 08          	mov    0x8(%rax),%rax
  21:	48 85 c0             	test   %rax,%rax
  24:	0f 94 c0             	sete   %al
  27:	84 c0                	test   %al,%al
  29:	75 ee                	jne    19 <base::SpinlockMcs::unlock()+0x19>

      lock_holder = lock_holder->next;
  2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  2f:	48 8b 40 08          	mov    0x8(%rax),%rax
  33:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  }

  void unlock() {
    Node* lock_holder = tail;

    while (lock_holder->loadLockState()) {  // traverse the queue to find unlocked node
  37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  3b:	48 89 c7             	mov    %rax,%rdi
  3e:	e8 00 00 00 00       	callq  43 <base::SpinlockMcs::unlock()+0x43>
  43:	84 c0                	test   %al,%al
  45:	75 d2                	jne    19 <base::SpinlockMcs::unlock()+0x19>
      while (lock_holder->next == NULL);    // wait for list to become consistent 

      lock_holder = lock_holder->next;
    }

    if (lock_holder->next == NULL) {
  47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4b:	48 8b 40 08          	mov    0x8(%rax),%rax
  4f:	48 85 c0             	test   %rax,%rax
  52:	75 39                	jne    8d <base::SpinlockMcs::unlock()+0x8d>
       if(__sync_bool_compare_and_swap(&tail, lock_holder, NULL)) {
  54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  58:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  5c:	b9 00 00 00 00       	mov    $0x0,%ecx
  61:	f0 48 0f b1 0a       	lock cmpxchg %rcx,(%rdx)
  66:	0f 94 c0             	sete   %al
  69:	84 c0                	test   %al,%al
  6b:	74 0e                	je     7b <base::SpinlockMcs::unlock()+0x7b>
          delete lock_holder;
  6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  71:	48 89 c7             	mov    %rax,%rdi
  74:	e8 00 00 00 00       	callq  79 <base::SpinlockMcs::unlock()+0x79>
          return;
  79:	eb 29                	jmp    a4 <base::SpinlockMcs::unlock()+0xa4>
       }

       while (lock_holder->next == NULL);
  7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  7f:	48 8b 40 08          	mov    0x8(%rax),%rax
  83:	48 85 c0             	test   %rax,%rax
  86:	0f 94 c0             	sete   %al
  89:	84 c0                	test   %al,%al
  8b:	75 ee                	jne    7b <base::SpinlockMcs::unlock()+0x7b>
    }

    lock_holder->next->locked = false;
  8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  91:	48 8b 40 08          	mov    0x8(%rax),%rax
  95:	c6 00 00             	movb   $0x0,(%rax)

    delete lock_holder;
  98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  9c:	48 89 c7             	mov    %rax,%rdi
  9f:	e8 00 00 00 00       	callq  a4 <base::SpinlockMcs::unlock()+0xa4>
  }
  a4:	c9                   	leaveq 
  a5:	c3                   	retq   

Disassembly of section .text._ZNKSt3tr18__detail18_Mod_range_hashingclEmm:

0000000000000000 <std::tr1::__detail::_Mod_range_hashing::operator()(unsigned long, unsigned long) const>:
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num, second_argument_type __den) const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
    { return __num % __den; }
  10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  14:	ba 00 00 00 00       	mov    $0x0,%edx
  19:	48 f7 75 e8          	divq   -0x18(%rbp)
  1d:	48 89 d0             	mov    %rdx,%rax
  20:	5d                   	pop    %rbp
  21:	c3                   	retq   

Disassembly of section .text._ZNSt3tr18__detail20_Prime_rehash_policyC2Ef:

0000000000000000 <std::tr1::__detail::_Prime_rehash_policy::_Prime_rehash_policy(float)>:

  // Default value for rehash policy.  Bucket size is (usually) the
  // smallest prime that keeps the load factor small enough.
  struct _Prime_rehash_policy
  {
    _Prime_rehash_policy(float __z = 1.0)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	f3 0f 11 45 f4       	movss  %xmm0,-0xc(%rbp)
    : _M_max_load_factor(__z), _M_growth_factor(2.f), _M_next_resize(0) { }
   d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  11:	8b 55 f4             	mov    -0xc(%rbp),%edx
  14:	89 10                	mov    %edx,(%rax)
  16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1a:	ba 00 00 00 40       	mov    $0x40000000,%edx
  1f:	89 50 04             	mov    %edx,0x4(%rax)
  22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  26:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  2d:	00 
  2e:	5d                   	pop    %rbp
  2f:	c3                   	retq   

Disassembly of section .text._ZNKSt3tr18__detail20_Prime_rehash_policy11_M_next_bktEm:

0000000000000000 <std::tr1::__detail::_Prime_rehash_policy::_M_next_bkt(unsigned long) const>:

  // Return a prime no smaller than n.
  inline std::size_t
  _Prime_rehash_policy::
  _M_next_bkt(std::size_t __n) const
  {
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    const unsigned long* __p = std::lower_bound(__prime_list, __prime_list
						+ _S_n_primes, __n);
  10:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  14:	48 89 c2             	mov    %rax,%rdx
  17:	be 00 00 00 00       	mov    $0x0,%esi
  1c:	bf 00 00 00 00       	mov    $0x0,%edi
  21:	e8 00 00 00 00       	callq  26 <std::tr1::__detail::_Prime_rehash_policy::_M_next_bkt(unsigned long) const+0x26>
  26:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    _M_next_resize = 
      static_cast<std::size_t>(__builtin_ceil(*__p * _M_max_load_factor));
  2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  2e:	48 8b 00             	mov    (%rax),%rax
  31:	48 85 c0             	test   %rax,%rax
  34:	78 07                	js     3d <std::tr1::__detail::_Prime_rehash_policy::_M_next_bkt(unsigned long) const+0x3d>
  36:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
  3b:	eb 15                	jmp    52 <std::tr1::__detail::_Prime_rehash_policy::_M_next_bkt(unsigned long) const+0x52>
  3d:	48 89 c2             	mov    %rax,%rdx
  40:	48 d1 ea             	shr    %rdx
  43:	83 e0 01             	and    $0x1,%eax
  46:	48 09 c2             	or     %rax,%rdx
  49:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
  4e:	f3 0f 58 c0          	addss  %xmm0,%xmm0
  52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  56:	f3 0f 10 08          	movss  (%rax),%xmm1
  5a:	f3 0f 59 c1          	mulss  %xmm1,%xmm0
  5e:	0f 14 c0             	unpcklps %xmm0,%xmm0
  61:	0f 5a c0             	cvtps2pd %xmm0,%xmm0
  64:	e8 00 00 00 00       	callq  69 <std::tr1::__detail::_Prime_rehash_policy::_M_next_bkt(unsigned long) const+0x69>
  69:	66 0f 2e 05 00 00 00 	ucomisd 0x0(%rip),%xmm0        # 71 <std::tr1::__detail::_Prime_rehash_policy::_M_next_bkt(unsigned long) const+0x71>
  70:	00 
  71:	73 07                	jae    7a <std::tr1::__detail::_Prime_rehash_policy::_M_next_bkt(unsigned long) const+0x7a>
  73:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
  78:	eb 1e                	jmp    98 <std::tr1::__detail::_Prime_rehash_policy::_M_next_bkt(unsigned long) const+0x98>
  7a:	f2 0f 10 0d 00 00 00 	movsd  0x0(%rip),%xmm1        # 82 <std::tr1::__detail::_Prime_rehash_policy::_M_next_bkt(unsigned long) const+0x82>
  81:	00 
  82:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
  86:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
  8b:	48 ba 00 00 00 00 00 	movabs $0x8000000000000000,%rdx
  92:	00 00 80 
  95:	48 31 d0             	xor    %rdx,%rax
  98:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  9c:	48 89 42 08          	mov    %rax,0x8(%rdx)
    return *__p;
  a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  a4:	48 8b 00             	mov    (%rax),%rax
  }
  a7:	c9                   	leaveq 
  a8:	c3                   	retq   

Disassembly of section .text._ZNKSt3tr18__detail20_Prime_rehash_policy14_M_need_rehashEmmm:

0000000000000000 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const>:

  inline std::pair<bool, std::size_t>
  _Prime_rehash_policy::
  _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
		 std::size_t __n_ins) const
  {
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
   b:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
   f:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  13:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  17:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
    if (__n_elt + __n_ins > _M_next_resize)
  1b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  1f:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  23:	48 01 c2             	add    %rax,%rdx
  26:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  2a:	48 8b 40 08          	mov    0x8(%rax),%rax
  2e:	48 39 c2             	cmp    %rax,%rdx
  31:	0f 86 65 02 00 00    	jbe    29c <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x29c>
      {
	float __min_bkts = ((float(__n_ins) + float(__n_elt))
			    / _M_max_load_factor);
  37:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  3b:	48 85 c0             	test   %rax,%rax
  3e:	78 07                	js     47 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x47>
  40:	f3 48 0f 2a c8       	cvtsi2ss %rax,%xmm1
  45:	eb 18                	jmp    5f <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x5f>
  47:	48 89 c2             	mov    %rax,%rdx
  4a:	48 d1 ea             	shr    %rdx
  4d:	83 e0 01             	and    $0x1,%eax
  50:	48 09 c2             	or     %rax,%rdx
  53:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
  58:	0f 28 c8             	movaps %xmm0,%xmm1
  5b:	f3 0f 58 c8          	addss  %xmm0,%xmm1
  5f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  63:	48 85 c0             	test   %rax,%rax
  66:	78 07                	js     6f <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x6f>
  68:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
  6d:	eb 15                	jmp    84 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x84>
  6f:	48 89 c2             	mov    %rax,%rdx
  72:	48 d1 ea             	shr    %rdx
  75:	83 e0 01             	and    $0x1,%eax
  78:	48 09 c2             	or     %rax,%rdx
  7b:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
  80:	f3 0f 58 c0          	addss  %xmm0,%xmm0
  84:	f3 0f 58 c1          	addss  %xmm1,%xmm0
  88:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8c:	f3 0f 10 08          	movss  (%rax),%xmm1
  90:	f3 0f 5e c1          	divss  %xmm1,%xmm0
  94:	f3 0f 11 45 f8       	movss  %xmm0,-0x8(%rbp)
	if (__min_bkts > __n_bkt)
  99:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  9d:	48 85 c0             	test   %rax,%rax
  a0:	78 07                	js     a9 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0xa9>
  a2:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
  a7:	eb 15                	jmp    be <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0xbe>
  a9:	48 89 c2             	mov    %rax,%rdx
  ac:	48 d1 ea             	shr    %rdx
  af:	83 e0 01             	and    $0x1,%eax
  b2:	48 09 c2             	or     %rax,%rdx
  b5:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
  ba:	f3 0f 58 c0          	addss  %xmm0,%xmm0
  be:	f3 0f 10 4d f8       	movss  -0x8(%rbp),%xmm1
  c3:	0f 2e c8             	ucomiss %xmm0,%xmm1
  c6:	0f 97 c0             	seta   %al
  c9:	84 c0                	test   %al,%al
  cb:	0f 84 20 01 00 00    	je     1f1 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x1f1>
	  {
	    __min_bkts = std::max(__min_bkts, _M_growth_factor * __n_bkt);
  d1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  d5:	f3 0f 10 48 04       	movss  0x4(%rax),%xmm1
  da:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  de:	48 85 c0             	test   %rax,%rax
  e1:	78 07                	js     ea <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0xea>
  e3:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
  e8:	eb 15                	jmp    ff <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0xff>
  ea:	48 89 c2             	mov    %rax,%rdx
  ed:	48 d1 ea             	shr    %rdx
  f0:	83 e0 01             	and    $0x1,%eax
  f3:	48 09 c2             	or     %rax,%rdx
  f6:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
  fb:	f3 0f 58 c0          	addss  %xmm0,%xmm0
  ff:	f3 0f 59 c1          	mulss  %xmm1,%xmm0
 103:	f3 0f 11 45 fc       	movss  %xmm0,-0x4(%rbp)
 108:	48 8d 55 fc          	lea    -0x4(%rbp),%rdx
 10c:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
 110:	48 89 d6             	mov    %rdx,%rsi
 113:	48 89 c7             	mov    %rax,%rdi
 116:	e8 00 00 00 00       	callq  11b <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x11b>
 11b:	8b 00                	mov    (%rax),%eax
 11d:	89 45 f8             	mov    %eax,-0x8(%rbp)
	    const unsigned long* __p =
	      std::lower_bound(__prime_list, __prime_list + _S_n_primes,
			       __min_bkts);
 120:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
 124:	48 89 c2             	mov    %rax,%rdx
 127:	be 00 00 00 00       	mov    $0x0,%esi
 12c:	bf 00 00 00 00       	mov    $0x0,%edi
 131:	e8 00 00 00 00       	callq  136 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x136>
 136:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	    _M_next_resize = static_cast<std::size_t>
	      (__builtin_ceil(*__p * _M_max_load_factor));
 13a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 13e:	48 8b 00             	mov    (%rax),%rax
 141:	48 85 c0             	test   %rax,%rax
 144:	78 07                	js     14d <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x14d>
 146:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
 14b:	eb 15                	jmp    162 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x162>
 14d:	48 89 c2             	mov    %rax,%rdx
 150:	48 d1 ea             	shr    %rdx
 153:	83 e0 01             	and    $0x1,%eax
 156:	48 09 c2             	or     %rax,%rdx
 159:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
 15e:	f3 0f 58 c0          	addss  %xmm0,%xmm0
 162:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 166:	f3 0f 10 08          	movss  (%rax),%xmm1
 16a:	f3 0f 59 c1          	mulss  %xmm1,%xmm0
 16e:	0f 14 c0             	unpcklps %xmm0,%xmm0
 171:	0f 5a c0             	cvtps2pd %xmm0,%xmm0
 174:	e8 00 00 00 00       	callq  179 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x179>
 179:	66 0f 2e 05 00 00 00 	ucomisd 0x0(%rip),%xmm0        # 181 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x181>
 180:	00 
 181:	73 07                	jae    18a <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x18a>
 183:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
 188:	eb 1e                	jmp    1a8 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x1a8>
 18a:	f2 0f 10 0d 00 00 00 	movsd  0x0(%rip),%xmm1        # 192 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x192>
 191:	00 
 192:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
 196:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
 19b:	48 ba 00 00 00 00 00 	movabs $0x8000000000000000,%rdx
 1a2:	00 00 80 
 1a5:	48 31 d0             	xor    %rdx,%rax
 1a8:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
 1ac:	48 89 42 08          	mov    %rax,0x8(%rdx)
	    return std::make_pair(true, *__p);
 1b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 1b4:	48 8b 00             	mov    (%rax),%rax
 1b7:	48 89 c6             	mov    %rax,%rsi
 1ba:	bf 01 00 00 00       	mov    $0x1,%edi
 1bf:	e8 00 00 00 00       	callq  1c4 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x1c4>
 1c4:	89 c1                	mov    %eax,%ecx
 1c6:	48 89 d0             	mov    %rdx,%rax
 1c9:	89 8d 70 ff ff ff    	mov    %ecx,-0x90(%rbp)
 1cf:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
 1d6:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
 1dd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
 1e1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
 1e8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
 1ec:	e9 e1 00 00 00       	jmpq   2d2 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x2d2>
	  }
	else 
	  {
	    _M_next_resize = static_cast<std::size_t>
	      (__builtin_ceil(__n_bkt * _M_max_load_factor));
 1f1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
 1f5:	48 85 c0             	test   %rax,%rax
 1f8:	78 07                	js     201 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x201>
 1fa:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
 1ff:	eb 15                	jmp    216 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x216>
 201:	48 89 c2             	mov    %rax,%rdx
 204:	48 d1 ea             	shr    %rdx
 207:	83 e0 01             	and    $0x1,%eax
 20a:	48 09 c2             	or     %rax,%rdx
 20d:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
 212:	f3 0f 58 c0          	addss  %xmm0,%xmm0
 216:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 21a:	f3 0f 10 08          	movss  (%rax),%xmm1
 21e:	f3 0f 59 c1          	mulss  %xmm1,%xmm0
 222:	0f 14 c0             	unpcklps %xmm0,%xmm0
 225:	0f 5a c0             	cvtps2pd %xmm0,%xmm0
 228:	e8 00 00 00 00       	callq  22d <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x22d>
 22d:	66 0f 2e 05 00 00 00 	ucomisd 0x0(%rip),%xmm0        # 235 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x235>
 234:	00 
 235:	73 07                	jae    23e <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x23e>
 237:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
 23c:	eb 1e                	jmp    25c <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x25c>
 23e:	f2 0f 10 0d 00 00 00 	movsd  0x0(%rip),%xmm1        # 246 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x246>
 245:	00 
 246:	f2 0f 5c c1          	subsd  %xmm1,%xmm0
 24a:	f2 48 0f 2c c0       	cvttsd2si %xmm0,%rax
 24f:	48 ba 00 00 00 00 00 	movabs $0x8000000000000000,%rdx
 256:	00 00 80 
 259:	48 31 d0             	xor    %rdx,%rax
 25c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
 260:	48 89 42 08          	mov    %rax,0x8(%rdx)
	    return std::make_pair(false, 0);
 264:	be 00 00 00 00       	mov    $0x0,%esi
 269:	bf 00 00 00 00       	mov    $0x0,%edi
 26e:	e8 00 00 00 00       	callq  273 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x273>
 273:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
 277:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
 27b:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
 27f:	48 89 d6             	mov    %rdx,%rsi
 282:	48 89 c7             	mov    %rax,%rdi
 285:	e8 00 00 00 00       	callq  28a <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x28a>
 28a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
 28e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
 292:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 296:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
 29a:	eb 36                	jmp    2d2 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x2d2>
	  }
      }
    else
      return std::make_pair(false, 0);
 29c:	be 00 00 00 00       	mov    $0x0,%esi
 2a1:	bf 00 00 00 00       	mov    $0x0,%edi
 2a6:	e8 00 00 00 00       	callq  2ab <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x2ab>
 2ab:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
 2af:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
 2b3:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
 2b7:	48 89 d6             	mov    %rdx,%rsi
 2ba:	48 89 c7             	mov    %rax,%rdi
 2bd:	e8 00 00 00 00       	callq  2c2 <std::tr1::__detail::_Prime_rehash_policy::_M_need_rehash(unsigned long, unsigned long, unsigned long) const+0x2c2>
 2c2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 2c6:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
 2ca:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 2ce:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
 2d2:	8b 45 c0             	mov    -0x40(%rbp),%eax
 2d5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  }
 2d9:	c9                   	leaveq 
 2da:	c3                   	retq   

Disassembly of section .text._ZNSt3tr115__unordered_mapISsSsNS_4hashISsEESt8equal_toISsESaISt4pairIKSsSsEELb0EED2Ev:

0000000000000000 <std::tr1::__unordered_map<std::string, std::string, std::tr1::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<std::string const, std::string> >, false>::~__unordered_map()>:
  template<class _Key, class _Tp,
	   class _Hash = hash<_Key>,
	   class _Pred = std::equal_to<_Key>,
	   class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
	   bool __cache_hash_code = false>
    class __unordered_map
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::tr1::__unordered_map<std::string, std::string, std::tr1::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<std::string const, std::string> >, false>::~__unordered_map()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZNSt3tr113unordered_mapISsSsNS_4hashISsEESt8equal_toISsESaISt4pairIKSsSsEEED2Ev:

0000000000000000 <std::tr1::unordered_map<std::string, std::string, std::tr1::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<std::string const, std::string> > >::~unordered_map()>:
   */
  template<class _Key, class _Tp,
	   class _Hash = hash<_Key>,
	   class _Pred = std::equal_to<_Key>,
	   class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class unordered_map
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::tr1::unordered_map<std::string, std::string, std::tr1::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<std::string const, std::string> > >::~unordered_map()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZN4base8ParamMapD2Ev:

0000000000000000 <base::ParamMap::~ParamMap()>:
//
// The class also produces "usage" descriptions.
class ParamMap {
public:
  ParamMap();
  ~ParamMap() {}
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 18          	sub    $0x18,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  11:	48 83 c0 60          	add    $0x60,%rax
  15:	48 89 c7             	mov    %rax,%rdi
  18:	e8 00 00 00 00       	callq  1d <base::ParamMap::~ParamMap()+0x1d>
  1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  21:	48 83 c0 30          	add    $0x30,%rax
  25:	48 89 c7             	mov    %rax,%rdi
  28:	e8 00 00 00 00       	callq  2d <base::ParamMap::~ParamMap()+0x2d>
  2d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  31:	48 89 c7             	mov    %rax,%rdi
  34:	e8 00 00 00 00       	callq  39 <base::ParamMap::~ParamMap()+0x39>
  39:	48 83 c4 18          	add    $0x18,%rsp
  3d:	5b                   	pop    %rbx
  3e:	5d                   	pop    %rbp
  3f:	c3                   	retq   
  40:	48 89 c3             	mov    %rax,%rbx
  43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  47:	48 83 c0 30          	add    $0x30,%rax
  4b:	48 89 c7             	mov    %rax,%rdi
  4e:	e8 00 00 00 00       	callq  53 <base::ParamMap::~ParamMap()+0x53>
  53:	eb 03                	jmp    58 <base::ParamMap::~ParamMap()+0x58>
  55:	48 89 c3             	mov    %rax,%rbx
  58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  5c:	48 89 c7             	mov    %rax,%rdi
  5f:	e8 00 00 00 00       	callq  64 <base::ParamMap::~ParamMap()+0x64>
  64:	48 89 d8             	mov    %rbx,%rax
  67:	48 89 c7             	mov    %rax,%rdi
  6a:	e8 00 00 00 00       	callq  6f <(anonymous namespace)::Concurrency_counters_Test::me_+0x57>

Disassembly of section .text._ZN4base8TestCaseD2Ev:

0000000000000000 <base::TestCase::~TestCase()>:
using std::tr1::unordered_map;
using std::vector;

class TestCase {
public:
  virtual ~TestCase() {}
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 18          	sub    $0x18,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  11:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1c:	48 83 c0 10          	add    $0x10,%rax
  20:	48 89 c7             	mov    %rax,%rdi
  23:	e8 00 00 00 00       	callq  28 <base::TestCase::~TestCase()+0x28>
  28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  2c:	48 83 c0 08          	add    $0x8,%rax
  30:	48 89 c7             	mov    %rax,%rdi
  33:	e8 00 00 00 00       	callq  38 <base::TestCase::~TestCase()+0x38>
  38:	b8 00 00 00 00       	mov    $0x0,%eax
  3d:	83 e0 01             	and    $0x1,%eax
  40:	84 c0                	test   %al,%al
  42:	74 2c                	je     70 <base::TestCase::~TestCase()+0x70>
  44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  48:	48 89 c7             	mov    %rax,%rdi
  4b:	e8 00 00 00 00       	callq  50 <base::TestCase::~TestCase()+0x50>
  50:	eb 1e                	jmp    70 <base::TestCase::~TestCase()+0x70>
  52:	48 89 c3             	mov    %rax,%rbx
  55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  59:	48 83 c0 08          	add    $0x8,%rax
  5d:	48 89 c7             	mov    %rax,%rdi
  60:	e8 00 00 00 00       	callq  65 <base::TestCase::~TestCase()+0x65>
  65:	48 89 d8             	mov    %rbx,%rax
  68:	48 89 c7             	mov    %rax,%rdi
  6b:	e8 00 00 00 00       	callq  70 <base::TestCase::~TestCase()+0x70>
  70:	48 83 c4 18          	add    $0x18,%rsp
  74:	5b                   	pop    %rbx
  75:	5d                   	pop    %rbp
  76:	c3                   	retq   

Disassembly of section .text._ZN4base8TestCaseD0Ev:

0000000000000000 <base::TestCase::~TestCase()>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <base::TestCase::~TestCase()+0x18>
  18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1c:	48 89 c7             	mov    %rax,%rdi
  1f:	e8 00 00 00 00       	callq  24 <base::TestCase::~TestCase()+0x24>
  24:	c9                   	leaveq 
  25:	c3                   	retq   

Disassembly of section .text._ZNK4base8TestCase4nameEv:

0000000000000000 <base::TestCase::name() const>:

  virtual void testBody() = 0;
  virtual void clear() = 0;

  const string& group() const { return group_; }
  const string& name() const { return name_; }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	48 83 c0 10          	add    $0x10,%rax
  10:	5d                   	pop    %rbp
  11:	c3                   	retq   

Disassembly of section .text._ZNK4base8TestCase8fullNameEv:

0000000000000000 <base::TestCase::fullName() const>:
  string fullName() const { return group_ + "(" + name_ + ")"; }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 38          	sub    $0x38,%rsp
   9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
   d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  11:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  15:	48 8d 58 10          	lea    0x10(%rax),%rbx
  19:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  1d:	48 8d 48 08          	lea    0x8(%rax),%rcx
  21:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  25:	ba 00 00 00 00       	mov    $0x0,%edx
  2a:	48 89 ce             	mov    %rcx,%rsi
  2d:	48 89 c7             	mov    %rax,%rdi
  30:	e8 00 00 00 00       	callq  35 <base::TestCase::fullName() const+0x35>
  35:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  39:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  3d:	48 89 da             	mov    %rbx,%rdx
  40:	48 89 ce             	mov    %rcx,%rsi
  43:	48 89 c7             	mov    %rax,%rdi
  46:	e8 00 00 00 00       	callq  4b <base::TestCase::fullName() const+0x4b>
  4b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  4f:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  53:	ba 00 00 00 00       	mov    $0x0,%edx
  58:	48 89 ce             	mov    %rcx,%rsi
  5b:	48 89 c7             	mov    %rax,%rdi
  5e:	e8 00 00 00 00       	callq  63 <base::TestCase::fullName() const+0x63>
  63:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  67:	48 89 c7             	mov    %rax,%rdi
  6a:	e8 00 00 00 00       	callq  6f <base::TestCase::fullName() const+0x6f>
  6f:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  73:	48 89 c7             	mov    %rax,%rdi
  76:	e8 00 00 00 00       	callq  7b <base::TestCase::fullName() const+0x7b>
  7b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  7f:	48 83 c4 38          	add    $0x38,%rsp
  83:	5b                   	pop    %rbx
  84:	5d                   	pop    %rbp
  85:	c3                   	retq   
  86:	48 89 c3             	mov    %rax,%rbx
  89:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8d:	48 89 c7             	mov    %rax,%rdi
  90:	e8 00 00 00 00       	callq  95 <base::TestCase::fullName() const+0x95>
  95:	eb 03                	jmp    9a <base::TestCase::fullName() const+0x9a>
  97:	48 89 c3             	mov    %rax,%rbx
  9a:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  9e:	48 89 c7             	mov    %rax,%rdi
  a1:	e8 00 00 00 00       	callq  a6 <base::TestCase::fullName() const+0xa6>
  a6:	48 89 d8             	mov    %rbx,%rax
  a9:	48 89 c7             	mov    %rax,%rdi
  ac:	e8 00 00 00 00       	callq  b1 <(anonymous namespace)::Concurrency_counters_Test::me_+0x99>

Disassembly of section .text._ZNK4base8TestCase6errorsEv:

0000000000000000 <base::TestCase::errors() const>:
  int errors() const { return errors_; }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	8b 40 18             	mov    0x18(%rax),%eax
   f:	5d                   	pop    %rbp
  10:	c3                   	retq   

Disassembly of section .text._ZN4base8TestCaseC2ERKSsS2_:

0000000000000000 <base::TestCase::TestCase(std::string const&, std::string const&)>:

protected:
  TestCase(const string& group, const string& name)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 28          	sub    $0x28,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  11:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    : group_(group), name_(name), errors_(0) {}
  15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  19:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  24:	48 8d 50 08          	lea    0x8(%rax),%rdx
  28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  2c:	48 89 c6             	mov    %rax,%rsi
  2f:	48 89 d7             	mov    %rdx,%rdi
  32:	e8 00 00 00 00       	callq  37 <base::TestCase::TestCase(std::string const&, std::string const&)+0x37>
  37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  3b:	48 8d 50 10          	lea    0x10(%rax),%rdx
  3f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  43:	48 89 c6             	mov    %rax,%rsi
  46:	48 89 d7             	mov    %rdx,%rdi
  49:	e8 00 00 00 00       	callq  4e <base::TestCase::TestCase(std::string const&, std::string const&)+0x4e>
  4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  52:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  59:	48 83 c4 28          	add    $0x28,%rsp
  5d:	5b                   	pop    %rbx
  5e:	5d                   	pop    %rbp
  5f:	c3                   	retq   
  60:	48 89 c3             	mov    %rax,%rbx
  63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  67:	48 83 c0 08          	add    $0x8,%rax
  6b:	48 89 c7             	mov    %rax,%rdi
  6e:	e8 00 00 00 00       	callq  73 <base::TestCase::TestCase(std::string const&, std::string const&)+0x73>
  73:	48 89 d8             	mov    %rbx,%rax
  76:	48 89 c7             	mov    %rax,%rdi
  79:	e8 00 00 00 00       	callq  7e <(anonymous namespace)::Concurrency_counters_Test::me_+0x66>

Disassembly of section .text._ZN4base8TestCase9incErrorsEv:

0000000000000000 <base::TestCase::incErrors()>:

  void incErrors()     { ++errors_; }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	8b 40 18             	mov    0x18(%rax),%eax
   f:	8d 50 01             	lea    0x1(%rax),%edx
  12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  16:	89 50 18             	mov    %edx,0x18(%rax)
  19:	5d                   	pop    %rbp
  1a:	c3                   	retq   

Disassembly of section .text._ZN4base12TestRegistryD2Ev:

0000000000000000 <base::TestRegistry::~TestRegistry()>:

};

class TestRegistry {
public:
  ~TestRegistry() {}
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 18          	sub    $0x18,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  11:	48 83 c0 18          	add    $0x18,%rax
  15:	48 89 c7             	mov    %rax,%rdi
  18:	e8 00 00 00 00       	callq  1d <base::TestRegistry::~TestRegistry()+0x1d>
  1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  21:	48 89 c7             	mov    %rax,%rdi
  24:	e8 00 00 00 00       	callq  29 <base::TestRegistry::~TestRegistry()+0x29>
  29:	48 83 c4 18          	add    $0x18,%rsp
  2d:	5b                   	pop    %rbx
  2e:	5d                   	pop    %rbp
  2f:	c3                   	retq   
  30:	48 89 c3             	mov    %rax,%rbx
  33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  37:	48 89 c7             	mov    %rax,%rdi
  3a:	e8 00 00 00 00       	callq  3f <base::TestRegistry::~TestRegistry()+0x3f>
  3f:	48 89 d8             	mov    %rbx,%rax
  42:	48 89 c7             	mov    %rax,%rdi
  45:	e8 00 00 00 00       	callq  4a <(anonymous namespace)::Concurrency_counters_Test::me_+0x32>

Disassembly of section .text._ZNSt3tr115__unordered_mapISsbNS_4hashISsEESt8equal_toISsESaISt4pairIKSsbEELb0EED2Ev:

0000000000000000 <std::tr1::__unordered_map<std::string, bool, std::tr1::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<std::string const, bool> >, false>::~__unordered_map()>:
  template<class _Key, class _Tp,
	   class _Hash = hash<_Key>,
	   class _Pred = std::equal_to<_Key>,
	   class _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
	   bool __cache_hash_code = false>
    class __unordered_map
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::tr1::__unordered_map<std::string, bool, std::tr1::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<std::string const, bool> >, false>::~__unordered_map()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZNSt3tr113unordered_mapISsbNS_4hashISsEESt8equal_toISsESaISt4pairIKSsbEEED2Ev:

0000000000000000 <std::tr1::unordered_map<std::string, bool, std::tr1::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<std::string const, bool> > >::~unordered_map()>:
   */
  template<class _Key, class _Tp,
	   class _Hash = hash<_Key>,
	   class _Pred = std::equal_to<_Key>,
	   class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class unordered_map
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::tr1::unordered_map<std::string, bool, std::tr1::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<std::string const, bool> > >::~unordered_map()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZNSt4pairISsbED2Ev:

0000000000000000 <std::pair<std::string, bool>::~pair()>:
    struct _Index_tuple;
#endif

  /// Struct holding two objects of arbitrary type.
  template<class _T1, class _T2>
    struct pair
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::pair<std::string, bool>::~pair()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZNSt4pairIKSsbED2Ev:

0000000000000000 <std::pair<std::string const, bool>::~pair()>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::pair<std::string const, bool>::~pair()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZSt11lower_boundIPKmmET_S2_S2_RKT0_:

0000000000000000 <unsigned long const* std::lower_bound<unsigned long const*, unsigned long>(unsigned long const*, unsigned long const*, unsigned long const&)>:
   *                  @a val.
   *  @ingroup binary_search_algorithms
  */
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 40          	sub    $0x40,%rsp
   8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
   c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  10:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanOpConcept<_ValueType, _Tp>)
      __glibcxx_requires_partitioned_lower(__first, __last, __val);

      _DistanceType __len = std::distance(__first, __last);
  14:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  18:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  1c:	48 89 d6             	mov    %rdx,%rsi
  1f:	48 89 c7             	mov    %rax,%rdi
  22:	e8 00 00 00 00       	callq  27 <unsigned long const* std::lower_bound<unsigned long const*, unsigned long>(unsigned long const*, unsigned long const*, unsigned long const&)+0x27>
  27:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

      while (__len > 0)
  2b:	eb 69                	jmp    96 <unsigned long const* std::lower_bound<unsigned long const*, unsigned long>(unsigned long const*, unsigned long const*, unsigned long const&)+0x96>
	{
	  _DistanceType __half = __len >> 1;
  2d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  31:	48 d1 f8             	sar    %rax
  34:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	  _ForwardIterator __middle = __first;
  38:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  3c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	  std::advance(__middle, __half);
  40:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  44:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  48:	48 89 d6             	mov    %rdx,%rsi
  4b:	48 89 c7             	mov    %rax,%rdi
  4e:	e8 00 00 00 00       	callq  53 <unsigned long const* std::lower_bound<unsigned long const*, unsigned long>(unsigned long const*, unsigned long const*, unsigned long const&)+0x53>
	  if (*__middle < __val)
  53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  57:	48 8b 10             	mov    (%rax),%rdx
  5a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  5e:	48 8b 00             	mov    (%rax),%rax
  61:	48 39 c2             	cmp    %rax,%rdx
  64:	73 28                	jae    8e <unsigned long const* std::lower_bound<unsigned long const*, unsigned long>(unsigned long const*, unsigned long const*, unsigned long const&)+0x8e>
	    {
	      __first = __middle;
  66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  6a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	      ++__first;
  6e:	48 83 45 d8 08       	addq   $0x8,-0x28(%rbp)
	      __len = __len - __half - 1;
  73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  77:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  7b:	48 89 d1             	mov    %rdx,%rcx
  7e:	48 29 c1             	sub    %rax,%rcx
  81:	48 89 c8             	mov    %rcx,%rax
  84:	48 83 e8 01          	sub    $0x1,%rax
  88:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8c:	eb 08                	jmp    96 <unsigned long const* std::lower_bound<unsigned long const*, unsigned long>(unsigned long const*, unsigned long const*, unsigned long const&)+0x96>
	    }
	  else
	    __len = __half;
  8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  92:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      __glibcxx_function_requires(_LessThanOpConcept<_ValueType, _Tp>)
      __glibcxx_requires_partitioned_lower(__first, __last, __val);

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
  96:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  9b:	0f 9f c0             	setg   %al
  9e:	84 c0                	test   %al,%al
  a0:	75 8b                	jne    2d <unsigned long const* std::lower_bound<unsigned long const*, unsigned long>(unsigned long const*, unsigned long const*, unsigned long const&)+0x2d>
	      __len = __len - __half - 1;
	    }
	  else
	    __len = __half;
	}
      return __first;
  a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    }
  a6:	c9                   	leaveq 
  a7:	c3                   	retq   

Disassembly of section .text._ZSt11lower_boundIPKmfET_S2_S2_RKT0_:

0000000000000000 <unsigned long const* std::lower_bound<unsigned long const*, float>(unsigned long const*, unsigned long const*, float const&)>:
   *                  @a val.
   *  @ingroup binary_search_algorithms
  */
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 40          	sub    $0x40,%rsp
   8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
   c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  10:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
      // concept requirements
      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
      __glibcxx_function_requires(_LessThanOpConcept<_ValueType, _Tp>)
      __glibcxx_requires_partitioned_lower(__first, __last, __val);

      _DistanceType __len = std::distance(__first, __last);
  14:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  18:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  1c:	48 89 d6             	mov    %rdx,%rsi
  1f:	48 89 c7             	mov    %rax,%rdi
  22:	e8 00 00 00 00       	callq  27 <unsigned long const* std::lower_bound<unsigned long const*, float>(unsigned long const*, unsigned long const*, float const&)+0x27>
  27:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

      while (__len > 0)
  2b:	e9 90 00 00 00       	jmpq   c0 <unsigned long const* std::lower_bound<unsigned long const*, float>(unsigned long const*, unsigned long const*, float const&)+0xc0>
	{
	  _DistanceType __half = __len >> 1;
  30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  34:	48 d1 f8             	sar    %rax
  37:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	  _ForwardIterator __middle = __first;
  3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  3f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	  std::advance(__middle, __half);
  43:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  47:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  4b:	48 89 d6             	mov    %rdx,%rsi
  4e:	48 89 c7             	mov    %rax,%rdi
  51:	e8 00 00 00 00       	callq  56 <unsigned long const* std::lower_bound<unsigned long const*, float>(unsigned long const*, unsigned long const*, float const&)+0x56>
	  if (*__middle < __val)
  56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  5a:	48 8b 00             	mov    (%rax),%rax
  5d:	48 85 c0             	test   %rax,%rax
  60:	78 07                	js     69 <unsigned long const* std::lower_bound<unsigned long const*, float>(unsigned long const*, unsigned long const*, float const&)+0x69>
  62:	f3 48 0f 2a c0       	cvtsi2ss %rax,%xmm0
  67:	eb 15                	jmp    7e <unsigned long const* std::lower_bound<unsigned long const*, float>(unsigned long const*, unsigned long const*, float const&)+0x7e>
  69:	48 89 c2             	mov    %rax,%rdx
  6c:	48 d1 ea             	shr    %rdx
  6f:	83 e0 01             	and    $0x1,%eax
  72:	48 09 c2             	or     %rax,%rdx
  75:	f3 48 0f 2a c2       	cvtsi2ss %rdx,%xmm0
  7a:	f3 0f 58 c0          	addss  %xmm0,%xmm0
  7e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  82:	f3 0f 10 08          	movss  (%rax),%xmm1
  86:	0f 2e c8             	ucomiss %xmm0,%xmm1
  89:	0f 97 c0             	seta   %al
  8c:	84 c0                	test   %al,%al
  8e:	74 28                	je     b8 <unsigned long const* std::lower_bound<unsigned long const*, float>(unsigned long const*, unsigned long const*, float const&)+0xb8>
	    {
	      __first = __middle;
  90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  94:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	      ++__first;
  98:	48 83 45 d8 08       	addq   $0x8,-0x28(%rbp)
	      __len = __len - __half - 1;
  9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  a1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  a5:	48 89 d1             	mov    %rdx,%rcx
  a8:	48 29 c1             	sub    %rax,%rcx
  ab:	48 89 c8             	mov    %rcx,%rax
  ae:	48 83 e8 01          	sub    $0x1,%rax
  b2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  b6:	eb 08                	jmp    c0 <unsigned long const* std::lower_bound<unsigned long const*, float>(unsigned long const*, unsigned long const*, float const&)+0xc0>
	    }
	  else
	    __len = __half;
  b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  bc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      __glibcxx_function_requires(_LessThanOpConcept<_ValueType, _Tp>)
      __glibcxx_requires_partitioned_lower(__first, __last, __val);

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
  c0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  c5:	0f 9f c0             	setg   %al
  c8:	84 c0                	test   %al,%al
  ca:	0f 85 60 ff ff ff    	jne    30 <unsigned long const* std::lower_bound<unsigned long const*, float>(unsigned long const*, unsigned long const*, float const&)+0x30>
	      __len = __len - __half - 1;
	    }
	  else
	    __len = __half;
	}
      return __first;
  d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    }
  d4:	c9                   	leaveq 
  d5:	c3                   	retq   

Disassembly of section .text._ZSt3maxIfERKT_S2_S2_:

0000000000000000 <float const& std::max<float>(float const&, float const&)>:
   *  temporary expressions, since they are only evaluated once, unlike a
   *  preprocessor macro.
  */
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	f3 0f 10 08          	movss  (%rax),%xmm1
  14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  18:	f3 0f 10 00          	movss  (%rax),%xmm0
  1c:	0f 2e c1             	ucomiss %xmm1,%xmm0
  1f:	0f 97 c0             	seta   %al
  22:	84 c0                	test   %al,%al
  24:	74 06                	je     2c <float const& std::max<float>(float const&, float const&)+0x2c>
	return __b;
  26:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  2a:	eb 04                	jmp    30 <float const& std::max<float>(float const&, float const&)+0x30>
      return __a;
  2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    }
  30:	5d                   	pop    %rbp
  31:	c3                   	retq   

Disassembly of section .text._ZSt9make_pairIbmESt4pairIT_T0_ES1_S2_:

0000000000000000 <std::pair<bool, unsigned long> std::make_pair<bool, unsigned long>(bool, unsigned long)>:
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
#else
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 40          	sub    $0x40,%rsp
   8:	89 f8                	mov    %edi,%eax
   a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
   e:	88 45 dc             	mov    %al,-0x24(%rbp)
    { return pair<_T1, _T2>(__x, __y); }
  11:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  15:	48 8d 4d dc          	lea    -0x24(%rbp),%rcx
  19:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  1d:	48 89 ce             	mov    %rcx,%rsi
  20:	48 89 c7             	mov    %rax,%rdi
  23:	e8 00 00 00 00       	callq  28 <std::pair<bool, unsigned long> std::make_pair<bool, unsigned long>(bool, unsigned long)+0x28>
  28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  2c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  30:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  34:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  38:	8b 45 f0             	mov    -0x10(%rbp),%eax
  3b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  3f:	c9                   	leaveq 
  40:	c3                   	retq   

Disassembly of section .text._ZSt9make_pairIbiESt4pairIT_T0_ES1_S2_:

0000000000000000 <std::pair<bool, int> std::make_pair<bool, int>(bool, int)>:
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
#else
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	89 f8                	mov    %edi,%eax
   a:	89 75 e8             	mov    %esi,-0x18(%rbp)
   d:	88 45 ec             	mov    %al,-0x14(%rbp)
    { return pair<_T1, _T2>(__x, __y); }
  10:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  14:	48 8d 4d ec          	lea    -0x14(%rbp),%rcx
  18:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  1c:	48 89 ce             	mov    %rcx,%rsi
  1f:	48 89 c7             	mov    %rax,%rdi
  22:	e8 00 00 00 00       	callq  27 <std::pair<bool, int> std::make_pair<bool, int>(bool, int)+0x27>
  27:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  2b:	c9                   	leaveq 
  2c:	c3                   	retq   

Disassembly of section .text._ZNSt4pairIbmEC2IbiEERKS_IT_T0_E:

0000000000000000 <std::pair<bool, unsigned long>::pair<bool, int>(std::pair<bool, int> const&)>:
      _GLIBCXX_CONSTEXPR pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

      /** There is also a templated copy ctor for the @c pair class itself.  */
      template<class _U1, class _U2>
	_GLIBCXX_CONSTEXPR pair(const pair<_U1, _U2>& __p)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	: first(__p.first), second(__p.second) { }
   c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  10:	0f b6 10             	movzbl (%rax),%edx
  13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  17:	88 10                	mov    %dl,(%rax)
  19:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  1d:	8b 40 04             	mov    0x4(%rax),%eax
  20:	48 63 d0             	movslq %eax,%rdx
  23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  27:	48 89 50 08          	mov    %rdx,0x8(%rax)
  2b:	5d                   	pop    %rbp
  2c:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsSsESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EED2Ev:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::~_Hashtable()>:

  template<typename _Key, typename _Value,
	   typename _Allocator, typename _ExtractKey, typename _Equal,
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 18          	sub    $0x18,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    ~_Hashtable()
    {
      clear();
   d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  11:	48 89 c7             	mov    %rax,%rdi
  14:	e8 00 00 00 00       	callq  19 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::~_Hashtable()+0x19>
      _M_deallocate_buckets(_M_buckets, _M_bucket_count);
  19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  25:	48 8b 48 08          	mov    0x8(%rax),%rcx
  29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  2d:	48 89 ce             	mov    %rcx,%rsi
  30:	48 89 c7             	mov    %rax,%rdi
  33:	e8 00 00 00 00       	callq  38 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::~_Hashtable()+0x38>
    }
  38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  3c:	48 83 c0 04          	add    $0x4,%rax
  40:	48 89 c7             	mov    %rax,%rdi
  43:	e8 00 00 00 00       	callq  48 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::~_Hashtable()+0x48>
  48:	48 83 c4 18          	add    $0x18,%rsp
  4c:	5b                   	pop    %rbx
  4d:	5d                   	pop    %rbp
  4e:	c3                   	retq   
  4f:	48 89 c3             	mov    %rax,%rbx
  52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  56:	48 83 c0 04          	add    $0x4,%rax
  5a:	48 89 c7             	mov    %rax,%rdi
  5d:	e8 00 00 00 00       	callq  62 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::~_Hashtable()+0x62>
  62:	48 89 d8             	mov    %rbx,%rax
  65:	48 89 c7             	mov    %rax,%rdi
  68:	e8 00 00 00 00       	callq  6d <(anonymous namespace)::Concurrency_counters_Test::me_+0x55>

Disassembly of section .text._ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_PKS3_:

0000000000000000 <std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const*)>:
   *  @param rhs  Last string.
   *  @return  New string with @a lhs followed by @a rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 28          	sub    $0x28,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  11:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	     const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  15:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1d:	48 89 d6             	mov    %rdx,%rsi
  20:	48 89 c7             	mov    %rax,%rdi
  23:	e8 00 00 00 00       	callq  28 <std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const*)+0x28>
      __str.append(__rhs);
  28:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  30:	48 89 d6             	mov    %rdx,%rsi
  33:	48 89 c7             	mov    %rax,%rdi
  36:	e8 00 00 00 00       	callq  3b <std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const*)+0x3b>
      return __str;
  3b:	eb 1a                	jmp    57 <std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const*)+0x57>
  3d:	48 89 c3             	mov    %rax,%rbx
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	     const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  44:	48 89 c7             	mov    %rax,%rdi
  47:	e8 00 00 00 00       	callq  4c <std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const*)+0x4c>
  4c:	48 89 d8             	mov    %rbx,%rax
  4f:	48 89 c7             	mov    %rax,%rdi
  52:	e8 00 00 00 00       	callq  57 <std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const*)+0x57>
      __str.append(__rhs);
      return __str;
    }
  57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  5b:	48 83 c4 28          	add    $0x28,%rsp
  5f:	5b                   	pop    %rbx
  60:	5d                   	pop    %rbp
  61:	c3                   	retq   

Disassembly of section .text._ZStplIcSt11char_traitsIcESaIcEESbIT_T0_T1_ERKS6_S8_:

0000000000000000 <std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)>:
   *  @param rhs  Last string.
   *  @return  New string with value of @a lhs followed by @a rhs.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 28          	sub    $0x28,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  11:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  15:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1d:	48 89 d6             	mov    %rdx,%rsi
  20:	48 89 c7             	mov    %rax,%rdi
  23:	e8 00 00 00 00       	callq  28 <std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)+0x28>
      __str.append(__rhs);
  28:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  30:	48 89 d6             	mov    %rdx,%rsi
  33:	48 89 c7             	mov    %rax,%rdi
  36:	e8 00 00 00 00       	callq  3b <std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)+0x3b>
      return __str;
  3b:	eb 1a                	jmp    57 <std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)+0x57>
  3d:	48 89 c3             	mov    %rax,%rbx
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
	      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
  40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  44:	48 89 c7             	mov    %rax,%rdi
  47:	e8 00 00 00 00       	callq  4c <std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)+0x4c>
  4c:	48 89 d8             	mov    %rbx,%rax
  4f:	48 89 c7             	mov    %rax,%rdi
  52:	e8 00 00 00 00       	callq  57 <std::basic_string<char, std::char_traits<char>, std::allocator<char> > std::operator+<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)+0x57>
      __str.append(__rhs);
      return __str;
    }
  57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  5b:	48 83 c4 28          	add    $0x28,%rsp
  5f:	5b                   	pop    %rbx
  60:	5d                   	pop    %rbp
  61:	c3                   	retq   

Disassembly of section .text._ZNSt6vectorIPN4base8TestCaseESaIS2_EED2Ev:

0000000000000000 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::~vector()>:
       *  The dtor only erases the elements, and note that if the
       *  elements themselves are pointers, the pointed-to memory is
       *  not touched in any way.  Managing the pointer is the user's
       *  responsibility.
       */
      ~vector()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 18          	sub    $0x18,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  11:	48 89 c7             	mov    %rax,%rdi
  14:	e8 00 00 00 00       	callq  19 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::~vector()+0x19>
  19:	48 89 c2             	mov    %rax,%rdx
  1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  20:	48 8b 48 08          	mov    0x8(%rax),%rcx
  24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  28:	48 8b 00             	mov    (%rax),%rax
  2b:	48 89 ce             	mov    %rcx,%rsi
  2e:	48 89 c7             	mov    %rax,%rdi
  31:	e8 00 00 00 00       	callq  36 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::~vector()+0x36>
		      _M_get_Tp_allocator()); }
  36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  3a:	48 89 c7             	mov    %rax,%rdi
  3d:	e8 00 00 00 00       	callq  42 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::~vector()+0x42>
  42:	48 83 c4 18          	add    $0x18,%rsp
  46:	5b                   	pop    %rbx
  47:	5d                   	pop    %rbp
  48:	c3                   	retq   
  49:	48 89 c3             	mov    %rax,%rbx
  4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  50:	48 89 c7             	mov    %rax,%rdi
  53:	e8 00 00 00 00       	callq  58 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::~vector()+0x58>
  58:	48 89 d8             	mov    %rbx,%rax
  5b:	48 89 c7             	mov    %rax,%rdi
  5e:	e8 00 00 00 00       	callq  63 <(anonymous namespace)::Concurrency_counters_Test::me_+0x4b>

Disassembly of section .text._ZNSt6vectorIPN4base8TestCaseESaIS2_EEC2Ev:

0000000000000000 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::vector()>:
      // [23.2.4.1] construct/copy/destroy
      // (assign() and get_allocator() are also listed in this section)
      /**
       *  @brief  Default constructor creates no elements.
       */
      vector()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      : _Base() { }
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::vector()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZNSt6vectorIPN4base8TestCaseESaIS2_EE9push_backERKS2_:

0000000000000000 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::push_back(base::TestCase* const&)>:
       *  to it.  Due to the nature of a %vector this operation can be
       *  done in constant time if the %vector has preallocated space
       *  available.
       */
      void
      push_back(const value_type& __x)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
      {
	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  14:	48 8b 50 08          	mov    0x8(%rax),%rdx
  18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1c:	48 8b 40 10          	mov    0x10(%rax),%rax
  20:	48 39 c2             	cmp    %rax,%rdx
  23:	74 31                	je     56 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::push_back(base::TestCase* const&)+0x56>
	  {
	    this->_M_impl.construct(this->_M_impl._M_finish, __x);
  25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  29:	48 8b 48 08          	mov    0x8(%rax),%rcx
  2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  31:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  35:	48 89 ce             	mov    %rcx,%rsi
  38:	48 89 c7             	mov    %rax,%rdi
  3b:	e8 00 00 00 00       	callq  40 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::push_back(base::TestCase* const&)+0x40>
	    ++this->_M_impl._M_finish;
  40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  44:	48 8b 40 08          	mov    0x8(%rax),%rax
  48:	48 8d 50 08          	lea    0x8(%rax),%rdx
  4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  50:	48 89 50 08          	mov    %rdx,0x8(%rax)
  54:	eb 22                	jmp    78 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::push_back(base::TestCase* const&)+0x78>
	  }
	else
	  _M_insert_aux(end(), __x);
  56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  5a:	48 89 c7             	mov    %rax,%rdi
  5d:	e8 00 00 00 00       	callq  62 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::push_back(base::TestCase* const&)+0x62>
  62:	48 89 c1             	mov    %rax,%rcx
  65:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  6d:	48 89 ce             	mov    %rcx,%rsi
  70:	48 89 c7             	mov    %rax,%rdi
  73:	e8 00 00 00 00       	callq  78 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::push_back(base::TestCase* const&)+0x78>
      }
  78:	c9                   	leaveq 
  79:	c3                   	retq   

Disassembly of section .text._ZNSt6vectorIPN4base8TestCaseESaIS2_EE5beginEv:

0000000000000000 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::begin()>:
       *  Returns a read/write iterator that points to the first
       *  element in the %vector.  Iteration is done in ordinary
       *  element order.
       */
      iterator
      begin()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
      { return iterator(this->_M_impl._M_start); }
   c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  10:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  14:	48 89 d6             	mov    %rdx,%rsi
  17:	48 89 c7             	mov    %rax,%rdi
  1a:	e8 00 00 00 00       	callq  1f <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::begin()+0x1f>
  1f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  23:	c9                   	leaveq 
  24:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx17__normal_iteratorIPKPN4base8TestCaseESt6vectorIS3_SaIS3_EEEC2IPS3_EERKNS0_IT_NS_11__enable_ifIXsrSt10__are_sameISC_SB_E7__valueES8_E6__typeEEE:

0000000000000000 <__gnu_cxx::__normal_iterator<base::TestCase* const*, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >::__normal_iterator<base::TestCase**>(__gnu_cxx::__normal_iterator<base::TestCase**, __gnu_cxx::__enable_if<std::__are_same<base::TestCase**, base::TestCase**>::__value, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >::__type> const&)>:
      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }

      // Allow iterator to const_iterator conversion
      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
			  typename __enable_if<
      	       (std::__are_same<_Iter, typename _Container::pointer>::__value),
		      _Container>::__type>& __i)
        : _M_current(__i.base()) { }
  10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  14:	48 89 c7             	mov    %rax,%rdi
  17:	e8 00 00 00 00       	callq  1c <__gnu_cxx::__normal_iterator<base::TestCase* const*, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >::__normal_iterator<base::TestCase**>(__gnu_cxx::__normal_iterator<base::TestCase**, __gnu_cxx::__enable_if<std::__are_same<base::TestCase**, base::TestCase**>::__value, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >::__type> const&)+0x1c>
  1c:	48 8b 10             	mov    (%rax),%rdx
  1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  23:	48 89 10             	mov    %rdx,(%rax)
  26:	c9                   	leaveq 
  27:	c3                   	retq   

Disassembly of section .text._ZNSt6vectorIPN4base8TestCaseESaIS2_EE3endEv:

0000000000000000 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::end()>:
       *  Returns a read/write iterator that points one past the last
       *  element in the %vector.  Iteration is done in ordinary
       *  element order.
       */
      iterator
      end()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
      { return iterator(this->_M_impl._M_finish); }
   c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  10:	48 8d 50 08          	lea    0x8(%rax),%rdx
  14:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  18:	48 89 d6             	mov    %rdx,%rsi
  1b:	48 89 c7             	mov    %rax,%rdi
  1e:	e8 00 00 00 00       	callq  23 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::end()+0x23>
  23:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  27:	c9                   	leaveq 
  28:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxxneIPKPN4base8TestCaseEPS3_St6vectorIS3_SaIS3_EEEEbRKNS_17__normal_iteratorIT_T1_EERKNSA_IT0_SC_EE:

0000000000000000 <bool __gnu_cxx::operator!=<base::TestCase* const*, base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >(__gnu_cxx::__normal_iterator<base::TestCase* const*, std::vector<base::TestCase*, std::allocator<base::TestCase*> > > const&, __gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > > const&)>:
	       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 18          	sub    $0x18,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }
  11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  15:	48 89 c7             	mov    %rax,%rdi
  18:	e8 00 00 00 00       	callq  1d <bool __gnu_cxx::operator!=<base::TestCase* const*, base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >(__gnu_cxx::__normal_iterator<base::TestCase* const*, std::vector<base::TestCase*, std::allocator<base::TestCase*> > > const&, __gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > > const&)+0x1d>
  1d:	48 8b 18             	mov    (%rax),%rbx
  20:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  24:	48 89 c7             	mov    %rax,%rdi
  27:	e8 00 00 00 00       	callq  2c <bool __gnu_cxx::operator!=<base::TestCase* const*, base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >(__gnu_cxx::__normal_iterator<base::TestCase* const*, std::vector<base::TestCase*, std::allocator<base::TestCase*> > > const&, __gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > > const&)+0x2c>
  2c:	48 8b 00             	mov    (%rax),%rax
  2f:	48 39 c3             	cmp    %rax,%rbx
  32:	0f 95 c0             	setne  %al
  35:	48 83 c4 18          	add    $0x18,%rsp
  39:	5b                   	pop    %rbx
  3a:	5d                   	pop    %rbp
  3b:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx17__normal_iteratorIPKPN4base8TestCaseESt6vectorIS3_SaIS3_EEEppEv:

0000000000000000 <__gnu_cxx::__normal_iterator<base::TestCase* const*, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >::operator++()>:
      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      {
	++_M_current;
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	48 8b 00             	mov    (%rax),%rax
   f:	48 8d 50 08          	lea    0x8(%rax),%rdx
  13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  17:	48 89 10             	mov    %rdx,(%rax)
	return *this;
  1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
      }
  1e:	5d                   	pop    %rbp
  1f:	c3                   	retq   

Disassembly of section .text._ZNK9__gnu_cxx17__normal_iteratorIPKPN4base8TestCaseESt6vectorIS3_SaIS3_EEEdeEv:

0000000000000000 <__gnu_cxx::__normal_iterator<base::TestCase* const*, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >::operator*() const>:
		      _Container>::__type>& __i)
        : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return *_M_current; }
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	48 8b 00             	mov    (%rax),%rax
   f:	5d                   	pop    %rbp
  10:	c3                   	retq   

Disassembly of section .text._ZNSaISt4pairIKSsbEEC2Ev:

0000000000000000 <std::allocator<std::pair<std::string const, bool> >::allocator()>:

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::allocator<std::pair<std::string const, bool> >::allocator()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZNSaISt4pairIKSsbEED2Ev:

0000000000000000 <std::allocator<std::pair<std::string const, bool> >::~allocator()>:
      : __glibcxx_base_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::allocator<std::pair<std::string const, bool> >::~allocator()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZNSt3tr113unordered_mapISsbNS_4hashISsEESt8equal_toISsESaISt4pairIKSsbEEEC2EmRKS2_RKS4_RKS8_:

0000000000000000 <std::tr1::unordered_map<std::string, bool, std::tr1::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<std::string const, bool> > >::unordered_map(unsigned long, std::tr1::hash<std::string> const&, std::equal_to<std::string> const&, std::allocator<std::pair<std::string const, bool> > const&)>:
      typedef typename _Base::hasher          hasher;
      typedef typename _Base::key_equal       key_equal;
      typedef typename _Base::allocator_type  allocator_type;

      explicit
      unordered_map(size_type __n = 10,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 30          	sub    $0x30,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  14:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  18:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
		    const hasher& __hf = hasher(),
		    const key_equal& __eql = key_equal(),
		    const allocator_type& __a = allocator_type())
      : _Base(__n, __hf, __eql, __a)
  1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  20:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  24:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  28:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  2c:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  30:	49 89 f8             	mov    %rdi,%r8
  33:	48 89 c7             	mov    %rax,%rdi
  36:	e8 00 00 00 00       	callq  3b <std::tr1::unordered_map<std::string, bool, std::tr1::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<std::string const, bool> > >::unordered_map(unsigned long, std::tr1::hash<std::string> const&, std::equal_to<std::string> const&, std::allocator<std::pair<std::string const, bool> > const&)+0x3b>
      { }
  3b:	c9                   	leaveq 
  3c:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EED2Ev:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::~_Hashtable()>:

  template<typename _Key, typename _Value,
	   typename _Allocator, typename _ExtractKey, typename _Equal,
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 18          	sub    $0x18,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    ~_Hashtable()
    {
      clear();
   d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  11:	48 89 c7             	mov    %rax,%rdi
  14:	e8 00 00 00 00       	callq  19 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::~_Hashtable()+0x19>
      _M_deallocate_buckets(_M_buckets, _M_bucket_count);
  19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  25:	48 8b 48 08          	mov    0x8(%rax),%rcx
  29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  2d:	48 89 ce             	mov    %rcx,%rsi
  30:	48 89 c7             	mov    %rax,%rdi
  33:	e8 00 00 00 00       	callq  38 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::~_Hashtable()+0x38>
    }
  38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  3c:	48 83 c0 04          	add    $0x4,%rax
  40:	48 89 c7             	mov    %rax,%rdi
  43:	e8 00 00 00 00       	callq  48 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::~_Hashtable()+0x48>
  48:	48 83 c4 18          	add    $0x18,%rsp
  4c:	5b                   	pop    %rbx
  4d:	5d                   	pop    %rbp
  4e:	c3                   	retq   
  4f:	48 89 c3             	mov    %rax,%rbx
  52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  56:	48 83 c0 04          	add    $0x4,%rax
  5a:	48 89 c7             	mov    %rax,%rdi
  5d:	e8 00 00 00 00       	callq  62 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::~_Hashtable()+0x62>
  62:	48 89 d8             	mov    %rbx,%rax
  65:	48 89 c7             	mov    %rax,%rdi
  68:	e8 00 00 00 00       	callq  6d <(anonymous namespace)::Concurrency_counters_Test::me_+0x55>

Disassembly of section .text._ZStneIcSt11char_traitsIcESaIcEEbRKSbIT_T0_T1_EPKS3_:

0000000000000000 <bool std::operator!=<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const*)>:
   *  @param rhs  C string.
   *  @return  True if @a lhs.compare(@a rhs) != 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	       const _CharT* __rhs)
    { return !(__lhs == __rhs); }
  10:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  18:	48 89 d6             	mov    %rdx,%rsi
  1b:	48 89 c7             	mov    %rax,%rdi
  1e:	e8 00 00 00 00       	callq  23 <bool std::operator!=<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const*)+0x23>
  23:	83 f0 01             	xor    $0x1,%eax
  26:	c9                   	leaveq 
  27:	c3                   	retq   

Disassembly of section .text._ZSt9make_pairISsbESt4pairIT_T0_ES1_S2_:

0000000000000000 <std::pair<std::string, bool> std::make_pair<std::string, bool>(std::string, bool)>:
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
#else
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	89 d0                	mov    %edx,%eax
  12:	88 45 ec             	mov    %al,-0x14(%rbp)
    { return pair<_T1, _T2>(__x, __y); }
  15:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
  19:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  21:	48 89 ce             	mov    %rcx,%rsi
  24:	48 89 c7             	mov    %rax,%rdi
  27:	e8 00 00 00 00       	callq  2c <std::pair<std::string, bool> std::make_pair<std::string, bool>(std::string, bool)+0x2c>
  2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  30:	c9                   	leaveq 
  31:	c3                   	retq   

Disassembly of section .text._ZNSt4pairIKSsbEC2ISsbEERKS_IT_T0_E:

0000000000000000 <std::pair<std::string const, bool>::pair<std::string, bool>(std::pair<std::string, bool> const&)>:
      _GLIBCXX_CONSTEXPR pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

      /** There is also a templated copy ctor for the @c pair class itself.  */
      template<class _U1, class _U2>
	_GLIBCXX_CONSTEXPR pair(const pair<_U1, _U2>& __p)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	: first(__p.first), second(__p.second) { }
  10:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  18:	48 89 d6             	mov    %rdx,%rsi
  1b:	48 89 c7             	mov    %rax,%rdi
  1e:	e8 00 00 00 00       	callq  23 <std::pair<std::string const, bool>::pair<std::string, bool>(std::pair<std::string, bool> const&)+0x23>
  23:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  27:	0f b6 50 08          	movzbl 0x8(%rax),%edx
  2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  2f:	88 50 08             	mov    %dl,0x8(%rax)
  32:	c9                   	leaveq 
  33:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE6insertERKS3_:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::insert(std::pair<std::string const, bool> const&)>:
      _M_erase_node(_Node*, _Node**);

    public:
      // Insert and erase
      _Insert_Return_Type
      insert(const value_type& __v)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 30          	sub    $0x30,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      { return _M_insert(__v, std::tr1::integral_constant<bool,
			 __unique_keys>()); }
  14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  18:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  1c:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  20:	44 88 04 24          	mov    %r8b,(%rsp)
  24:	48 89 ce             	mov    %rcx,%rsi
  27:	48 89 c7             	mov    %rax,%rdi
  2a:	e8 00 00 00 00       	callq  2f <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::insert(std::pair<std::string const, bool> const&)+0x2f>
  2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  33:	c9                   	leaveq 
  34:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE4findERS2_:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::find(std::string const&)>:
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
			_H1, _H2, _Hash, _RehashPolicy,
			__chc, __cit, __uk>::iterator
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 50          	sub    $0x50,%rsp
   8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
   c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    find(const key_type& __k)
    {
      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
  10:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  14:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  18:	48 89 d6             	mov    %rdx,%rsi
  1b:	48 89 c7             	mov    %rax,%rdi
  1e:	e8 00 00 00 00       	callq  23 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::find(std::string const&)+0x23>
  23:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      std::size_t __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
  27:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  2b:	48 8b 48 10          	mov    0x10(%rax),%rcx
  2f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  33:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  37:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  3b:	48 89 c7             	mov    %rax,%rdi
  3e:	e8 00 00 00 00       	callq  43 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::find(std::string const&)+0x43>
  43:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      _Node* __p = _M_find_node(_M_buckets[__n], __k, __code);
  47:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  4b:	48 8b 40 08          	mov    0x8(%rax),%rax
  4f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  53:	48 c1 e2 03          	shl    $0x3,%rdx
  57:	48 01 d0             	add    %rdx,%rax
  5a:	48 8b 30             	mov    (%rax),%rsi
  5d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  61:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  65:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  69:	48 89 c7             	mov    %rax,%rdi
  6c:	e8 00 00 00 00       	callq  71 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::find(std::string const&)+0x71>
  71:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
      return __p ? iterator(__p, _M_buckets + __n) : this->end();
  75:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  7a:	74 28                	je     a4 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::find(std::string const&)+0xa4>
  7c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80:	48 8b 40 08          	mov    0x8(%rax),%rax
  84:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  88:	48 c1 e2 03          	shl    $0x3,%rdx
  8c:	48 01 c2             	add    %rax,%rdx
  8f:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  93:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  97:	48 89 ce             	mov    %rcx,%rsi
  9a:	48 89 c7             	mov    %rax,%rdi
  9d:	e8 00 00 00 00       	callq  a2 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::find(std::string const&)+0xa2>
  a2:	eb 2a                	jmp    ce <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::find(std::string const&)+0xce>
  a4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  a8:	48 89 c7             	mov    %rax,%rdi
  ab:	e8 00 00 00 00       	callq  b0 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::find(std::string const&)+0xb0>
  b0:	48 89 c1             	mov    %rax,%rcx
  b3:	48 89 d0             	mov    %rdx,%rax
  b6:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  ba:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  be:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  c2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  c6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  ca:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  ce:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  d2:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
    }
  d6:	c9                   	leaveq 
  d7:	c3                   	retq   

Disassembly of section .text._ZNKSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE5emptyEv:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::empty() const>:
      size_type
      size() const
      { return _M_element_count; }

      bool
      empty() const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return size() == 0; }
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::empty() const+0x18>
  18:	48 85 c0             	test   %rax,%rax
  1b:	0f 94 c0             	sete   %al
  1e:	c9                   	leaveq 
  1f:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE3endEv:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::end()>:
	  __i._M_incr_bucket();
	return __i;
      }

      iterator
      end()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 40          	sub    $0x40,%rsp
   8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
      { return iterator(_M_buckets + _M_bucket_count); }
   c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  10:	48 8b 50 08          	mov    0x8(%rax),%rdx
  14:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  18:	48 8b 40 10          	mov    0x10(%rax),%rax
  1c:	48 c1 e0 03          	shl    $0x3,%rax
  20:	48 01 c2             	add    %rax,%rdx
  23:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  27:	48 89 d6             	mov    %rdx,%rsi
  2a:	48 89 c7             	mov    %rax,%rdi
  2d:	e8 00 00 00 00       	callq  32 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::end()+0x32>
  32:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  36:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  3e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  42:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  46:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  4a:	c9                   	leaveq 
  4b:	c3                   	retq   

Disassembly of section .text._ZNSt3tr18__detaileqISt4pairIKSsbELb0EEEbRKNS0_24_Hashtable_iterator_baseIT_XT0_EEES9_:

0000000000000000 <bool std::tr1::__detail::operator==<std::pair<std::string const, bool>, false>(std::tr1::__detail::_Hashtable_iterator_base<std::pair<std::string const, bool>, false> const&, std::tr1::__detail::_Hashtable_iterator_base<std::pair<std::string const, bool>, false> const&)>:
      _M_cur_node = *_M_cur_bucket;
    }

  template<typename _Value, bool __cache>
    inline bool
    operator==(const _Hashtable_iterator_base<_Value, __cache>& __x,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	       const _Hashtable_iterator_base<_Value, __cache>& __y)
    { return __x._M_cur_node == __y._M_cur_node; }
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 8b 10             	mov    (%rax),%rdx
  13:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  17:	48 8b 00             	mov    (%rax),%rax
  1a:	48 39 c2             	cmp    %rax,%rdx
  1d:	0f 94 c0             	sete   %al
  20:	5d                   	pop    %rbp
  21:	c3                   	retq   

Disassembly of section .text._ZNKSt3tr18__detail19_Hashtable_iteratorISt4pairIKSsbELb0ELb0EEptEv:

0000000000000000 <std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>::operator->() const>:
      reference
      operator*() const
      { return this->_M_cur_node->_M_v; }
  
      pointer
      operator->() const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return std::__addressof(this->_M_cur_node->_M_v); }
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 8b 00             	mov    (%rax),%rax
  13:	48 89 c7             	mov    %rax,%rdi
  16:	e8 00 00 00 00       	callq  1b <std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>::operator->() const+0x1b>
  1b:	c9                   	leaveq 
  1c:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE5beginEv:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::begin()>:

      void swap(_Hashtable&);

      // Basic container operations
      iterator
      begin()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 40          	sub    $0x40,%rsp
   8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
      {
	iterator __i(_M_buckets);
   c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  10:	48 8b 50 08          	mov    0x8(%rax),%rdx
  14:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  18:	48 89 d6             	mov    %rdx,%rsi
  1b:	48 89 c7             	mov    %rax,%rdi
  1e:	e8 00 00 00 00       	callq  23 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::begin()+0x23>
	if (!__i._M_cur_node)
  23:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  27:	48 85 c0             	test   %rax,%rax
  2a:	75 0c                	jne    38 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::begin()+0x38>
	  __i._M_incr_bucket();
  2c:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  30:	48 89 c7             	mov    %rax,%rdi
  33:	e8 00 00 00 00       	callq  38 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::begin()+0x38>
	return __i;
  38:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  3c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  44:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  48:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  4c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
      }
  50:	c9                   	leaveq 
  51:	c3                   	retq   

Disassembly of section .text._ZNSt3tr18__detailneISt4pairIKSsbELb0EEEbRKNS0_24_Hashtable_iterator_baseIT_XT0_EEES9_:

0000000000000000 <bool std::tr1::__detail::operator!=<std::pair<std::string const, bool>, false>(std::tr1::__detail::_Hashtable_iterator_base<std::pair<std::string const, bool>, false> const&, std::tr1::__detail::_Hashtable_iterator_base<std::pair<std::string const, bool>, false> const&)>:
	       const _Hashtable_iterator_base<_Value, __cache>& __y)
    { return __x._M_cur_node == __y._M_cur_node; }

  template<typename _Value, bool __cache>
    inline bool
    operator!=(const _Hashtable_iterator_base<_Value, __cache>& __x,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	       const _Hashtable_iterator_base<_Value, __cache>& __y)
    { return __x._M_cur_node != __y._M_cur_node; }
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 8b 10             	mov    (%rax),%rdx
  13:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  17:	48 8b 00             	mov    (%rax),%rax
  1a:	48 39 c2             	cmp    %rax,%rdx
  1d:	0f 95 c0             	setne  %al
  20:	5d                   	pop    %rbp
  21:	c3                   	retq   

Disassembly of section .text._ZNSt3tr18__detail19_Hashtable_iteratorISt4pairIKSsbELb0ELb0EEppEv:

0000000000000000 <std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>::operator++()>:
      pointer
      operator->() const
      { return std::__addressof(this->_M_cur_node->_M_v); }

      _Hashtable_iterator&
      operator++()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { 
	this->_M_incr();
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>::operator++()+0x18>
	return *this;
  18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
      }
  1c:	c9                   	leaveq 
  1d:	c3                   	retq   

Disassembly of section .text._ZSteqIcSt11char_traitsIcESaIcEEbRKSbIT_T0_T1_EPKS3_:

0000000000000000 <bool std::operator==<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const*)>:
   *  @param rhs  C string.
   *  @return  True if @a lhs.compare(@a rhs) == 0.  False otherwise.
   */
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	       const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
  10:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  18:	48 89 d6             	mov    %rdx,%rsi
  1b:	48 89 c7             	mov    %rax,%rdi
  1e:	e8 00 00 00 00       	callq  23 <bool std::operator==<char, std::char_traits<char>, std::allocator<char> >(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, char const*)+0x23>
  23:	85 c0                	test   %eax,%eax
  25:	0f 94 c0             	sete   %al
  28:	c9                   	leaveq 
  29:	c3                   	retq   

Disassembly of section .text._ZNSt6vectorIPN4base8TestCaseESaIS2_EE5clearEv:

0000000000000000 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::clear()>:
       *  elements, and that if the elements themselves are pointers, the
       *  pointed-to memory is not touched in any way.  Managing the pointer is
       *  the user's responsibility.
       */
      void
      clear()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { _M_erase_at_end(this->_M_impl._M_start); }
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 8b 10             	mov    (%rax),%rdx
  13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  17:	48 89 d6             	mov    %rdx,%rsi
  1a:	48 89 c7             	mov    %rax,%rdi
  1d:	e8 00 00 00 00       	callq  22 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::clear()+0x22>
  22:	c9                   	leaveq 
  23:	c3                   	retq   

Disassembly of section .text._ZSt8distanceIPKmENSt15iterator_traitsIT_E15difference_typeES3_S3_:

0000000000000000 <std::iterator_traits<unsigned long const*>::difference_type std::distance<unsigned long const*>(unsigned long const*, unsigned long const*)>:
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
  */
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 28          	sub    $0x28,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    {
      // concept requirements -- taken care of in __distance
      return std::__distance(__first, __last,
			     std::__iterator_category(__first));
  11:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  15:	48 89 c7             	mov    %rax,%rdi
  18:	e8 00 00 00 00       	callq  1d <std::iterator_traits<unsigned long const*>::difference_type std::distance<unsigned long const*>(unsigned long const*, unsigned long const*)+0x1d>
  1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  21:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  25:	88 1c 24             	mov    %bl,(%rsp)
  28:	48 89 d6             	mov    %rdx,%rsi
  2b:	48 89 c7             	mov    %rax,%rdi
  2e:	e8 00 00 00 00       	callq  33 <std::iterator_traits<unsigned long const*>::difference_type std::distance<unsigned long const*>(unsigned long const*, unsigned long const*)+0x33>
    }
  33:	48 83 c4 28          	add    $0x28,%rsp
  37:	5b                   	pop    %rbx
  38:	5d                   	pop    %rbp
  39:	c3                   	retq   

Disassembly of section .text._ZSt7advanceIPKmlEvRT_T0_:

0000000000000000 <void std::advance<unsigned long const*, long>(unsigned long const*&, long)>:
   *  For random access iterators, this uses their @c + and @c - operations
   *  and are constant time.  For other %iterator classes they are linear time.
  */
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 38          	sub    $0x38,%rsp
   9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
   d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    {
      // concept requirements -- taken care of in __advance
      typename iterator_traits<_InputIterator>::difference_type __d = __n;
  11:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  15:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      std::__advance(__i, __d, std::__iterator_category(__i));
  19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  1d:	48 89 c7             	mov    %rax,%rdi
  20:	e8 00 00 00 00       	callq  25 <void std::advance<unsigned long const*, long>(unsigned long const*&, long)+0x25>
  25:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  29:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  2d:	88 1c 24             	mov    %bl,(%rsp)
  30:	48 89 d6             	mov    %rdx,%rsi
  33:	48 89 c7             	mov    %rax,%rdi
  36:	e8 00 00 00 00       	callq  3b <void std::advance<unsigned long const*, long>(unsigned long const*&, long)+0x3b>
    }
  3b:	48 83 c4 38          	add    $0x38,%rsp
  3f:	5b                   	pop    %rbx
  40:	5d                   	pop    %rbp
  41:	c3                   	retq   

Disassembly of section .text._ZNSt4pairIbmEC2ERKbRKm:

0000000000000000 <std::pair<bool, unsigned long>::pair(bool const&, unsigned long const&)>:
       *  respective default constructors.  */
      _GLIBCXX_CONSTEXPR pair()
      : first(), second() { }

      /** Two objects may be passed to a @c pair constructor to be copied.  */
      _GLIBCXX_CONSTEXPR pair(const _T1& __a, const _T2& __b)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      : first(__a), second(__b) { }
  10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  14:	0f b6 10             	movzbl (%rax),%edx
  17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1b:	88 10                	mov    %dl,(%rax)
  1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  21:	48 8b 10             	mov    (%rax),%rdx
  24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  28:	48 89 50 08          	mov    %rdx,0x8(%rax)
  2c:	5d                   	pop    %rbp
  2d:	c3                   	retq   

Disassembly of section .text._ZNSt4pairIbiEC2ERKbRKi:

0000000000000000 <std::pair<bool, int>::pair(bool const&, int const&)>:
       *  respective default constructors.  */
      _GLIBCXX_CONSTEXPR pair()
      : first(), second() { }

      /** Two objects may be passed to a @c pair constructor to be copied.  */
      _GLIBCXX_CONSTEXPR pair(const _T1& __a, const _T2& __b)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      : first(__a), second(__b) { }
  10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  14:	0f b6 10             	movzbl (%rax),%edx
  17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1b:	88 10                	mov    %dl,(%rax)
  1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  21:	8b 10                	mov    (%rax),%edx
  23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  27:	89 50 04             	mov    %edx,0x4(%rax)
  2a:	5d                   	pop    %rbp
  2b:	c3                   	retq   

Disassembly of section .text._ZNSaINSt3tr18__detail10_Hash_nodeISt4pairIKSsSsELb0EEEED2Ev:

0000000000000000 <std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false> >::~allocator()>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false> >::~allocator()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsSsESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE5clearEv:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::clear()>:
  template<typename _Key, typename _Value,
	   typename _Allocator, typename _ExtractKey, typename _Equal,
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    clear()
    {
      _M_deallocate_nodes(_M_buckets, _M_bucket_count);
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 8b 50 10          	mov    0x10(%rax),%rdx
  14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  18:	48 8b 48 08          	mov    0x8(%rax),%rcx
  1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  20:	48 89 ce             	mov    %rcx,%rsi
  23:	48 89 c7             	mov    %rax,%rdi
  26:	e8 00 00 00 00       	callq  2b <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::clear()+0x2b>
      _M_element_count = 0;
  2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  2f:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  36:	00 
    }
  37:	c9                   	leaveq 
  38:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsSsESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE21_M_deallocate_bucketsEPPNSB_10_Hash_nodeIS3_Lb0EEEm:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_buckets(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>**, unsigned long)>:
  template<typename _Key, typename _Value,
	   typename _Allocator, typename _ExtractKey, typename _Equal,
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 30          	sub    $0x30,%rsp
   8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  10:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_buckets(_Node** __p, size_type __n)
    {
      _Bucket_allocator_type __alloc(_M_node_allocator);
  14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  18:	48 8d 50 04          	lea    0x4(%rax),%rdx
  1c:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  20:	48 89 d6             	mov    %rdx,%rsi
  23:	48 89 c7             	mov    %rax,%rdi
  26:	e8 00 00 00 00       	callq  2b <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_buckets(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>**, unsigned long)+0x2b>
      __alloc.deallocate(__p, __n + 1);
  2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  2f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  33:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  37:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  3b:	48 89 ce             	mov    %rcx,%rsi
  3e:	48 89 c7             	mov    %rax,%rdi
  41:	e8 00 00 00 00       	callq  46 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_buckets(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>**, unsigned long)+0x46>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_buckets(_Node** __p, size_type __n)
    {
      _Bucket_allocator_type __alloc(_M_node_allocator);
  46:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  4a:	48 89 c7             	mov    %rax,%rdi
  4d:	e8 00 00 00 00       	callq  52 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_buckets(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>**, unsigned long)+0x52>
      __alloc.deallocate(__p, __n + 1);
    }
  52:	c9                   	leaveq 
  53:	c3                   	retq   

Disassembly of section .text._ZNSt12_Vector_baseIPN4base8TestCaseESaIS2_EE12_Vector_implD2Ev:

0000000000000000 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_Vector_impl::~_Vector_impl()>:
  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _Vector_impl 
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_Vector_impl::~_Vector_impl()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZNSt12_Vector_baseIPN4base8TestCaseESaIS2_EED2Ev:

0000000000000000 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::~_Vector_base()>:
	__x._M_impl._M_finish = 0;
	__x._M_impl._M_end_of_storage = 0;
      }
#endif

      ~_Vector_base()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 18          	sub    $0x18,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
   d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  11:	48 8b 40 10          	mov    0x10(%rax),%rax
  15:	48 89 c2             	mov    %rax,%rdx
  18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1c:	48 8b 00             	mov    (%rax),%rax
  1f:	48 89 d1             	mov    %rdx,%rcx
  22:	48 29 c1             	sub    %rax,%rcx
  25:	48 89 c8             	mov    %rcx,%rax
  28:	48 c1 f8 03          	sar    $0x3,%rax
  2c:	48 89 c2             	mov    %rax,%rdx
  2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  33:	48 8b 08             	mov    (%rax),%rcx
  36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  3a:	48 89 ce             	mov    %rcx,%rsi
  3d:	48 89 c7             	mov    %rax,%rdi
  40:	e8 00 00 00 00       	callq  45 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::~_Vector_base()+0x45>
		      - this->_M_impl._M_start); }
  45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  49:	48 89 c7             	mov    %rax,%rdi
  4c:	e8 00 00 00 00       	callq  51 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::~_Vector_base()+0x51>
  51:	48 83 c4 18          	add    $0x18,%rsp
  55:	5b                   	pop    %rbx
  56:	5d                   	pop    %rbp
  57:	c3                   	retq   
  58:	48 89 c3             	mov    %rax,%rbx
  5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  5f:	48 89 c7             	mov    %rax,%rdi
  62:	e8 00 00 00 00       	callq  67 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::~_Vector_base()+0x67>
  67:	48 89 d8             	mov    %rbx,%rax
  6a:	48 89 c7             	mov    %rax,%rdi
  6d:	e8 00 00 00 00       	callq  72 <(anonymous namespace)::Concurrency_counters_Test::me_+0x5a>

Disassembly of section .text._ZNSt12_Vector_baseIPN4base8TestCaseESaIS2_EE19_M_get_Tp_allocatorEv:

0000000000000000 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_M_get_Tp_allocator()>:
      
    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	5d                   	pop    %rbp
   d:	c3                   	retq   

Disassembly of section .text._ZSt8_DestroyIPPN4base8TestCaseES2_EvT_S4_RSaIT0_E:

0000000000000000 <void std::_Destroy<base::TestCase**, base::TestCase*>(base::TestCase**, base::TestCase**, std::allocator<base::TestCase*>&)>:
	__alloc.destroy(std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	     allocator<_Tp>&)
    {
      _Destroy(__first, __last);
  14:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1c:	48 89 d6             	mov    %rdx,%rsi
  1f:	48 89 c7             	mov    %rax,%rdi
  22:	e8 00 00 00 00       	callq  27 <void std::_Destroy<base::TestCase**, base::TestCase*>(base::TestCase**, base::TestCase**, std::allocator<base::TestCase*>&)+0x27>
    }
  27:	c9                   	leaveq 
  28:	c3                   	retq   

Disassembly of section .text._ZNSt12_Vector_baseIPN4base8TestCaseESaIS2_EEC2Ev:

0000000000000000 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_Vector_base()>:

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      : _M_impl() { }
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_Vector_base()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorIPN4base8TestCaseEE9constructEPS3_RKS3_:

0000000000000000 <__gnu_cxx::new_allocator<base::TestCase*>::construct(base::TestCase**, base::TestCase* const&)>:
      { return size_t(-1) / sizeof(_Tp); }

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 402. wrong new expression in [some_] allocator::construct
      void 
      construct(pointer __p, const _Tp& __val) 
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      { ::new((void *)__p) _Tp(__val); }
  14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  18:	48 89 c6             	mov    %rax,%rsi
  1b:	bf 08 00 00 00       	mov    $0x8,%edi
  20:	e8 00 00 00 00       	callq  25 <__gnu_cxx::new_allocator<base::TestCase*>::construct(base::TestCase**, base::TestCase* const&)+0x25>
  25:	48 85 c0             	test   %rax,%rax
  28:	74 0a                	je     34 <__gnu_cxx::new_allocator<base::TestCase*>::construct(base::TestCase**, base::TestCase* const&)+0x34>
  2a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  2e:	48 8b 12             	mov    (%rdx),%rdx
  31:	48 89 10             	mov    %rdx,(%rax)
  34:	c9                   	leaveq 
  35:	c3                   	retq   

Disassembly of section .text._ZNSt6vectorIPN4base8TestCaseESaIS2_EE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPS2_S4_EERKS2_:

0000000000000000 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)>:
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Args&&... __args)
#else
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	41 54                	push   %r12
   6:	53                   	push   %rbx
   7:	48 83 ec 50          	sub    $0x50,%rsp
   b:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
   f:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  13:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
    _M_insert_aux(iterator __position, const _Tp& __x)
#endif
    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
  17:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  1b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  1f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  23:	48 8b 40 10          	mov    0x10(%rax),%rax
  27:	48 39 c2             	cmp    %rax,%rdx
  2a:	0f 84 8f 00 00 00    	je     bf <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0xbf>
	{
	  this->_M_impl.construct(this->_M_impl._M_finish,
  30:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  34:	48 8b 40 08          	mov    0x8(%rax),%rax
  38:	48 8d 50 f8          	lea    -0x8(%rax),%rdx
  3c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  40:	48 8b 48 08          	mov    0x8(%rax),%rcx
  44:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  48:	48 89 ce             	mov    %rcx,%rsi
  4b:	48 89 c7             	mov    %rax,%rdi
  4e:	e8 00 00 00 00       	callq  53 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x53>
				  _GLIBCXX_MOVE(*(this->_M_impl._M_finish
						  - 1)));
	  ++this->_M_impl._M_finish;
  53:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  57:	48 8b 40 08          	mov    0x8(%rax),%rax
  5b:	48 8d 50 08          	lea    0x8(%rax),%rdx
  5f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  63:	48 89 50 08          	mov    %rdx,0x8(%rax)
#ifndef __GXX_EXPERIMENTAL_CXX0X__
	  _Tp __x_copy = __x;
  67:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  6b:	48 8b 00             	mov    (%rax),%rax
  6e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
#endif
	  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
  72:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  76:	48 8b 40 08          	mov    0x8(%rax),%rax
  7a:	4c 8d 60 f8          	lea    -0x8(%rax),%r12
  7e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82:	48 8b 40 08          	mov    0x8(%rax),%rax
  86:	48 8d 58 f0          	lea    -0x10(%rax),%rbx
  8a:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  8e:	48 89 c7             	mov    %rax,%rdi
  91:	e8 00 00 00 00       	callq  96 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x96>
  96:	48 8b 00             	mov    (%rax),%rax
  99:	4c 89 e2             	mov    %r12,%rdx
  9c:	48 89 de             	mov    %rbx,%rsi
  9f:	48 89 c7             	mov    %rax,%rdi
  a2:	e8 00 00 00 00       	callq  a7 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0xa7>
				  this->_M_impl._M_finish - 2,
				  this->_M_impl._M_finish - 1);
#ifndef __GXX_EXPERIMENTAL_CXX0X__
	  *__position = __x_copy;
  a7:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  ab:	48 89 c7             	mov    %rax,%rdi
  ae:	e8 00 00 00 00       	callq  b3 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0xb3>
  b3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  b7:	48 89 10             	mov    %rdx,(%rax)
			- this->_M_impl._M_start);
	  this->_M_impl._M_start = __new_start;
	  this->_M_impl._M_finish = __new_finish;
	  this->_M_impl._M_end_of_storage = __new_start + __len;
	}
    }
  ba:	e9 17 02 00 00       	jmpq   2d6 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x2d6>
#endif
	}
      else
	{
	  const size_type __len =
	    _M_check_len(size_type(1), "vector::_M_insert_aux");
  bf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  c3:	ba 00 00 00 00       	mov    $0x0,%edx
  c8:	be 01 00 00 00       	mov    $0x1,%esi
  cd:	48 89 c7             	mov    %rax,%rdi
  d0:	e8 00 00 00 00       	callq  d5 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0xd5>
  d5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	  const size_type __elems_before = __position - begin();
  d9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  dd:	48 89 c7             	mov    %rax,%rdi
  e0:	e8 00 00 00 00       	callq  e5 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0xe5>
  e5:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  e9:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  ed:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  f1:	48 89 d6             	mov    %rdx,%rsi
  f4:	48 89 c7             	mov    %rax,%rdi
  f7:	e8 00 00 00 00       	callq  fc <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0xfc>
  fc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	  pointer __new_start(this->_M_allocate(__len));
 100:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 104:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
 108:	48 89 d6             	mov    %rdx,%rsi
 10b:	48 89 c7             	mov    %rax,%rdi
 10e:	e8 00 00 00 00       	callq  113 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x113>
 113:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	  pointer __new_finish(__new_start);
 117:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 11b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	    {
	      // The order of the three operations is dictated by the C++0x
	      // case, where the moves could alter a new element belonging
	      // to the existing vector.  This is an issue only for callers
	      // taking the element by const lvalue ref (see 23.1/13).
	      this->_M_impl.construct(__new_start + __elems_before,
 11f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 123:	48 c1 e0 03          	shl    $0x3,%rax
 127:	48 89 c1             	mov    %rax,%rcx
 12a:	48 03 4d e8          	add    -0x18(%rbp),%rcx
 12e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 132:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
 136:	48 89 ce             	mov    %rcx,%rsi
 139:	48 89 c7             	mov    %rax,%rdi
 13c:	e8 00 00 00 00       	callq  141 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x141>
#ifdef __GXX_EXPERIMENTAL_CXX0X__
				      std::forward<_Args>(__args)...);
#else
	                              __x);
#endif
	      __new_finish = 0;
 141:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
 148:	00 

	      __new_finish =
 149:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 14d:	48 89 c7             	mov    %rax,%rdi
 150:	e8 00 00 00 00       	callq  155 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x155>
 155:	48 89 c3             	mov    %rax,%rbx
 158:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
 15c:	48 89 c7             	mov    %rax,%rdi
 15f:	e8 00 00 00 00       	callq  164 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x164>
 164:	48 8b 30             	mov    (%rax),%rsi
 167:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 16b:	48 8b 00             	mov    (%rax),%rax
 16e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 172:	48 89 d9             	mov    %rbx,%rcx
 175:	48 89 c7             	mov    %rax,%rdi
 178:	e8 00 00 00 00       	callq  17d <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x17d>
 17d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		std::__uninitialized_move_a(this->_M_impl._M_start,
					    __position.base(), __new_start,
					    _M_get_Tp_allocator());
	      ++__new_finish;
 181:	48 83 45 c8 08       	addq   $0x8,-0x38(%rbp)

	      __new_finish =
 186:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 18a:	48 89 c7             	mov    %rax,%rdi
 18d:	e8 00 00 00 00       	callq  192 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x192>
 192:	49 89 c4             	mov    %rax,%r12
 195:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 199:	48 8b 58 08          	mov    0x8(%rax),%rbx
 19d:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
 1a1:	48 89 c7             	mov    %rax,%rdi
 1a4:	e8 00 00 00 00       	callq  1a9 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x1a9>
 1a9:	48 8b 00             	mov    (%rax),%rax
 1ac:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
 1b0:	4c 89 e1             	mov    %r12,%rcx
 1b3:	48 89 de             	mov    %rbx,%rsi
 1b6:	48 89 c7             	mov    %rax,%rdi
 1b9:	e8 00 00 00 00       	callq  1be <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x1be>
 1be:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	      else
		std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
	      _M_deallocate(__new_start, __len);
	      __throw_exception_again;
	    }
	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
 1c2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 1c6:	48 89 c7             	mov    %rax,%rdi
 1c9:	e8 00 00 00 00       	callq  1ce <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x1ce>
 1ce:	48 89 c2             	mov    %rax,%rdx
 1d1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 1d5:	48 8b 48 08          	mov    0x8(%rax),%rcx
 1d9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 1dd:	48 8b 00             	mov    (%rax),%rax
 1e0:	48 89 ce             	mov    %rcx,%rsi
 1e3:	48 89 c7             	mov    %rax,%rdi
 1e6:	e8 00 00 00 00       	callq  1eb <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x1eb>
			_M_get_Tp_allocator());
	  _M_deallocate(this->_M_impl._M_start,
 1eb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 1ef:	48 8b 40 10          	mov    0x10(%rax),%rax
 1f3:	48 89 c2             	mov    %rax,%rdx
 1f6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 1fa:	48 8b 00             	mov    (%rax),%rax
 1fd:	48 89 d1             	mov    %rdx,%rcx
 200:	48 29 c1             	sub    %rax,%rcx
 203:	48 89 c8             	mov    %rcx,%rax
 206:	48 c1 f8 03          	sar    $0x3,%rax
 20a:	48 89 c2             	mov    %rax,%rdx
 20d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 211:	48 8b 08             	mov    (%rax),%rcx
 214:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 218:	48 89 ce             	mov    %rcx,%rsi
 21b:	48 89 c7             	mov    %rax,%rdi
 21e:	e8 00 00 00 00       	callq  223 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x223>
			this->_M_impl._M_end_of_storage
			- this->_M_impl._M_start);
	  this->_M_impl._M_start = __new_start;
 223:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 227:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 22b:	48 89 10             	mov    %rdx,(%rax)
	  this->_M_impl._M_finish = __new_finish;
 22e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 232:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
 236:	48 89 50 08          	mov    %rdx,0x8(%rax)
	  this->_M_impl._M_end_of_storage = __new_start + __len;
 23a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 23e:	48 c1 e0 03          	shl    $0x3,%rax
 242:	48 89 c2             	mov    %rax,%rdx
 245:	48 03 55 e8          	add    -0x18(%rbp),%rdx
 249:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 24d:	48 89 50 10          	mov    %rdx,0x10(%rax)
 251:	e9 80 00 00 00       	jmpq   2d6 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x2d6>
 256:	48 89 c3             	mov    %rax,%rbx
		std::__uninitialized_move_a(__position.base(),
					    this->_M_impl._M_finish,
					    __new_finish,
					    _M_get_Tp_allocator());
	    }
          __catch(...)
 259:	e8 00 00 00 00       	callq  25e <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x25e>
 25e:	48 89 d8             	mov    %rbx,%rax
 261:	48 89 c7             	mov    %rax,%rdi
 264:	e8 00 00 00 00       	callq  269 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x269>
 269:	48 89 c7             	mov    %rax,%rdi
 26c:	e8 00 00 00 00       	callq  271 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x271>
	    {
	      if (!__new_finish)
 271:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
 276:	75 20                	jne    298 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x298>
		this->_M_impl.destroy(__new_start + __elems_before);
 278:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 27c:	48 c1 e0 03          	shl    $0x3,%rax
 280:	48 89 c2             	mov    %rax,%rdx
 283:	48 03 55 e8          	add    -0x18(%rbp),%rdx
 287:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 28b:	48 89 d6             	mov    %rdx,%rsi
 28e:	48 89 c7             	mov    %rax,%rdi
 291:	e8 00 00 00 00       	callq  296 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x296>
 296:	eb 22                	jmp    2ba <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x2ba>
	      else
		std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
 298:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 29c:	48 89 c7             	mov    %rax,%rdi
 29f:	e8 00 00 00 00       	callq  2a4 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x2a4>
 2a4:	48 89 c2             	mov    %rax,%rdx
 2a7:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
 2ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 2af:	48 89 ce             	mov    %rcx,%rsi
 2b2:	48 89 c7             	mov    %rax,%rdi
 2b5:	e8 00 00 00 00       	callq  2ba <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x2ba>
	      _M_deallocate(__new_start, __len);
 2ba:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 2be:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
 2c2:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
 2c6:	48 89 ce             	mov    %rcx,%rsi
 2c9:	48 89 c7             	mov    %rax,%rdi
 2cc:	e8 00 00 00 00       	callq  2d1 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x2d1>
	      __throw_exception_again;
 2d1:	e8 00 00 00 00       	callq  2d6 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_insert_aux(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >, base::TestCase* const&)+0x2d6>
			- this->_M_impl._M_start);
	  this->_M_impl._M_start = __new_start;
	  this->_M_impl._M_finish = __new_finish;
	  this->_M_impl._M_end_of_storage = __new_start + __len;
	}
    }
 2d6:	48 83 c4 50          	add    $0x50,%rsp
 2da:	5b                   	pop    %rbx
 2db:	41 5c                	pop    %r12
 2dd:	5d                   	pop    %rbp
 2de:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx17__normal_iteratorIPPN4base8TestCaseESt6vectorIS3_SaIS3_EEEC2ERKS4_:

0000000000000000 <__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >::__normal_iterator(base::TestCase** const&)>:
      typedef typename __traits_type::pointer   	pointer;

      _GLIBCXX_CONSTEXPR __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  10:	48 8b 10             	mov    (%rax),%rdx
  13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  17:	48 89 10             	mov    %rdx,(%rax)
  1a:	5d                   	pop    %rbp
  1b:	c3                   	retq   

Disassembly of section .text._ZNK9__gnu_cxx17__normal_iteratorIPPN4base8TestCaseESt6vectorIS3_SaIS3_EEE4baseEv:

0000000000000000 <__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >::base() const>:
      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return _M_current; }
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	5d                   	pop    %rbp
   d:	c3                   	retq   

Disassembly of section .text._ZNK9__gnu_cxx17__normal_iteratorIPKPN4base8TestCaseESt6vectorIS3_SaIS3_EEE4baseEv:

0000000000000000 <__gnu_cxx::__normal_iterator<base::TestCase* const*, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >::base() const>:
      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return _M_current; }
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	5d                   	pop    %rbp
   d:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorISt4pairIKSsbEEC2Ev:

0000000000000000 <__gnu_cxx::new_allocator<std::pair<std::string const, bool> >::new_allocator()>:

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	5d                   	pop    %rbp
   9:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorISt4pairIKSsbEED2Ev:

0000000000000000 <__gnu_cxx::new_allocator<std::pair<std::string const, bool> >::~new_allocator()>:
      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	5d                   	pop    %rbp
   9:	c3                   	retq   

Disassembly of section .text._ZNSt3tr115__unordered_mapISsbNS_4hashISsEESt8equal_toISsESaISt4pairIKSsbEELb0EEC2EmRKS2_RKS4_RKS8_:

0000000000000000 <std::tr1::__unordered_map<std::string, bool, std::tr1::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<std::string const, bool> >, false>::__unordered_map(unsigned long, std::tr1::hash<std::string> const&, std::equal_to<std::string> const&, std::allocator<std::pair<std::string const, bool> > const&)>:
      typedef typename _Base::hasher          hasher;
      typedef typename _Base::key_equal       key_equal;
      typedef typename _Base::allocator_type  allocator_type;

      explicit
      __unordered_map(size_type __n = 10,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 50          	sub    $0x50,%rsp
   8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  10:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  14:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  18:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
		      const hasher& __hf = hasher(),
		      const key_equal& __eql = key_equal(),
		      const allocator_type& __a = allocator_type())
      : _Base(__n, __hf, __detail::_Mod_range_hashing(),
	      __detail::_Default_ranged_hash(),
	      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)
  1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  20:	4c 8b 4d d0          	mov    -0x30(%rbp),%r9
  24:	4c 8d 45 fe          	lea    -0x2(%rbp),%r8
  28:	48 8d 4d fd          	lea    -0x3(%rbp),%rcx
  2c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  30:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  34:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  38:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  3d:	48 8d 7d ff          	lea    -0x1(%rbp),%rdi
  41:	48 89 3c 24          	mov    %rdi,(%rsp)
  45:	48 89 c7             	mov    %rax,%rdi
  48:	e8 00 00 00 00       	callq  4d <std::tr1::__unordered_map<std::string, bool, std::tr1::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<std::string const, bool> >, false>::__unordered_map(unsigned long, std::tr1::hash<std::string> const&, std::equal_to<std::string> const&, std::allocator<std::pair<std::string const, bool> > const&)+0x4d>
      { }
  4d:	c9                   	leaveq 
  4e:	c3                   	retq   

Disassembly of section .text._ZNSaINSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEED2Ev:

0000000000000000 <std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >::~allocator()>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >::~allocator()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE5clearEv:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::clear()>:
  template<typename _Key, typename _Value,
	   typename _Allocator, typename _ExtractKey, typename _Equal,
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    clear()
    {
      _M_deallocate_nodes(_M_buckets, _M_bucket_count);
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 8b 50 10          	mov    0x10(%rax),%rdx
  14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  18:	48 8b 48 08          	mov    0x8(%rax),%rcx
  1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  20:	48 89 ce             	mov    %rcx,%rsi
  23:	48 89 c7             	mov    %rax,%rdi
  26:	e8 00 00 00 00       	callq  2b <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::clear()+0x2b>
      _M_element_count = 0;
  2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  2f:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  36:	00 
    }
  37:	c9                   	leaveq 
  38:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE21_M_deallocate_bucketsEPPNSB_10_Hash_nodeIS3_Lb0EEEm:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_buckets(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, unsigned long)>:
  template<typename _Key, typename _Value,
	   typename _Allocator, typename _ExtractKey, typename _Equal,
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 30          	sub    $0x30,%rsp
   8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  10:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_buckets(_Node** __p, size_type __n)
    {
      _Bucket_allocator_type __alloc(_M_node_allocator);
  14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  18:	48 8d 50 04          	lea    0x4(%rax),%rdx
  1c:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  20:	48 89 d6             	mov    %rdx,%rsi
  23:	48 89 c7             	mov    %rax,%rdi
  26:	e8 00 00 00 00       	callq  2b <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_buckets(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, unsigned long)+0x2b>
      __alloc.deallocate(__p, __n + 1);
  2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  2f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  33:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  37:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  3b:	48 89 ce             	mov    %rcx,%rsi
  3e:	48 89 c7             	mov    %rax,%rdi
  41:	e8 00 00 00 00       	callq  46 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_buckets(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, unsigned long)+0x46>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_buckets(_Node** __p, size_type __n)
    {
      _Bucket_allocator_type __alloc(_M_node_allocator);
  46:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  4a:	48 89 c7             	mov    %rax,%rdi
  4d:	e8 00 00 00 00       	callq  52 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_buckets(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, unsigned long)+0x52>
      __alloc.deallocate(__p, __n + 1);
    }
  52:	c9                   	leaveq 
  53:	c3                   	retq   

Disassembly of section .text._ZNSt4pairISsbEC2ERKSsRKb:

0000000000000000 <std::pair<std::string, bool>::pair(std::string const&, bool const&)>:
       *  respective default constructors.  */
      _GLIBCXX_CONSTEXPR pair()
      : first(), second() { }

      /** Two objects may be passed to a @c pair constructor to be copied.  */
      _GLIBCXX_CONSTEXPR pair(const _T1& __a, const _T2& __b)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      : first(__a), second(__b) { }
  14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  18:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  1c:	48 89 d6             	mov    %rdx,%rsi
  1f:	48 89 c7             	mov    %rax,%rdi
  22:	e8 00 00 00 00       	callq  27 <std::pair<std::string, bool>::pair(std::string const&, bool const&)+0x27>
  27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  2b:	0f b6 10             	movzbl (%rax),%edx
  2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  32:	88 50 08             	mov    %dl,0x8(%rax)
  35:	c9                   	leaveq 
  36:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE9_M_insertERKS3_NS_17integral_constantIbLb1EEE:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert(std::pair<std::string const, bool> const&, std::tr1::integral_constant<bool, true>)>:
	   bool __chc, bool __cit, bool __uk>
    std::pair<typename _Hashtable<_Key, _Value, _Allocator,
				  _ExtractKey, _Equal, _H1,
				  _H2, _Hash, _RehashPolicy,
				  __chc, __cit, __uk>::iterator, bool>
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 70          	sub    $0x70,%rsp
   8:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
   c:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  10:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
  _M_insert(const value_type& __v, std::tr1::true_type)
    {
      const key_type& __k = this->_M_extract(__v);
  14:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  18:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  1c:	48 89 d6             	mov    %rdx,%rsi
  1f:	48 89 c7             	mov    %rax,%rdi
  22:	e8 00 00 00 00       	callq  27 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert(std::pair<std::string const, bool> const&, std::tr1::integral_constant<bool, true>)+0x27>
  27:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);
  2b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  2f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  33:	48 89 d6             	mov    %rdx,%rsi
  36:	48 89 c7             	mov    %rax,%rdi
  39:	e8 00 00 00 00       	callq  3e <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert(std::pair<std::string const, bool> const&, std::tr1::integral_constant<bool, true>)+0x3e>
  3e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);
  42:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  46:	48 8b 48 10          	mov    0x10(%rax),%rcx
  4a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  4e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  52:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  56:	48 89 c7             	mov    %rax,%rdi
  59:	e8 00 00 00 00       	callq  5e <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert(std::pair<std::string const, bool> const&, std::tr1::integral_constant<bool, true>)+0x5e>
  5e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

      if (_Node* __p = _M_find_node(_M_buckets[__n], __k, __code))
  62:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  66:	48 8b 40 08          	mov    0x8(%rax),%rax
  6a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  6e:	48 c1 e2 03          	shl    $0x3,%rdx
  72:	48 01 d0             	add    %rdx,%rax
  75:	48 8b 30             	mov    (%rax),%rsi
  78:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  7c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  84:	48 89 c7             	mov    %rax,%rdi
  87:	e8 00 00 00 00       	callq  8c <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert(std::pair<std::string const, bool> const&, std::tr1::integral_constant<bool, true>)+0x8c>
  8c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  90:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  95:	74 41                	je     d8 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert(std::pair<std::string const, bool> const&, std::tr1::integral_constant<bool, true>)+0xd8>
	return std::make_pair(iterator(__p, _M_buckets + __n), false);
  97:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  9b:	48 8b 40 08          	mov    0x8(%rax),%rax
  9f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  a3:	48 c1 e2 03          	shl    $0x3,%rdx
  a7:	48 01 c2             	add    %rax,%rdx
  aa:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  ae:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  b2:	48 89 ce             	mov    %rcx,%rsi
  b5:	48 89 c7             	mov    %rax,%rdi
  b8:	e8 00 00 00 00       	callq  bd <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert(std::pair<std::string const, bool> const&, std::tr1::integral_constant<bool, true>)+0xbd>
  bd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  c1:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  c5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  c9:	b9 00 00 00 00       	mov    $0x0,%ecx
  ce:	48 89 c7             	mov    %rax,%rdi
  d1:	e8 00 00 00 00       	callq  d6 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert(std::pair<std::string const, bool> const&, std::tr1::integral_constant<bool, true>)+0xd6>
  d6:	eb 4f                	jmp    127 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert(std::pair<std::string const, bool> const&, std::tr1::integral_constant<bool, true>)+0x127>
      return std::make_pair(_M_insert_bucket(__v, __n, __code), true);
  d8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  dc:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  e0:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
  e4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  e8:	48 89 c7             	mov    %rax,%rdi
  eb:	e8 00 00 00 00       	callq  f0 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert(std::pair<std::string const, bool> const&, std::tr1::integral_constant<bool, true>)+0xf0>
  f0:	48 89 c1             	mov    %rax,%rcx
  f3:	48 89 d0             	mov    %rdx,%rax
  f6:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
  fa:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  fe:	48 8b 45 90          	mov    -0x70(%rbp),%rax
 102:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
 106:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 10a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 10e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 112:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
 116:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
 11a:	b9 01 00 00 00       	mov    $0x1,%ecx
 11f:	48 89 c7             	mov    %rax,%rdi
 122:	e8 00 00 00 00       	callq  127 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert(std::pair<std::string const, bool> const&, std::tr1::integral_constant<bool, true>)+0x127>
    }
 127:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 12b:	c9                   	leaveq 
 12c:	c3                   	retq   

Disassembly of section .text._ZNKSt3tr18__detail15_Hash_code_baseISsSt4pairIKSsbESt10_Select1stIS4_ESt8equal_toISsENS_4hashISsEENS0_18_Mod_range_hashingENS0_20_Default_ranged_hashELb0EE12_M_hash_codeERS3_:

0000000000000000 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_hash_code(std::string const&) const>:
      : _M_extract(__ex), _M_eq(__eq), _M_h1(__h1), _M_h2(__h2) { }

      typedef std::size_t _Hash_code_type;

      _Hash_code_type
      _M_hash_code(const _Key& __k) const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 28          	sub    $0x28,%rsp
   9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
   d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
      { return _M_h1(__k); }
  11:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  15:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  19:	48 89 d6             	mov    %rdx,%rsi
  1c:	48 89 c7             	mov    %rax,%rdi
  1f:	e8 00 00 00 00       	callq  24 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_hash_code(std::string const&) const+0x24>
  24:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  28:	48 8d 50 02          	lea    0x2(%rax),%rdx
  2c:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  30:	48 89 c6             	mov    %rax,%rsi
  33:	48 89 d7             	mov    %rdx,%rdi
  36:	e8 00 00 00 00       	callq  3b <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_hash_code(std::string const&) const+0x3b>
  3b:	48 89 c3             	mov    %rax,%rbx
  3e:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  42:	48 89 c7             	mov    %rax,%rdi
  45:	e8 00 00 00 00       	callq  4a <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_hash_code(std::string const&) const+0x4a>
  4a:	48 89 d8             	mov    %rbx,%rax
  4d:	48 83 c4 28          	add    $0x28,%rsp
  51:	5b                   	pop    %rbx
  52:	5d                   	pop    %rbp
  53:	c3                   	retq   
  54:	48 89 c3             	mov    %rax,%rbx
  57:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  5b:	48 89 c7             	mov    %rax,%rdi
  5e:	e8 00 00 00 00       	callq  63 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_hash_code(std::string const&) const+0x63>
  63:	48 89 d8             	mov    %rbx,%rax
  66:	48 89 c7             	mov    %rax,%rdi
  69:	e8 00 00 00 00       	callq  6e <(anonymous namespace)::Concurrency_counters_Test::me_+0x56>

Disassembly of section .text._ZNKSt3tr18__detail15_Hash_code_baseISsSt4pairIKSsbESt10_Select1stIS4_ESt8equal_toISsENS_4hashISsEENS0_18_Mod_range_hashingENS0_20_Default_ranged_hashELb0EE15_M_bucket_indexERS3_mm:

0000000000000000 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_bucket_index(std::string const&, unsigned long, unsigned long) const>:
      
      std::size_t
      _M_bucket_index(const _Key&, _Hash_code_type __c,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  14:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
		      std::size_t __n) const
      { return _M_h2(__c, __n); }
  18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1c:	48 8d 48 03          	lea    0x3(%rax),%rcx
  20:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  28:	48 89 c6             	mov    %rax,%rsi
  2b:	48 89 cf             	mov    %rcx,%rdi
  2e:	e8 00 00 00 00       	callq  33 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_bucket_index(std::string const&, unsigned long, unsigned long) const+0x33>
  33:	c9                   	leaveq 
  34:	c3                   	retq   

Disassembly of section .text._ZNKSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE12_M_find_nodeEPNSB_10_Hash_nodeIS3_Lb0EEERS2_m:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_find_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*, std::string const&, unsigned long) const>:
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey,
			_Equal, _H1, _H2, _Hash, _RehashPolicy,
			__chc, __cit, __uk>::_Node*
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  14:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_find_node(_Node* __p, const key_type& __k,
		typename _Hashtable::_Hash_code_type __code) const
    {
      for (; __p; __p = __p->_M_next)
  18:	eb 2e                	jmp    48 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_find_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*, std::string const&, unsigned long) const+0x48>
	if (this->_M_compare(__k, __code, __p))
  1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1e:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  22:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  26:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  2a:	48 89 c7             	mov    %rax,%rdi
  2d:	e8 00 00 00 00       	callq  32 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_find_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*, std::string const&, unsigned long) const+0x32>
  32:	84 c0                	test   %al,%al
  34:	74 06                	je     3c <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_find_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*, std::string const&, unsigned long) const+0x3c>
	  return __p;
  36:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  3a:	eb 1d                	jmp    59 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_find_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*, std::string const&, unsigned long) const+0x59>
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_find_node(_Node* __p, const key_type& __k,
		typename _Hashtable::_Hash_code_type __code) const
    {
      for (; __p; __p = __p->_M_next)
  3c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  40:	48 8b 40 10          	mov    0x10(%rax),%rax
  44:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  48:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  4d:	0f 95 c0             	setne  %al
  50:	84 c0                	test   %al,%al
  52:	75 c6                	jne    1a <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_find_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*, std::string const&, unsigned long) const+0x1a>
	if (this->_M_compare(__k, __code, __p))
	  return __p;
      return false;
  54:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  59:	c9                   	leaveq 
  5a:	c3                   	retq   

Disassembly of section .text._ZNSt3tr18__detail19_Hashtable_iteratorISt4pairIKSsbELb0ELb0EEC2EPNS0_10_Hash_nodeIS4_Lb0EEEPS8_:

0000000000000000 <std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>::_Hashtable_iterator(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**)>:
      typedef std::forward_iterator_tag                iterator_category;

      _Hashtable_iterator()
      : _Hashtable_iterator_base<_Value, __cache>(0, 0) { }

      _Hashtable_iterator(_Hash_node<_Value, __cache>* __p,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
			  _Hash_node<_Value, __cache>** __b)
      : _Hashtable_iterator_base<_Value, __cache>(__p, __b) { }
  14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  18:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  1c:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  20:	48 89 ce             	mov    %rcx,%rsi
  23:	48 89 c7             	mov    %rax,%rdi
  26:	e8 00 00 00 00       	callq  2b <std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>::_Hashtable_iterator(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**)+0x2b>
  2b:	c9                   	leaveq 
  2c:	c3                   	retq   

Disassembly of section .text._ZNKSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE4sizeEv:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::size() const>:
      const_iterator
      end() const
      { return const_iterator(_M_buckets + _M_bucket_count); }

      size_type
      size() const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return _M_element_count; }
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	48 8b 40 18          	mov    0x18(%rax),%rax
  10:	5d                   	pop    %rbp
  11:	c3                   	retq   

Disassembly of section .text._ZNSt3tr18__detail19_Hashtable_iteratorISt4pairIKSsbELb0ELb0EEC2EPPNS0_10_Hash_nodeIS4_Lb0EEE:

0000000000000000 <std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>::_Hashtable_iterator(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**)>:

      explicit
      _Hashtable_iterator(_Hash_node<_Value, __cache>** __b)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
      : _Hashtable_iterator_base<_Value, __cache>(*__b, __b) { }
  10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  14:	48 8b 08             	mov    (%rax),%rcx
  17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  1f:	48 89 ce             	mov    %rcx,%rsi
  22:	48 89 c7             	mov    %rax,%rdi
  25:	e8 00 00 00 00       	callq  2a <std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>::_Hashtable_iterator(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**)+0x2a>
  2a:	c9                   	leaveq 
  2b:	c3                   	retq   

Disassembly of section .text._ZSt11__addressofISt4pairIKSsbEEPT_RS3_:

0000000000000000 <std::pair<std::string const, bool>* std::__addressof<std::pair<std::string const, bool> >(std::pair<std::string const, bool>&)>:
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  // Used, in C++03 mode too, by allocators, etc.
  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    {
      return reinterpret_cast<_Tp*>
	(&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    }
   c:	5d                   	pop    %rbp
   d:	c3                   	retq   

Disassembly of section .text._ZNSt3tr18__detail24_Hashtable_iterator_baseISt4pairIKSsbELb0EE14_M_incr_bucketEv:

0000000000000000 <std::tr1::__detail::_Hashtable_iterator_base<std::pair<std::string const, bool>, false>::_M_incr_bucket()>:

  // Global iterators, used for arbitrary iteration within a hash
  // table.  Larger and more expensive than local iterators.
  template<typename _Value, bool __cache>
    void
    _Hashtable_iterator_base<_Value, __cache>::
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    _M_incr_bucket()
    {
      ++_M_cur_bucket;
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	48 8b 40 08          	mov    0x8(%rax),%rax
  10:	48 8d 50 08          	lea    0x8(%rax),%rdx
  14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  18:	48 89 50 08          	mov    %rdx,0x8(%rax)

      // This loop requires the bucket array to have a non-null sentinel.
      while (!*_M_cur_bucket)
  1c:	eb 14                	jmp    32 <std::tr1::__detail::_Hashtable_iterator_base<std::pair<std::string const, bool>, false>::_M_incr_bucket()+0x32>
	++_M_cur_bucket;
  1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  22:	48 8b 40 08          	mov    0x8(%rax),%rax
  26:	48 8d 50 08          	lea    0x8(%rax),%rdx
  2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  2e:	48 89 50 08          	mov    %rdx,0x8(%rax)
    _M_incr_bucket()
    {
      ++_M_cur_bucket;

      // This loop requires the bucket array to have a non-null sentinel.
      while (!*_M_cur_bucket)
  32:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  36:	48 8b 40 08          	mov    0x8(%rax),%rax
  3a:	48 8b 00             	mov    (%rax),%rax
  3d:	48 85 c0             	test   %rax,%rax
  40:	0f 94 c0             	sete   %al
  43:	84 c0                	test   %al,%al
  45:	75 d7                	jne    1e <std::tr1::__detail::_Hashtable_iterator_base<std::pair<std::string const, bool>, false>::_M_incr_bucket()+0x1e>
	++_M_cur_bucket;
      _M_cur_node = *_M_cur_bucket;
  47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  4b:	48 8b 40 08          	mov    0x8(%rax),%rax
  4f:	48 8b 10             	mov    (%rax),%rdx
  52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  56:	48 89 10             	mov    %rdx,(%rax)
    }
  59:	5d                   	pop    %rbp
  5a:	c3                   	retq   

Disassembly of section .text._ZNSt3tr18__detail24_Hashtable_iterator_baseISt4pairIKSsbELb0EE7_M_incrEv:

0000000000000000 <std::tr1::__detail::_Hashtable_iterator_base<std::pair<std::string const, bool>, false>::_M_incr()>:
      _Hashtable_iterator_base(_Hash_node<_Value, __cache>* __node,
			       _Hash_node<_Value, __cache>** __bucket)
      : _M_cur_node(__node), _M_cur_bucket(__bucket) { }

      void
      _M_incr()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      {
	_M_cur_node = _M_cur_node->_M_next;
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 8b 00             	mov    (%rax),%rax
  13:	48 8b 50 10          	mov    0x10(%rax),%rdx
  17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1b:	48 89 10             	mov    %rdx,(%rax)
	if (!_M_cur_node)
  1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  22:	48 8b 00             	mov    (%rax),%rax
  25:	48 85 c0             	test   %rax,%rax
  28:	75 0c                	jne    36 <std::tr1::__detail::_Hashtable_iterator_base<std::pair<std::string const, bool>, false>::_M_incr()+0x36>
	  _M_incr_bucket();
  2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  2e:	48 89 c7             	mov    %rax,%rdi
  31:	e8 00 00 00 00       	callq  36 <std::tr1::__detail::_Hashtable_iterator_base<std::pair<std::string const, bool>, false>::_M_incr()+0x36>
      }
  36:	c9                   	leaveq 
  37:	c3                   	retq   

Disassembly of section .text._ZNSt6vectorIPN4base8TestCaseESaIS2_EE15_M_erase_at_endEPS2_:

0000000000000000 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_erase_at_end(base::TestCase**)>:
      // Internal erase functions follow.

      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
      // _M_assign_aux.
      void
      _M_erase_at_end(pointer __pos)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
      {
	std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
  10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  14:	48 89 c7             	mov    %rax,%rdi
  17:	e8 00 00 00 00       	callq  1c <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_erase_at_end(base::TestCase**)+0x1c>
  1c:	48 89 c2             	mov    %rax,%rdx
  1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  23:	48 8b 48 08          	mov    0x8(%rax),%rcx
  27:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  2b:	48 89 ce             	mov    %rcx,%rsi
  2e:	48 89 c7             	mov    %rax,%rdi
  31:	e8 00 00 00 00       	callq  36 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_erase_at_end(base::TestCase**)+0x36>
	this->_M_impl._M_finish = __pos;
  36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  3a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  3e:	48 89 50 08          	mov    %rdx,0x8(%rax)
      }
  42:	c9                   	leaveq 
  43:	c3                   	retq   

Disassembly of section .text._ZN4base8CallbackIvvvvvEC2Ev:

0000000000000000 <base::Callback<void, void, void, void, void>::Callback()>:

template<typename Res, typename Args1=void, typename Args2=void, typename Args3=void, typename Args4=void>
class Callback;

template<typename Res>
class Callback<Res> {
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  13:	5d                   	pop    %rbp
  14:	c3                   	retq   

Disassembly of section .text._ZSt19__iterator_categoryIPKmENSt15iterator_traitsIT_E17iterator_categoryERKS3_:

0000000000000000 <std::iterator_traits<unsigned long const*>::iterator_category std::__iterator_category<unsigned long const*>(unsigned long const* const&)>:
   *  This function is not a part of the C++ standard but is syntactic
   *  sugar for internal library use only.
  */
  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    { return typename iterator_traits<_Iter>::iterator_category(); }
   8:	5d                   	pop    %rbp
   9:	c3                   	retq   

Disassembly of section .text._ZSt10__distanceIPKmENSt15iterator_traitsIT_E15difference_typeES3_S3_St26random_access_iterator_tag:

0000000000000000 <std::iterator_traits<unsigned long const*>::difference_type std::__distance<unsigned long const*>(unsigned long const*, unsigned long const*, std::random_access_iterator_tag)>:
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
               random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      return __last - __first;
   c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  14:	48 89 d1             	mov    %rdx,%rcx
  17:	48 29 c1             	sub    %rax,%rcx
  1a:	48 89 c8             	mov    %rcx,%rax
  1d:	48 c1 f8 03          	sar    $0x3,%rax
    }
  21:	5d                   	pop    %rbp
  22:	c3                   	retq   

Disassembly of section .text._ZSt9__advanceIPKmlEvRT_T0_St26random_access_iterator_tag:

0000000000000000 <void std::__advance<unsigned long const*, long>(unsigned long const*&, long, std::random_access_iterator_tag)>:
	  --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
              random_access_iterator_tag)
    {
      // concept requirements
      __glibcxx_function_requires(_RandomAccessIteratorConcept<
				  _RandomAccessIterator>)
      __i += __n;
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 8b 00             	mov    (%rax),%rax
  13:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  17:	48 c1 e2 03          	shl    $0x3,%rdx
  1b:	48 01 c2             	add    %rax,%rdx
  1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  22:	48 89 10             	mov    %rdx,(%rax)
    }
  25:	5d                   	pop    %rbp
  26:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorINSt3tr18__detail10_Hash_nodeISt4pairIKSsSsELb0EEEED2Ev:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false> >::~new_allocator()>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	5d                   	pop    %rbp
   9:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsSsESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE19_M_deallocate_nodesEPPNSB_10_Hash_nodeIS3_Lb0EEEm:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_nodes(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>**, unsigned long)>:
  template<typename _Key, typename _Value,
	   typename _Allocator, typename _ExtractKey, typename _Equal,
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 40          	sub    $0x40,%rsp
   8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
   c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  10:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_nodes(_Node** __array, size_type __n)
    {
      for (size_type __i = 0; __i < __n; ++__i)
  14:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  1b:	00 
  1c:	eb 60                	jmp    7e <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_nodes(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>**, unsigned long)+0x7e>
	{
	  _Node* __p = __array[__i];
  1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  22:	48 c1 e0 03          	shl    $0x3,%rax
  26:	48 03 45 d0          	add    -0x30(%rbp),%rax
  2a:	48 8b 00             	mov    (%rax),%rax
  2d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	  while (__p)
  31:	eb 27                	jmp    5a <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_nodes(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>**, unsigned long)+0x5a>
	    {
	      _Node* __tmp = __p;
  33:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  37:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	      __p = __p->_M_next;
  3b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  3f:	48 8b 40 10          	mov    0x10(%rax),%rax
  43:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	      _M_deallocate_node(__tmp);
  47:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  4b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4f:	48 89 d6             	mov    %rdx,%rsi
  52:	48 89 c7             	mov    %rax,%rdi
  55:	e8 00 00 00 00       	callq  5a <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_nodes(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>**, unsigned long)+0x5a>
    _M_deallocate_nodes(_Node** __array, size_type __n)
    {
      for (size_type __i = 0; __i < __n; ++__i)
	{
	  _Node* __p = __array[__i];
	  while (__p)
  5a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  5f:	0f 95 c0             	setne  %al
  62:	84 c0                	test   %al,%al
  64:	75 cd                	jne    33 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_nodes(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>**, unsigned long)+0x33>
	    {
	      _Node* __tmp = __p;
	      __p = __p->_M_next;
	      _M_deallocate_node(__tmp);
	    }
	  __array[__i] = 0;
  66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  6a:	48 c1 e0 03          	shl    $0x3,%rax
  6e:	48 03 45 d0          	add    -0x30(%rbp),%rax
  72:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_nodes(_Node** __array, size_type __n)
    {
      for (size_type __i = 0; __i < __n; ++__i)
  79:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  86:	0f 92 c0             	setb   %al
  89:	84 c0                	test   %al,%al
  8b:	75 91                	jne    1e <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_nodes(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>**, unsigned long)+0x1e>
	      __p = __p->_M_next;
	      _M_deallocate_node(__tmp);
	    }
	  __array[__i] = 0;
	}
    }
  8d:	c9                   	leaveq 
  8e:	c3                   	retq   

Disassembly of section .text._ZNSaIPNSt3tr18__detail10_Hash_nodeISt4pairIKSsSsELb0EEEEC2IS5_EERKSaIT_E:

0000000000000000 <std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*>::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false> >(std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false> > const&)>:

      allocator(const allocator& __a) throw()
      : __glibcxx_base_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  14:	48 89 c7             	mov    %rax,%rdi
  17:	e8 00 00 00 00       	callq  1c <std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*>::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false> >(std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false> > const&)+0x1c>
  1c:	c9                   	leaveq 
  1d:	c3                   	retq   

Disassembly of section .text._ZNSaIPNSt3tr18__detail10_Hash_nodeISt4pairIKSsSsELb0EEEED2Ev:

0000000000000000 <std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*>::~allocator()>:

      ~allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*>::~allocator()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorIPNSt3tr18__detail10_Hash_nodeISt4pairIKSsSsELb0EEEE10deallocateEPS8_m:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*>::deallocate(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>**, unsigned long)>:
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      { ::operator delete(__p); }
  14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  18:	48 89 c7             	mov    %rax,%rdi
  1b:	e8 00 00 00 00       	callq  20 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*>::deallocate(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>**, unsigned long)+0x20>
  20:	c9                   	leaveq 
  21:	c3                   	retq   

Disassembly of section .text._ZNSaIPN4base8TestCaseEED2Ev:

0000000000000000 <std::allocator<base::TestCase*>::~allocator()>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::allocator<base::TestCase*>::~allocator()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZNSt12_Vector_baseIPN4base8TestCaseESaIS2_EE13_M_deallocateEPS2_m:

0000000000000000 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_M_deallocate(base::TestCase**, unsigned long)>:
      typename _Tp_alloc_type::pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(typename _Tp_alloc_type::pointer __p, size_t __n)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      {
	if (__p)
  14:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  19:	74 17                	je     32 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_M_deallocate(base::TestCase**, unsigned long)+0x32>
	  _M_impl.deallocate(__p, __n);
  1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  23:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  27:	48 89 ce             	mov    %rcx,%rsi
  2a:	48 89 c7             	mov    %rax,%rdi
  2d:	e8 00 00 00 00       	callq  32 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_M_deallocate(base::TestCase**, unsigned long)+0x32>
      }
  32:	c9                   	leaveq 
  33:	c3                   	retq   

Disassembly of section .text._ZSt8_DestroyIPPN4base8TestCaseEEvT_S4_:

0000000000000000 <void std::_Destroy<base::TestCase**>(base::TestCase**, base::TestCase**)>:
   * a trivial destructor, the compiler should optimize all of this
   * away, otherwise the objects' destructors must be invoked.
   */
  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
  10:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  18:	48 89 d6             	mov    %rdx,%rsi
  1b:	48 89 c7             	mov    %rax,%rdi
  1e:	e8 00 00 00 00       	callq  23 <void std::_Destroy<base::TestCase**>(base::TestCase**, base::TestCase**)+0x23>
	__destroy(__first, __last);
    }
  23:	c9                   	leaveq 
  24:	c3                   	retq   

Disassembly of section .text._ZNSt12_Vector_baseIPN4base8TestCaseESaIS2_EE12_Vector_implC2Ev:

0000000000000000 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_Vector_impl::_Vector_impl()>:
      {
	typename _Tp_alloc_type::pointer _M_start;
	typename _Tp_alloc_type::pointer _M_finish;
	typename _Tp_alloc_type::pointer _M_end_of_storage;

	_Vector_impl()
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	: _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_Vector_impl::_Vector_impl()+0x18>
  18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  27:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  2e:	00 
  2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  33:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  3a:	00 
	{ }
  3b:	c9                   	leaveq 
  3c:	c3                   	retq   

Disassembly of section .text._ZSt13copy_backwardIPPN4base8TestCaseES3_ET0_T_S5_S4_:

0000000000000000 <base::TestCase** std::copy_backward<base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)>:
   *  Result may not be in the range [first,last).  Use copy instead.  Note
   *  that the start of the output range may overlap [first,last).
  */
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 28          	sub    $0x28,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  11:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	    typename iterator_traits<_BI2>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
	      (std::__miter_base(__first), std::__miter_base(__last),
	       __result));
  15:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  19:	48 89 c7             	mov    %rax,%rdi
  1c:	e8 00 00 00 00       	callq  21 <base::TestCase** std::copy_backward<base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x21>
  21:	48 89 c3             	mov    %rax,%rbx
  24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  28:	48 89 c7             	mov    %rax,%rdi
  2b:	e8 00 00 00 00       	callq  30 <base::TestCase** std::copy_backward<base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x30>
  30:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  34:	48 89 de             	mov    %rbx,%rsi
  37:	48 89 c7             	mov    %rax,%rdi
  3a:	e8 00 00 00 00       	callq  3f <base::TestCase** std::copy_backward<base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x3f>
    }
  3f:	48 83 c4 28          	add    $0x28,%rsp
  43:	5b                   	pop    %rbx
  44:	5d                   	pop    %rbp
  45:	c3                   	retq   

Disassembly of section .text._ZNK9__gnu_cxx17__normal_iteratorIPPN4base8TestCaseESt6vectorIS3_SaIS3_EEEdeEv:

0000000000000000 <__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >::operator*() const>:
		      _Container>::__type>& __i)
        : _M_current(__i.base()) { }

      // Forward iterator requirements
      reference
      operator*() const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return *_M_current; }
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	48 8b 00             	mov    (%rax),%rax
   f:	5d                   	pop    %rbp
  10:	c3                   	retq   

Disassembly of section .text._ZNKSt6vectorIPN4base8TestCaseESaIS2_EE12_M_check_lenEmPKc:

0000000000000000 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_check_len(unsigned long, char const*) const>:
        _M_insert_aux(iterator __position, _Args&&... __args);
#endif

      // Called by the latter.
      size_type
      _M_check_len(size_type __n, const char* __s) const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 38          	sub    $0x38,%rsp
   9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
   d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  11:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
      {
	if (max_size() - size() < __n)
  15:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  19:	48 89 c7             	mov    %rax,%rdi
  1c:	e8 00 00 00 00       	callq  21 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_check_len(unsigned long, char const*) const+0x21>
  21:	48 89 c3             	mov    %rax,%rbx
  24:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  28:	48 89 c7             	mov    %rax,%rdi
  2b:	e8 00 00 00 00       	callq  30 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_check_len(unsigned long, char const*) const+0x30>
  30:	48 89 da             	mov    %rbx,%rdx
  33:	48 29 c2             	sub    %rax,%rdx
  36:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  3a:	48 39 c2             	cmp    %rax,%rdx
  3d:	0f 92 c0             	setb   %al
  40:	84 c0                	test   %al,%al
  42:	74 0c                	je     50 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_check_len(unsigned long, char const*) const+0x50>
	  __throw_length_error(__N(__s));
  44:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  48:	48 89 c7             	mov    %rax,%rdi
  4b:	e8 00 00 00 00       	callq  50 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_check_len(unsigned long, char const*) const+0x50>

	const size_type __len = size() + std::max(size(), __n);
  50:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  54:	48 89 c7             	mov    %rax,%rdi
  57:	e8 00 00 00 00       	callq  5c <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_check_len(unsigned long, char const*) const+0x5c>
  5c:	48 89 c3             	mov    %rax,%rbx
  5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  63:	48 89 c7             	mov    %rax,%rdi
  66:	e8 00 00 00 00       	callq  6b <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_check_len(unsigned long, char const*) const+0x6b>
  6b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  6f:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  73:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  77:	48 89 d6             	mov    %rdx,%rsi
  7a:	48 89 c7             	mov    %rax,%rdi
  7d:	e8 00 00 00 00       	callq  82 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_check_len(unsigned long, char const*) const+0x82>
  82:	48 8b 00             	mov    (%rax),%rax
  85:	48 01 d8             	add    %rbx,%rax
  88:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	return (__len < size() || __len > max_size()) ? max_size() : __len;
  8c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  90:	48 89 c7             	mov    %rax,%rdi
  93:	e8 00 00 00 00       	callq  98 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_check_len(unsigned long, char const*) const+0x98>
  98:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  9c:	77 12                	ja     b0 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_check_len(unsigned long, char const*) const+0xb0>
  9e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  a2:	48 89 c7             	mov    %rax,%rdi
  a5:	e8 00 00 00 00       	callq  aa <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_check_len(unsigned long, char const*) const+0xaa>
  aa:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  ae:	73 0e                	jae    be <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_check_len(unsigned long, char const*) const+0xbe>
  b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  b4:	48 89 c7             	mov    %rax,%rdi
  b7:	e8 00 00 00 00       	callq  bc <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_check_len(unsigned long, char const*) const+0xbc>
  bc:	eb 04                	jmp    c2 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::_M_check_len(unsigned long, char const*) const+0xc2>
  be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
      }
  c2:	48 83 c4 38          	add    $0x38,%rsp
  c6:	5b                   	pop    %rbx
  c7:	5d                   	pop    %rbp
  c8:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxxmiIPPN4base8TestCaseESt6vectorIS3_SaIS3_EEEENS_17__normal_iteratorIT_T0_E15difference_typeERKSB_SE_:

0000000000000000 <__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >::difference_type __gnu_cxx::operator-<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > > const&, __gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > > const&)>:
#endif
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 18          	sub    $0x18,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	      const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }
  11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  15:	48 89 c7             	mov    %rax,%rdi
  18:	e8 00 00 00 00       	callq  1d <__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >::difference_type __gnu_cxx::operator-<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > > const&, __gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > > const&)+0x1d>
  1d:	48 8b 00             	mov    (%rax),%rax
  20:	48 89 c3             	mov    %rax,%rbx
  23:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  27:	48 89 c7             	mov    %rax,%rdi
  2a:	e8 00 00 00 00       	callq  2f <__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >::difference_type __gnu_cxx::operator-<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > >(__gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > > const&, __gnu_cxx::__normal_iterator<base::TestCase**, std::vector<base::TestCase*, std::allocator<base::TestCase*> > > const&)+0x2f>
  2f:	48 8b 00             	mov    (%rax),%rax
  32:	48 89 da             	mov    %rbx,%rdx
  35:	48 29 c2             	sub    %rax,%rdx
  38:	48 89 d0             	mov    %rdx,%rax
  3b:	48 c1 f8 03          	sar    $0x3,%rax
  3f:	48 83 c4 18          	add    $0x18,%rsp
  43:	5b                   	pop    %rbx
  44:	5d                   	pop    %rbp
  45:	c3                   	retq   

Disassembly of section .text._ZNSt12_Vector_baseIPN4base8TestCaseESaIS2_EE11_M_allocateEm:

0000000000000000 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_M_allocate(unsigned long)>:

    public:
      _Vector_impl _M_impl;

      typename _Tp_alloc_type::pointer
      _M_allocate(size_t __n)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }
  10:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  15:	74 1a                	je     31 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_M_allocate(unsigned long)+0x31>
  17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1b:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  1f:	ba 00 00 00 00       	mov    $0x0,%edx
  24:	48 89 ce             	mov    %rcx,%rsi
  27:	48 89 c7             	mov    %rax,%rdi
  2a:	e8 00 00 00 00       	callq  2f <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_M_allocate(unsigned long)+0x2f>
  2f:	eb 05                	jmp    36 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_M_allocate(unsigned long)+0x36>
  31:	b8 00 00 00 00       	mov    $0x0,%eax
  36:	c9                   	leaveq 
  37:	c3                   	retq   

Disassembly of section .text._ZSt22__uninitialized_move_aIPPN4base8TestCaseES3_SaIS2_EET0_T_S6_S5_RT1_:

0000000000000000 <base::TestCase** std::__uninitialized_move_a<base::TestCase**, base::TestCase**, std::allocator<base::TestCase*> >(base::TestCase**, base::TestCase**, base::TestCase**, std::allocator<base::TestCase*>&)>:
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
	   typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  14:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
			   _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(_GLIBCXX_MAKE_MOVE_ITERATOR(__first),
					 _GLIBCXX_MAKE_MOVE_ITERATOR(__last),
					 __result, __alloc);
  18:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  1c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  20:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  28:	48 89 c7             	mov    %rax,%rdi
  2b:	e8 00 00 00 00       	callq  30 <base::TestCase** std::__uninitialized_move_a<base::TestCase**, base::TestCase**, std::allocator<base::TestCase*> >(base::TestCase**, base::TestCase**, base::TestCase**, std::allocator<base::TestCase*>&)+0x30>
    }
  30:	c9                   	leaveq 
  31:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorIPN4base8TestCaseEE7destroyEPS3_:

0000000000000000 <__gnu_cxx::new_allocator<base::TestCase*>::destroy(base::TestCase**)>:
        construct(pointer __p, _Args&&... __args)
	{ ::new((void *)__p) _Tp(std::forward<_Args>(__args)...); }
#endif

      void 
      destroy(pointer __p) { __p->~_Tp(); }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   c:	5d                   	pop    %rbp
   d:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EEC2EmRKSA_RKSC_RKSD_RKS8_RKS6_RKS4_:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_Hashtable(unsigned long, std::tr1::hash<std::string> const&, std::tr1::__detail::_Mod_range_hashing const&, std::tr1::__detail::_Default_ranged_hash const&, std::equal_to<std::string> const&, std::_Select1st<std::pair<std::string const, bool> > const&, std::allocator<std::pair<std::string const, bool> > const&)>:

  template<typename _Key, typename _Value,
	   typename _Allocator, typename _ExtractKey, typename _Equal,
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 38          	sub    $0x38,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  11:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  15:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  19:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  1d:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
							__h1, __h2, __h),
      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),
      _M_node_allocator(__a),
      _M_bucket_count(0),
      _M_element_count(0),
      _M_rehash_policy()
  21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  25:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
  29:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  2d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  31:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  35:	49 89 f9             	mov    %rdi,%r9
  38:	49 89 f0             	mov    %rsi,%r8
  3b:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  3f:	48 89 c7             	mov    %rax,%rdi
  42:	e8 00 00 00 00       	callq  47 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_Hashtable(unsigned long, std::tr1::hash<std::string> const&, std::tr1::__detail::_Mod_range_hashing const&, std::tr1::__detail::_Default_ranged_hash const&, std::equal_to<std::string> const&, std::_Select1st<std::pair<std::string const, bool> > const&, std::allocator<std::pair<std::string const, bool> > const&)+0x47>
  47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  4b:	48 8d 50 04          	lea    0x4(%rax),%rdx
  4f:	48 8b 45 18          	mov    0x18(%rbp),%rax
  53:	48 89 c6             	mov    %rax,%rsi
  56:	48 89 d7             	mov    %rdx,%rdi
  59:	e8 00 00 00 00       	callq  5e <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_Hashtable(unsigned long, std::tr1::hash<std::string> const&, std::tr1::__detail::_Mod_range_hashing const&, std::tr1::__detail::_Default_ranged_hash const&, std::equal_to<std::string> const&, std::_Select1st<std::pair<std::string const, bool> > const&, std::allocator<std::pair<std::string const, bool> > const&)+0x5e>
  5e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  62:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  69:	00 
  6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  6e:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  75:	00 
  76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  7a:	48 83 c0 20          	add    $0x20,%rax
  7e:	f3 0f 10 05 00 00 00 	movss  0x0(%rip),%xmm0        # 86 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_Hashtable(unsigned long, std::tr1::hash<std::string> const&, std::tr1::__detail::_Mod_range_hashing const&, std::tr1::__detail::_Default_ranged_hash const&, std::equal_to<std::string> const&, std::_Select1st<std::pair<std::string const, bool> > const&, std::allocator<std::pair<std::string const, bool> > const&)+0x86>
  85:	00 
  86:	48 89 c7             	mov    %rax,%rdi
  89:	e8 00 00 00 00       	callq  8e <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_Hashtable(unsigned long, std::tr1::hash<std::string> const&, std::tr1::__detail::_Mod_range_hashing const&, std::tr1::__detail::_Default_ranged_hash const&, std::equal_to<std::string> const&, std::_Select1st<std::pair<std::string const, bool> > const&, std::allocator<std::pair<std::string const, bool> > const&)+0x8e>
    {
      _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);
  8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  92:	48 8d 50 20          	lea    0x20(%rax),%rdx
  96:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  9a:	48 89 c6             	mov    %rax,%rsi
  9d:	48 89 d7             	mov    %rdx,%rdi
  a0:	e8 00 00 00 00       	callq  a5 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_Hashtable(unsigned long, std::tr1::hash<std::string> const&, std::tr1::__detail::_Mod_range_hashing const&, std::tr1::__detail::_Default_ranged_hash const&, std::equal_to<std::string> const&, std::_Select1st<std::pair<std::string const, bool> > const&, std::allocator<std::pair<std::string const, bool> > const&)+0xa5>
  a5:	48 89 c2             	mov    %rax,%rdx
  a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  ac:	48 89 50 10          	mov    %rdx,0x10(%rax)
      _M_buckets = _M_allocate_buckets(_M_bucket_count);
  b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  b4:	48 8b 50 10          	mov    0x10(%rax),%rdx
  b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  bc:	48 89 d6             	mov    %rdx,%rsi
  bf:	48 89 c7             	mov    %rax,%rdi
  c2:	e8 00 00 00 00       	callq  c7 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_Hashtable(unsigned long, std::tr1::hash<std::string> const&, std::tr1::__detail::_Mod_range_hashing const&, std::tr1::__detail::_Default_ranged_hash const&, std::equal_to<std::string> const&, std::_Select1st<std::pair<std::string const, bool> > const&, std::allocator<std::pair<std::string const, bool> > const&)+0xc7>
  c7:	48 89 c2             	mov    %rax,%rdx
  ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  ce:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
  d2:	48 83 c4 38          	add    $0x38,%rsp
  d6:	5b                   	pop    %rbx
  d7:	5d                   	pop    %rbp
  d8:	c3                   	retq   
  d9:	48 89 c3             	mov    %rax,%rbx
							__h1, __h2, __h),
      __detail::_Map_base<_Key, _Value, _ExtractKey, __uk, _Hashtable>(),
      _M_node_allocator(__a),
      _M_bucket_count(0),
      _M_element_count(0),
      _M_rehash_policy()
  dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  e0:	48 83 c0 04          	add    $0x4,%rax
  e4:	48 89 c7             	mov    %rax,%rdi
  e7:	e8 00 00 00 00       	callq  ec <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_Hashtable(unsigned long, std::tr1::hash<std::string> const&, std::tr1::__detail::_Mod_range_hashing const&, std::tr1::__detail::_Default_ranged_hash const&, std::equal_to<std::string> const&, std::_Select1st<std::pair<std::string const, bool> > const&, std::allocator<std::pair<std::string const, bool> > const&)+0xec>
  ec:	48 89 d8             	mov    %rbx,%rax
  ef:	48 89 c7             	mov    %rax,%rdi
  f2:	e8 00 00 00 00       	callq  f7 <(anonymous namespace)::Concurrency_counters_Test::me_+0xdf>

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorINSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEED2Ev:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >::~new_allocator()>:
      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	5d                   	pop    %rbp
   9:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE19_M_deallocate_nodesEPPNSB_10_Hash_nodeIS3_Lb0EEEm:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_nodes(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, unsigned long)>:
  template<typename _Key, typename _Value,
	   typename _Allocator, typename _ExtractKey, typename _Equal,
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 40          	sub    $0x40,%rsp
   8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
   c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  10:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_nodes(_Node** __array, size_type __n)
    {
      for (size_type __i = 0; __i < __n; ++__i)
  14:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  1b:	00 
  1c:	eb 60                	jmp    7e <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_nodes(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, unsigned long)+0x7e>
	{
	  _Node* __p = __array[__i];
  1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  22:	48 c1 e0 03          	shl    $0x3,%rax
  26:	48 03 45 d0          	add    -0x30(%rbp),%rax
  2a:	48 8b 00             	mov    (%rax),%rax
  2d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	  while (__p)
  31:	eb 27                	jmp    5a <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_nodes(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, unsigned long)+0x5a>
	    {
	      _Node* __tmp = __p;
  33:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  37:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	      __p = __p->_M_next;
  3b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  3f:	48 8b 40 10          	mov    0x10(%rax),%rax
  43:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	      _M_deallocate_node(__tmp);
  47:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  4b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  4f:	48 89 d6             	mov    %rdx,%rsi
  52:	48 89 c7             	mov    %rax,%rdi
  55:	e8 00 00 00 00       	callq  5a <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_nodes(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, unsigned long)+0x5a>
    _M_deallocate_nodes(_Node** __array, size_type __n)
    {
      for (size_type __i = 0; __i < __n; ++__i)
	{
	  _Node* __p = __array[__i];
	  while (__p)
  5a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  5f:	0f 95 c0             	setne  %al
  62:	84 c0                	test   %al,%al
  64:	75 cd                	jne    33 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_nodes(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, unsigned long)+0x33>
	    {
	      _Node* __tmp = __p;
	      __p = __p->_M_next;
	      _M_deallocate_node(__tmp);
	    }
	  __array[__i] = 0;
  66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  6a:	48 c1 e0 03          	shl    $0x3,%rax
  6e:	48 03 45 d0          	add    -0x30(%rbp),%rax
  72:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_nodes(_Node** __array, size_type __n)
    {
      for (size_type __i = 0; __i < __n; ++__i)
  79:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  86:	0f 92 c0             	setb   %al
  89:	84 c0                	test   %al,%al
  8b:	75 91                	jne    1e <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_nodes(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, unsigned long)+0x1e>
	      __p = __p->_M_next;
	      _M_deallocate_node(__tmp);
	    }
	  __array[__i] = 0;
	}
    }
  8d:	c9                   	leaveq 
  8e:	c3                   	retq   

Disassembly of section .text._ZNSaIPNSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEEC2IS5_EERKSaIT_E:

0000000000000000 <std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >(std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> > const&)>:

      allocator(const allocator& __a) throw()
      : __glibcxx_base_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  14:	48 89 c7             	mov    %rax,%rdi
  17:	e8 00 00 00 00       	callq  1c <std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >(std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> > const&)+0x1c>
  1c:	c9                   	leaveq 
  1d:	c3                   	retq   

Disassembly of section .text._ZNSaIPNSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEED2Ev:

0000000000000000 <std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::~allocator()>:

      ~allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::~allocator()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorIPNSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEE10deallocateEPS8_m:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::deallocate(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, unsigned long)>:
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      { ::operator delete(__p); }
  14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  18:	48 89 c7             	mov    %rax,%rdi
  1b:	e8 00 00 00 00       	callq  20 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::deallocate(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, unsigned long)+0x20>
  20:	c9                   	leaveq 
  21:	c3                   	retq   

Disassembly of section .text._ZNKSt10_Select1stISt4pairIKSsbEEclERKS2_:

0000000000000000 <std::_Select1st<std::pair<std::string const, bool> >::operator()(std::pair<std::string const, bool> const&) const>:
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
      { return __x.first; }
   c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  10:	5d                   	pop    %rbp
  11:	c3                   	retq   

Disassembly of section .text._ZSt9make_pairINSt3tr18__detail19_Hashtable_iteratorISt4pairIKSsbELb0ELb0EEEbES3_IT_T0_ES7_S8_:

0000000000000000 <std::pair<std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>, bool> std::make_pair<std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>, bool>(std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>, bool)>:
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
#else
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	89 c8                	mov    %ecx,%eax
   e:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  12:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  16:	88 45 e4             	mov    %al,-0x1c(%rbp)
    { return pair<_T1, _T2>(__x, __y); }
  19:	48 8d 55 e4          	lea    -0x1c(%rbp),%rdx
  1d:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  21:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  25:	48 89 ce             	mov    %rcx,%rsi
  28:	48 89 c7             	mov    %rax,%rdi
  2b:	e8 00 00 00 00       	callq  30 <std::pair<std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>, bool> std::make_pair<std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>, bool>(std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>, bool)+0x30>
  30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  34:	c9                   	leaveq 
  35:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE16_M_insert_bucketERKS3_mm:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert_bucket(std::pair<std::string const, bool> const&, unsigned long, unsigned long)>:
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
			_H1, _H2, _Hash, _RehashPolicy,
			__chc, __cit, __uk>::iterator
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 78          	sub    $0x78,%rsp
   9:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
   d:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  11:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  15:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
    _M_insert_bucket(const value_type& __v, size_type __n,
		    typename _Hashtable::_Hash_code_type __code)
    {
      std::pair<bool, std::size_t> __do_rehash
	= _M_rehash_policy._M_need_rehash(_M_bucket_count,
					  _M_element_count, 1);
  19:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  1d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  21:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  25:	48 8b 40 10          	mov    0x10(%rax),%rax
  29:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  2d:	48 8d 79 20          	lea    0x20(%rcx),%rdi
  31:	b9 01 00 00 00       	mov    $0x1,%ecx
  36:	48 89 c6             	mov    %rax,%rsi
  39:	e8 00 00 00 00       	callq  3e <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert_bucket(std::pair<std::string const, bool> const&, unsigned long, unsigned long)+0x3e>
  3e:	89 c1                	mov    %eax,%ecx
  40:	48 89 d0             	mov    %rdx,%rax
  43:	89 4d 80             	mov    %ecx,-0x80(%rbp)
  46:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  4a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  4e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  52:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  56:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

      // Allocate the new node before doing the rehash so that we don't
      // do a rehash if the allocation throws.
      _Node* __new_node = _M_allocate_node(__v);
  5a:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  5e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  62:	48 89 d6             	mov    %rdx,%rsi
  65:	48 89 c7             	mov    %rax,%rdi
  68:	e8 00 00 00 00       	callq  6d <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert_bucket(std::pair<std::string const, bool> const&, unsigned long, unsigned long)+0x6d>
  6d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

      __try
	{
	  if (__do_rehash.first)
  71:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
  75:	84 c0                	test   %al,%al
  77:	74 46                	je     bf <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert_bucket(std::pair<std::string const, bool> const&, unsigned long, unsigned long)+0xbf>
	    {
	      const key_type& __k = this->_M_extract(__v);
  79:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  7d:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  81:	48 89 d6             	mov    %rdx,%rsi
  84:	48 89 c7             	mov    %rax,%rdi
  87:	e8 00 00 00 00       	callq  8c <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert_bucket(std::pair<std::string const, bool> const&, unsigned long, unsigned long)+0x8c>
  8c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	      __n = this->_M_bucket_index(__k, __code, __do_rehash.second);
  90:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  94:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  98:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  9c:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  a0:	48 89 c7             	mov    %rax,%rdi
  a3:	e8 00 00 00 00       	callq  a8 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert_bucket(std::pair<std::string const, bool> const&, unsigned long, unsigned long)+0xa8>
  a8:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	      _M_rehash(__do_rehash.second);
  ac:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  b0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  b4:	48 89 d6             	mov    %rdx,%rsi
  b7:	48 89 c7             	mov    %rax,%rdi
  ba:	e8 00 00 00 00       	callq  bf <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert_bucket(std::pair<std::string const, bool> const&, unsigned long, unsigned long)+0xbf>
	    }

	  __new_node->_M_next = _M_buckets[__n];
  bf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  c3:	48 8b 40 08          	mov    0x8(%rax),%rax
  c7:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  cb:	48 c1 e2 03          	shl    $0x3,%rdx
  cf:	48 01 d0             	add    %rdx,%rax
  d2:	48 8b 10             	mov    (%rax),%rdx
  d5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  d9:	48 89 50 10          	mov    %rdx,0x10(%rax)
	  this->_M_store_code(__new_node, __code);
  dd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  e1:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  e5:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  e9:	48 89 ce             	mov    %rcx,%rsi
  ec:	48 89 c7             	mov    %rax,%rdi
  ef:	e8 00 00 00 00       	callq  f4 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert_bucket(std::pair<std::string const, bool> const&, unsigned long, unsigned long)+0xf4>
	  _M_buckets[__n] = __new_node;
  f4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  f8:	48 8b 40 08          	mov    0x8(%rax),%rax
  fc:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
 100:	48 c1 e2 03          	shl    $0x3,%rdx
 104:	48 01 c2             	add    %rax,%rdx
 107:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 10b:	48 89 02             	mov    %rax,(%rdx)
	  ++_M_element_count;
 10e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 112:	48 8b 40 18          	mov    0x18(%rax),%rax
 116:	48 8d 50 01          	lea    0x1(%rax),%rdx
 11a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 11e:	48 89 50 18          	mov    %rdx,0x18(%rax)
	  return iterator(__new_node, _M_buckets + __n);
 122:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 126:	48 8b 40 08          	mov    0x8(%rax),%rax
 12a:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
 12e:	48 c1 e2 03          	shl    $0x3,%rdx
 132:	48 01 c2             	add    %rax,%rdx
 135:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
 139:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
 13d:	48 89 ce             	mov    %rcx,%rsi
 140:	48 89 c7             	mov    %rax,%rdi
 143:	e8 00 00 00 00       	callq  148 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert_bucket(std::pair<std::string const, bool> const&, unsigned long, unsigned long)+0x148>
 148:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 14c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
 150:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 154:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 158:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 15c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
      __catch(...)
	{
	  _M_deallocate_node(__new_node);
	  __throw_exception_again;
	}
    }
 160:	48 83 c4 78          	add    $0x78,%rsp
 164:	5b                   	pop    %rbx
 165:	5d                   	pop    %rbp
 166:	c3                   	retq   
 167:	48 89 c3             	mov    %rax,%rbx
	  this->_M_store_code(__new_node, __code);
	  _M_buckets[__n] = __new_node;
	  ++_M_element_count;
	  return iterator(__new_node, _M_buckets + __n);
	}
      __catch(...)
 16a:	e8 00 00 00 00       	callq  16f <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert_bucket(std::pair<std::string const, bool> const&, unsigned long, unsigned long)+0x16f>
 16f:	48 89 d8             	mov    %rbx,%rax
 172:	48 89 c7             	mov    %rax,%rdi
 175:	e8 00 00 00 00       	callq  17a <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert_bucket(std::pair<std::string const, bool> const&, unsigned long, unsigned long)+0x17a>
 17a:	48 89 c7             	mov    %rax,%rdi
 17d:	e8 00 00 00 00       	callq  182 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert_bucket(std::pair<std::string const, bool> const&, unsigned long, unsigned long)+0x182>
	{
	  _M_deallocate_node(__new_node);
 182:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
 186:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 18a:	48 89 d6             	mov    %rdx,%rsi
 18d:	48 89 c7             	mov    %rax,%rdi
 190:	e8 00 00 00 00       	callq  195 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_insert_bucket(std::pair<std::string const, bool> const&, unsigned long, unsigned long)+0x195>
	  __throw_exception_again;
 195:	e8 00 00 00 00       	callq  19a <vtable for (anonymous namespace)::Basic_LockUnlock_Test+0x1a>

Disassembly of section .text._ZNKSt3tr18__detail15_Hash_code_baseISsSt4pairIKSsbESt10_Select1stIS4_ESt8equal_toISsENS_4hashISsEENS0_18_Mod_range_hashingENS0_20_Default_ranged_hashELb0EE10_M_compareERS3_mPNS0_10_Hash_nodeIS4_Lb0EEE:

0000000000000000 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_compare(std::string const&, unsigned long, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*) const>:
      _M_bucket_index(const _Hash_node<_Value, false>* __p,
		      std::size_t __n) const
      { return _M_h2(_M_h1(_M_extract(__p->_M_v)), __n); }

      bool
      _M_compare(const _Key& __k, _Hash_code_type,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  14:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
		 _Hash_node<_Value, false>* __n) const
      { return _M_eq(__k, _M_extract(__n->_M_v)); }
  18:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  20:	48 89 d6             	mov    %rdx,%rsi
  23:	48 89 c7             	mov    %rax,%rdi
  26:	e8 00 00 00 00       	callq  2b <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_compare(std::string const&, unsigned long, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*) const+0x2b>
  2b:	48 89 c2             	mov    %rax,%rdx
  2e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  32:	48 8d 48 01          	lea    0x1(%rax),%rcx
  36:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  3a:	48 89 c6             	mov    %rax,%rsi
  3d:	48 89 cf             	mov    %rcx,%rdi
  40:	e8 00 00 00 00       	callq  45 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_compare(std::string const&, unsigned long, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*) const+0x45>
  45:	c9                   	leaveq 
  46:	c3                   	retq   

Disassembly of section .text._ZNSt3tr18__detail24_Hashtable_iterator_baseISt4pairIKSsbELb0EEC2EPNS0_10_Hash_nodeIS4_Lb0EEEPS8_:

0000000000000000 <std::tr1::__detail::_Hashtable_iterator_base<std::pair<std::string const, bool>, false>::_Hashtable_iterator_base(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**)>:
    };

  template<typename _Value, bool __cache>
    struct _Hashtable_iterator_base
    {
      _Hashtable_iterator_base(_Hash_node<_Value, __cache>* __node,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
			       _Hash_node<_Value, __cache>** __bucket)
      : _M_cur_node(__node), _M_cur_bucket(__bucket) { }
  10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  14:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  18:	48 89 10             	mov    %rdx,(%rax)
  1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  23:	48 89 50 08          	mov    %rdx,0x8(%rax)
  27:	5d                   	pop    %rbp
  28:	c3                   	retq   

Disassembly of section .text._ZN4base8CallbackIvvvvvED2Ev:

0000000000000000 <base::Callback<void, void, void, void, void>::~Callback()>:
public:
  virtual ~Callback() {}
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  17:	b8 00 00 00 00       	mov    $0x0,%eax
  1c:	83 e0 01             	and    $0x1,%eax
  1f:	84 c0                	test   %al,%al
  21:	74 0c                	je     2f <base::Callback<void, void, void, void, void>::~Callback()+0x2f>
  23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  27:	48 89 c7             	mov    %rax,%rdi
  2a:	e8 00 00 00 00       	callq  2f <base::Callback<void, void, void, void, void>::~Callback()+0x2f>
  2f:	c9                   	leaveq 
  30:	c3                   	retq   

Disassembly of section .text._ZN4base8CallbackIvvvvvED0Ev:

0000000000000000 <base::Callback<void, void, void, void, void>::~Callback()>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <base::Callback<void, void, void, void, void>::~Callback()+0x18>
  18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1c:	48 89 c7             	mov    %rax,%rdi
  1f:	e8 00 00 00 00       	callq  24 <base::Callback<void, void, void, void, void>::~Callback()+0x24>
  24:	c9                   	leaveq 
  25:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsSsESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE18_M_deallocate_nodeEPNSB_10_Hash_nodeIS3_Lb0EEE:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*)>:
  template<typename _Key, typename _Value,
	   typename _Allocator, typename _ExtractKey, typename _Equal,
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 28          	sub    $0x28,%rsp
   9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
   d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_node(_Node* __n)
    {
      _M_get_Value_allocator().destroy(&__n->_M_v);
  11:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
  15:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  19:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  1d:	48 89 d6             	mov    %rdx,%rsi
  20:	48 89 c7             	mov    %rax,%rdi
  23:	e8 00 00 00 00       	callq  28 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*)+0x28>
  28:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  2c:	48 89 de             	mov    %rbx,%rsi
  2f:	48 89 c7             	mov    %rax,%rdi
  32:	e8 00 00 00 00       	callq  37 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*)+0x37>
  37:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  3b:	48 89 c7             	mov    %rax,%rdi
  3e:	e8 00 00 00 00       	callq  43 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*)+0x43>
      _M_node_allocator.deallocate(__n, 1);
  43:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  47:	48 8d 48 04          	lea    0x4(%rax),%rcx
  4b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4f:	ba 01 00 00 00       	mov    $0x1,%edx
  54:	48 89 c6             	mov    %rax,%rsi
  57:	48 89 cf             	mov    %rcx,%rdi
  5a:	e8 00 00 00 00       	callq  5f <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*)+0x5f>
    }
  5f:	48 83 c4 28          	add    $0x28,%rsp
  63:	5b                   	pop    %rbx
  64:	5d                   	pop    %rbp
  65:	c3                   	retq   
  66:	48 89 c3             	mov    %rax,%rbx
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_node(_Node* __n)
    {
      _M_get_Value_allocator().destroy(&__n->_M_v);
  69:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  6d:	48 89 c7             	mov    %rax,%rdi
  70:	e8 00 00 00 00       	callq  75 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*)+0x75>
  75:	48 89 d8             	mov    %rbx,%rax
  78:	48 89 c7             	mov    %rax,%rdi
  7b:	e8 00 00 00 00       	callq  80 <(anonymous namespace)::Concurrency_counters_Test::me_+0x68>

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorIPNSt3tr18__detail10_Hash_nodeISt4pairIKSsSsELb0EEEEC2Ev:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*>::new_allocator()>:

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	5d                   	pop    %rbp
   9:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorIPNSt3tr18__detail10_Hash_nodeISt4pairIKSsSsELb0EEEED2Ev:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*>::~new_allocator()>:
      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	5d                   	pop    %rbp
   9:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorIPN4base8TestCaseEED2Ev:

0000000000000000 <__gnu_cxx::new_allocator<base::TestCase*>::~new_allocator()>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	5d                   	pop    %rbp
   9:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorIPN4base8TestCaseEE10deallocateEPS3_m:

0000000000000000 <__gnu_cxx::new_allocator<base::TestCase*>::deallocate(base::TestCase**, unsigned long)>:
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      { ::operator delete(__p); }
  14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  18:	48 89 c7             	mov    %rax,%rdi
  1b:	e8 00 00 00 00       	callq  20 <__gnu_cxx::new_allocator<base::TestCase*>::deallocate(base::TestCase**, unsigned long)+0x20>
  20:	c9                   	leaveq 
  21:	c3                   	retq   

Disassembly of section .text._ZNSt12_Destroy_auxILb1EE9__destroyIPPN4base8TestCaseEEEvT_S6_:

0000000000000000 <void std::_Destroy_aux<true>::__destroy<base::TestCase**>(base::TestCase**, base::TestCase**)>:
  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   c:	5d                   	pop    %rbp
   d:	c3                   	retq   

Disassembly of section .text._ZNSaIPN4base8TestCaseEEC2Ev:

0000000000000000 <std::allocator<base::TestCase*>::allocator()>:

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::allocator<base::TestCase*>::allocator()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZSt12__miter_baseIPPN4base8TestCaseEENSt11_Miter_baseIT_E13iterator_typeES5_:

0000000000000000 <std::_Miter_base<base::TestCase**>::iterator_type std::__miter_base<base::TestCase**>(base::TestCase**)>:
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::_Miter_base<base::TestCase**>::iterator_type std::__miter_base<base::TestCase**>(base::TestCase**)+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZSt23__copy_move_backward_a2ILb0EPPN4base8TestCaseES3_ET1_T0_S5_S4_:

0000000000000000 <base::TestCase** std::__copy_move_backward_a2<false, base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)>:
								 __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	41 54                	push   %r12
   6:	53                   	push   %rbx
   7:	48 83 ec 20          	sub    $0x20,%rsp
   b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  13:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
		  (std::__niter_base(__first), std::__niter_base(__last),
		   std::__niter_base(__result)));
  17:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  1b:	48 89 c7             	mov    %rax,%rdi
  1e:	e8 00 00 00 00       	callq  23 <base::TestCase** std::__copy_move_backward_a2<false, base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x23>
  23:	49 89 c4             	mov    %rax,%r12
  26:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  2a:	48 89 c7             	mov    %rax,%rdi
  2d:	e8 00 00 00 00       	callq  32 <base::TestCase** std::__copy_move_backward_a2<false, base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x32>
  32:	48 89 c3             	mov    %rax,%rbx
  35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  39:	48 89 c7             	mov    %rax,%rdi
  3c:	e8 00 00 00 00       	callq  41 <base::TestCase** std::__copy_move_backward_a2<false, base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x41>
  41:	4c 89 e2             	mov    %r12,%rdx
  44:	48 89 de             	mov    %rbx,%rsi
  47:	48 89 c7             	mov    %rax,%rdi
  4a:	e8 00 00 00 00       	callq  4f <base::TestCase** std::__copy_move_backward_a2<false, base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x4f>
    }
  4f:	48 83 c4 20          	add    $0x20,%rsp
  53:	5b                   	pop    %rbx
  54:	41 5c                	pop    %r12
  56:	5d                   	pop    %rbp
  57:	c3                   	retq   

Disassembly of section .text._ZNKSt6vectorIPN4base8TestCaseESaIS2_EE4sizeEv:

0000000000000000 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::size() const>:
#endif

      // [23.2.4.2] capacity
      /**  Returns the number of elements in the %vector.  */
      size_type
      size() const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	48 8b 40 08          	mov    0x8(%rax),%rax
  10:	48 89 c2             	mov    %rax,%rdx
  13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  17:	48 8b 00             	mov    (%rax),%rax
  1a:	48 89 d1             	mov    %rdx,%rcx
  1d:	48 29 c1             	sub    %rax,%rcx
  20:	48 89 c8             	mov    %rcx,%rax
  23:	48 c1 f8 03          	sar    $0x3,%rax
  27:	5d                   	pop    %rbp
  28:	c3                   	retq   

Disassembly of section .text._ZNKSt6vectorIPN4base8TestCaseESaIS2_EE8max_sizeEv:

0000000000000000 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::max_size() const>:

      /**  Returns the size() of the largest possible %vector.  */
      size_type
      max_size() const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return _M_get_Tp_allocator().max_size(); }
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::max_size() const+0x18>
  18:	48 89 c7             	mov    %rax,%rdi
  1b:	e8 00 00 00 00       	callq  20 <std::vector<base::TestCase*, std::allocator<base::TestCase*> >::max_size() const+0x20>
  20:	c9                   	leaveq 
  21:	c3                   	retq   

Disassembly of section .text._ZSt3maxImERKT_S2_S2_:

0000000000000000 <unsigned long const& std::max<unsigned long>(unsigned long const&, unsigned long const&)>:
   *  temporary expressions, since they are only evaluated once, unlike a
   *  preprocessor macro.
  */
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    {
      // concept requirements
      __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)
      //return  __a < __b ? __b : __a;
      if (__a < __b)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 8b 10             	mov    (%rax),%rdx
  13:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  17:	48 8b 00             	mov    (%rax),%rax
  1a:	48 39 c2             	cmp    %rax,%rdx
  1d:	73 06                	jae    25 <unsigned long const& std::max<unsigned long>(unsigned long const&, unsigned long const&)+0x25>
	return __b;
  1f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  23:	eb 04                	jmp    29 <unsigned long const& std::max<unsigned long>(unsigned long const&, unsigned long const&)+0x29>
      return __a;
  25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    }
  29:	5d                   	pop    %rbp
  2a:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorIPN4base8TestCaseEE8allocateEmPKv:

0000000000000000 <__gnu_cxx::new_allocator<base::TestCase*>::allocate(unsigned long, void const*)>:
      address(const_reference __x) const { return std::__addressof(__x); }

      // NB: __n is permitted to be 0.  The C++ standard says nothing
      // about what the return value is when __n == 0.
      pointer
      allocate(size_type __n, const void* = 0)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      { 
	if (__n > this->max_size())
  14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  18:	48 89 c7             	mov    %rax,%rdi
  1b:	e8 00 00 00 00       	callq  20 <__gnu_cxx::new_allocator<base::TestCase*>::allocate(unsigned long, void const*)+0x20>
  20:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  24:	0f 92 c0             	setb   %al
  27:	84 c0                	test   %al,%al
  29:	74 05                	je     30 <__gnu_cxx::new_allocator<base::TestCase*>::allocate(unsigned long, void const*)+0x30>
	  std::__throw_bad_alloc();
  2b:	e8 00 00 00 00       	callq  30 <__gnu_cxx::new_allocator<base::TestCase*>::allocate(unsigned long, void const*)+0x30>

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  34:	48 c1 e0 03          	shl    $0x3,%rax
  38:	48 89 c7             	mov    %rax,%rdi
  3b:	e8 00 00 00 00       	callq  40 <__gnu_cxx::new_allocator<base::TestCase*>::allocate(unsigned long, void const*)+0x40>
      }
  40:	c9                   	leaveq 
  41:	c3                   	retq   

Disassembly of section .text._ZSt22__uninitialized_copy_aIPPN4base8TestCaseES3_S2_ET0_T_S5_S4_RSaIT1_E:

0000000000000000 <base::TestCase** std::__uninitialized_copy_a<base::TestCase**, base::TestCase**, base::TestCase*>(base::TestCase**, base::TestCase**, base::TestCase**, std::allocator<base::TestCase*>&)>:
	}
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  14:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
			   _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }
  18:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  1c:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  20:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  24:	48 89 ce             	mov    %rcx,%rsi
  27:	48 89 c7             	mov    %rax,%rdi
  2a:	e8 00 00 00 00       	callq  2f <base::TestCase** std::__uninitialized_copy_a<base::TestCase**, base::TestCase**, base::TestCase*>(base::TestCase**, base::TestCase**, base::TestCase**, std::allocator<base::TestCase*>&)+0x2f>
  2f:	c9                   	leaveq 
  30:	c3                   	retq   

Disassembly of section .text._ZNSt3tr18__detail15_Hash_code_baseISsSt4pairIKSsbESt10_Select1stIS4_ESt8equal_toISsENS_4hashISsEENS0_18_Mod_range_hashingENS0_20_Default_ranged_hashELb0EEC2ERKS6_RKS8_RKSA_RKSB_RKSC_:

0000000000000000 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_Hash_code_base(std::_Select1st<std::pair<std::string const, bool> > const&, std::equal_to<std::string> const&, std::tr1::hash<std::string> const&, std::tr1::__detail::_Mod_range_hashing const&, std::tr1::__detail::_Default_ranged_hash const&)>:
      hasher
      hash_function() const
      { return _M_h1; }

    protected:
      _Hash_code_base(const _ExtractKey& __ex, const _Equal& __eq,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  10:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  14:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  18:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
		      const _H1& __h1, const _H2& __h2,
		      const _Default_ranged_hash&)
      : _M_extract(__ex), _M_eq(__eq), _M_h1(__h1), _M_h2(__h2) { }
  1c:	5d                   	pop    %rbp
  1d:	c3                   	retq   

Disassembly of section .text._ZNSaINSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEEC2IS4_EERKSaIT_E:

0000000000000000 <std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >::allocator<std::pair<std::string const, bool> >(std::allocator<std::pair<std::string const, bool> > const&)>:

      allocator(const allocator& __a) throw()
      : __glibcxx_base_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  14:	48 89 c7             	mov    %rax,%rdi
  17:	e8 00 00 00 00       	callq  1c <std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >::allocator<std::pair<std::string const, bool> >(std::allocator<std::pair<std::string const, bool> > const&)+0x1c>
  1c:	c9                   	leaveq 
  1d:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE19_M_allocate_bucketsEm:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_buckets(unsigned long)>:
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
			_H1, _H2, _Hash, _RehashPolicy,
			__chc, __cit, __uk>::_Node**
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 38          	sub    $0x38,%rsp
   9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
   d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_allocate_buckets(size_type __n)
    {
      _Bucket_allocator_type __alloc(_M_node_allocator);
  11:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  15:	48 8d 50 04          	lea    0x4(%rax),%rdx
  19:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  1d:	48 89 d6             	mov    %rdx,%rsi
  20:	48 89 c7             	mov    %rax,%rdi
  23:	e8 00 00 00 00       	callq  28 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_buckets(unsigned long)+0x28>

      // We allocate one extra bucket to hold a sentinel, an arbitrary
      // non-null pointer.  Iterator increment relies on this.
      _Node** __p = __alloc.allocate(__n + 1);
  28:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  2c:	48 8d 48 01          	lea    0x1(%rax),%rcx
  30:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  34:	ba 00 00 00 00       	mov    $0x0,%edx
  39:	48 89 ce             	mov    %rcx,%rsi
  3c:	48 89 c7             	mov    %rax,%rdi
  3f:	e8 00 00 00 00       	callq  44 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_buckets(unsigned long)+0x44>
  44:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      std::fill(__p, __p + __n, (_Node*) 0);
  48:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  4f:	00 
  50:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  54:	48 c1 e0 03          	shl    $0x3,%rax
  58:	48 89 c1             	mov    %rax,%rcx
  5b:	48 03 4d e0          	add    -0x20(%rbp),%rcx
  5f:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  63:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  67:	48 89 ce             	mov    %rcx,%rsi
  6a:	48 89 c7             	mov    %rax,%rdi
  6d:	e8 00 00 00 00       	callq  72 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_buckets(unsigned long)+0x72>
      __p[__n] = reinterpret_cast<_Node*>(0x1000);
  72:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  76:	48 c1 e0 03          	shl    $0x3,%rax
  7a:	48 03 45 e0          	add    -0x20(%rbp),%rax
  7e:	48 c7 00 00 10 00 00 	movq   $0x1000,(%rax)
      return __p;
  85:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
			__chc, __cit, __uk>::_Node**
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_allocate_buckets(size_type __n)
    {
      _Bucket_allocator_type __alloc(_M_node_allocator);
  89:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  8d:	48 89 c7             	mov    %rax,%rdi
  90:	e8 00 00 00 00       	callq  95 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_buckets(unsigned long)+0x95>
      // We allocate one extra bucket to hold a sentinel, an arbitrary
      // non-null pointer.  Iterator increment relies on this.
      _Node** __p = __alloc.allocate(__n + 1);
      std::fill(__p, __p + __n, (_Node*) 0);
      __p[__n] = reinterpret_cast<_Node*>(0x1000);
      return __p;
  95:	48 89 d8             	mov    %rbx,%rax
    }
  98:	48 83 c4 38          	add    $0x38,%rsp
  9c:	5b                   	pop    %rbx
  9d:	5d                   	pop    %rbp
  9e:	c3                   	retq   
  9f:	48 89 c3             	mov    %rax,%rbx
			__chc, __cit, __uk>::_Node**
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_allocate_buckets(size_type __n)
    {
      _Bucket_allocator_type __alloc(_M_node_allocator);
  a2:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  a6:	48 89 c7             	mov    %rax,%rdi
  a9:	e8 00 00 00 00       	callq  ae <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_buckets(unsigned long)+0xae>
  ae:	48 89 d8             	mov    %rbx,%rax
  b1:	48 89 c7             	mov    %rax,%rdi
  b4:	e8 00 00 00 00       	callq  b9 <(anonymous namespace)::Concurrency_counters_Test::me_+0xa1>

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE18_M_deallocate_nodeEPNSB_10_Hash_nodeIS3_Lb0EEE:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*)>:
  template<typename _Key, typename _Value,
	   typename _Allocator, typename _ExtractKey, typename _Equal,
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 28          	sub    $0x28,%rsp
   9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
   d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_node(_Node* __n)
    {
      _M_get_Value_allocator().destroy(&__n->_M_v);
  11:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
  15:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  19:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  1d:	48 89 d6             	mov    %rdx,%rsi
  20:	48 89 c7             	mov    %rax,%rdi
  23:	e8 00 00 00 00       	callq  28 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*)+0x28>
  28:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  2c:	48 89 de             	mov    %rbx,%rsi
  2f:	48 89 c7             	mov    %rax,%rdi
  32:	e8 00 00 00 00       	callq  37 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*)+0x37>
  37:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  3b:	48 89 c7             	mov    %rax,%rdi
  3e:	e8 00 00 00 00       	callq  43 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*)+0x43>
      _M_node_allocator.deallocate(__n, 1);
  43:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  47:	48 8d 48 04          	lea    0x4(%rax),%rcx
  4b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  4f:	ba 01 00 00 00       	mov    $0x1,%edx
  54:	48 89 c6             	mov    %rax,%rsi
  57:	48 89 cf             	mov    %rcx,%rdi
  5a:	e8 00 00 00 00       	callq  5f <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*)+0x5f>
    }
  5f:	48 83 c4 28          	add    $0x28,%rsp
  63:	5b                   	pop    %rbx
  64:	5d                   	pop    %rbp
  65:	c3                   	retq   
  66:	48 89 c3             	mov    %rax,%rbx
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_deallocate_node(_Node* __n)
    {
      _M_get_Value_allocator().destroy(&__n->_M_v);
  69:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  6d:	48 89 c7             	mov    %rax,%rdi
  70:	e8 00 00 00 00       	callq  75 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_deallocate_node(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*)+0x75>
  75:	48 89 d8             	mov    %rbx,%rax
  78:	48 89 c7             	mov    %rax,%rdi
  7b:	e8 00 00 00 00       	callq  80 <(anonymous namespace)::Concurrency_counters_Test::me_+0x68>

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorIPNSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEEC2Ev:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::new_allocator()>:

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	5d                   	pop    %rbp
   9:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorIPNSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEED2Ev:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::~new_allocator()>:
      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	5d                   	pop    %rbp
   9:	c3                   	retq   

Disassembly of section .text._ZNSt4pairINSt3tr18__detail19_Hashtable_iteratorIS_IKSsbELb0ELb0EEEbEC2ERKS5_RKb:

0000000000000000 <std::pair<std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false>, bool>::pair(std::tr1::__detail::_Hashtable_iterator<std::pair<std::string const, bool>, false, false> const&, bool const&)>:
       *  respective default constructors.  */
      _GLIBCXX_CONSTEXPR pair()
      : first(), second() { }

      /** Two objects may be passed to a @c pair constructor to be copied.  */
      _GLIBCXX_CONSTEXPR pair(const _T1& __a, const _T2& __b)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      : first(__a), second(__b) { }
  10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  14:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  18:	48 8b 0a             	mov    (%rdx),%rcx
  1b:	48 89 08             	mov    %rcx,(%rax)
  1e:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  22:	48 89 50 08          	mov    %rdx,0x8(%rax)
  26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  2a:	0f b6 10             	movzbl (%rax),%edx
  2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  31:	88 50 10             	mov    %dl,0x10(%rax)
  34:	5d                   	pop    %rbp
  35:	c3                   	retq   

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE16_M_allocate_nodeERKS3_:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_node(std::pair<std::string const, bool> const&)>:
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
			_H1, _H2, _Hash, _RehashPolicy,
			__chc, __cit, __uk>::_Node*
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 28          	sub    $0x28,%rsp
   9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
   d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_allocate_node(const value_type& __v)
    {
      _Node* __n = _M_node_allocator.allocate(1);
  11:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  15:	48 83 c0 04          	add    $0x4,%rax
  19:	ba 00 00 00 00       	mov    $0x0,%edx
  1e:	be 01 00 00 00       	mov    $0x1,%esi
  23:	48 89 c7             	mov    %rax,%rdi
  26:	e8 00 00 00 00       	callq  2b <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_node(std::pair<std::string const, bool> const&)+0x2b>
  2b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      __try
	{
	  _M_get_Value_allocator().construct(&__n->_M_v, __v);
  2f:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  33:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  37:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  3b:	48 89 d6             	mov    %rdx,%rsi
  3e:	48 89 c7             	mov    %rax,%rdi
  41:	e8 00 00 00 00       	callq  46 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_node(std::pair<std::string const, bool> const&)+0x46>
  46:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  4a:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  4e:	48 89 de             	mov    %rbx,%rsi
  51:	48 89 c7             	mov    %rax,%rdi
  54:	e8 00 00 00 00       	callq  59 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_node(std::pair<std::string const, bool> const&)+0x59>
  59:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  5d:	48 89 c7             	mov    %rax,%rdi
  60:	e8 00 00 00 00       	callq  65 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_node(std::pair<std::string const, bool> const&)+0x65>
	  __n->_M_next = 0;
  65:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  69:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  70:	00 
	  return __n;
  71:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
      __catch(...)
	{
	  _M_node_allocator.deallocate(__n, 1);
	  __throw_exception_again;
	}
    }
  75:	48 83 c4 28          	add    $0x28,%rsp
  79:	5b                   	pop    %rbx
  7a:	5d                   	pop    %rbp
  7b:	c3                   	retq   
  7c:	48 89 c3             	mov    %rax,%rbx
    _M_allocate_node(const value_type& __v)
    {
      _Node* __n = _M_node_allocator.allocate(1);
      __try
	{
	  _M_get_Value_allocator().construct(&__n->_M_v, __v);
  7f:	48 8d 45 ef          	lea    -0x11(%rbp),%rax
  83:	48 89 c7             	mov    %rax,%rdi
  86:	e8 00 00 00 00       	callq  8b <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_node(std::pair<std::string const, bool> const&)+0x8b>
  8b:	48 89 d8             	mov    %rbx,%rax
	  __n->_M_next = 0;
	  return __n;
	}
      __catch(...)
  8e:	48 89 c7             	mov    %rax,%rdi
  91:	e8 00 00 00 00       	callq  96 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_node(std::pair<std::string const, bool> const&)+0x96>
	{
	  _M_node_allocator.deallocate(__n, 1);
  96:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  9a:	48 8d 48 04          	lea    0x4(%rax),%rcx
  9e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  a2:	ba 01 00 00 00       	mov    $0x1,%edx
  a7:	48 89 c6             	mov    %rax,%rsi
  aa:	48 89 cf             	mov    %rcx,%rdi
  ad:	e8 00 00 00 00       	callq  b2 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_node(std::pair<std::string const, bool> const&)+0xb2>
	  __throw_exception_again;
  b2:	e8 00 00 00 00       	callq  b7 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_node(std::pair<std::string const, bool> const&)+0xb7>
  b7:	48 89 c3             	mov    %rax,%rbx
	{
	  _M_get_Value_allocator().construct(&__n->_M_v, __v);
	  __n->_M_next = 0;
	  return __n;
	}
      __catch(...)
  ba:	e8 00 00 00 00       	callq  bf <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_allocate_node(std::pair<std::string const, bool> const&)+0xbf>
  bf:	48 89 d8             	mov    %rbx,%rax
  c2:	48 89 c7             	mov    %rax,%rdi
  c5:	e8 00 00 00 00       	callq  ca <(anonymous namespace)::Concurrency_counters_Test::me_+0xb2>

Disassembly of section .text._ZNSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE9_M_rehashEm:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_rehash(unsigned long)>:
  template<typename _Key, typename _Value,
	   typename _Allocator, typename _ExtractKey, typename _Equal,
	   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
	   bool __chc, bool __cit, bool __uk>
    void
    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 38          	sub    $0x38,%rsp
   9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
   d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
	       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::
    _M_rehash(size_type __n)
    {
      _Node** __new_array = _M_allocate_buckets(__n);
  11:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  15:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  19:	48 89 d6             	mov    %rdx,%rsi
  1c:	48 89 c7             	mov    %rax,%rdi
  1f:	e8 00 00 00 00       	callq  24 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_rehash(unsigned long)+0x24>
  24:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      __try
	{
	  for (size_type __i = 0; __i < _M_bucket_count; ++__i)
  28:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  2f:	00 
  30:	e9 8e 00 00 00       	jmpq   c3 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_rehash(unsigned long)+0xc3>
	    while (_Node* __p = _M_buckets[__i])
  35:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  39:	48 8b 40 08          	mov    0x8(%rax),%rax
  3d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  41:	48 c1 e2 03          	shl    $0x3,%rdx
  45:	48 01 d0             	add    %rdx,%rax
  48:	48 8b 00             	mov    (%rax),%rax
  4b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  4f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  54:	74 68                	je     be <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_rehash(unsigned long)+0xbe>
	      {
		std::size_t __new_index = this->_M_bucket_index(__p, __n);
  56:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  5a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  5e:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  62:	48 89 ce             	mov    %rcx,%rsi
  65:	48 89 c7             	mov    %rax,%rdi
  68:	e8 00 00 00 00       	callq  6d <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_rehash(unsigned long)+0x6d>
  6d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		_M_buckets[__i] = __p->_M_next;
  71:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  75:	48 8b 40 08          	mov    0x8(%rax),%rax
  79:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  7d:	48 c1 e2 03          	shl    $0x3,%rdx
  81:	48 01 c2             	add    %rax,%rdx
  84:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  88:	48 8b 40 10          	mov    0x10(%rax),%rax
  8c:	48 89 02             	mov    %rax,(%rdx)
		__p->_M_next = __new_array[__new_index];
  8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  93:	48 c1 e0 03          	shl    $0x3,%rax
  97:	48 03 45 d8          	add    -0x28(%rbp),%rax
  9b:	48 8b 10             	mov    (%rax),%rdx
  9e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  a2:	48 89 50 10          	mov    %rdx,0x10(%rax)
		__new_array[__new_index] = __p;
  a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  aa:	48 c1 e0 03          	shl    $0x3,%rax
  ae:	48 03 45 d8          	add    -0x28(%rbp),%rax
  b2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  b6:	48 89 10             	mov    %rdx,(%rax)
    {
      _Node** __new_array = _M_allocate_buckets(__n);
      __try
	{
	  for (size_type __i = 0; __i < _M_bucket_count; ++__i)
	    while (_Node* __p = _M_buckets[__i])
  b9:	e9 77 ff ff ff       	jmpq   35 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_rehash(unsigned long)+0x35>
    _M_rehash(size_type __n)
    {
      _Node** __new_array = _M_allocate_buckets(__n);
      __try
	{
	  for (size_type __i = 0; __i < _M_bucket_count; ++__i)
  be:	48 83 45 d0 01       	addq   $0x1,-0x30(%rbp)
  c3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  c7:	48 8b 40 10          	mov    0x10(%rax),%rax
  cb:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  cf:	0f 97 c0             	seta   %al
  d2:	84 c0                	test   %al,%al
  d4:	0f 85 5b ff ff ff    	jne    35 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_rehash(unsigned long)+0x35>
		std::size_t __new_index = this->_M_bucket_index(__p, __n);
		_M_buckets[__i] = __p->_M_next;
		__p->_M_next = __new_array[__new_index];
		__new_array[__new_index] = __p;
	      }
	  _M_deallocate_buckets(_M_buckets, _M_bucket_count);
  da:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  de:	48 8b 50 10          	mov    0x10(%rax),%rdx
  e2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  e6:	48 8b 48 08          	mov    0x8(%rax),%rcx
  ea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  ee:	48 89 ce             	mov    %rcx,%rsi
  f1:	48 89 c7             	mov    %rax,%rdi
  f4:	e8 00 00 00 00       	callq  f9 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_rehash(unsigned long)+0xf9>
	  _M_bucket_count = __n;
  f9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  fd:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
 101:	48 89 50 10          	mov    %rdx,0x10(%rax)
	  _M_buckets = __new_array;
 105:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 109:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
 10d:	48 89 50 08          	mov    %rdx,0x8(%rax)
	  _M_deallocate_buckets(__new_array, __n);
	  _M_deallocate_nodes(_M_buckets, _M_bucket_count);
	  _M_element_count = 0;
	  __throw_exception_again;
	}
    }
 111:	48 83 c4 38          	add    $0x38,%rsp
 115:	5b                   	pop    %rbx
 116:	5d                   	pop    %rbp
 117:	c3                   	retq   
 118:	48 89 c3             	mov    %rax,%rbx
	      }
	  _M_deallocate_buckets(_M_buckets, _M_bucket_count);
	  _M_bucket_count = __n;
	  _M_buckets = __new_array;
	}
      __catch(...)
 11b:	e8 00 00 00 00       	callq  120 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_rehash(unsigned long)+0x120>
 120:	48 89 d8             	mov    %rbx,%rax
 123:	48 89 c7             	mov    %rax,%rdi
 126:	e8 00 00 00 00       	callq  12b <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_rehash(unsigned long)+0x12b>
 12b:	48 89 c7             	mov    %rax,%rdi
 12e:	e8 00 00 00 00       	callq  133 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_rehash(unsigned long)+0x133>
	{
	  // A failure here means that a hash function threw an exception.
	  // We can't restore the previous state without calling the hash
	  // function again, so the only sensible recovery is to delete
	  // everything.
	  _M_deallocate_nodes(__new_array, __n);
 133:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
 137:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
 13b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 13f:	48 89 ce             	mov    %rcx,%rsi
 142:	48 89 c7             	mov    %rax,%rdi
 145:	e8 00 00 00 00       	callq  14a <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_rehash(unsigned long)+0x14a>
	  _M_deallocate_buckets(__new_array, __n);
 14a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
 14e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
 152:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 156:	48 89 ce             	mov    %rcx,%rsi
 159:	48 89 c7             	mov    %rax,%rdi
 15c:	e8 00 00 00 00       	callq  161 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_rehash(unsigned long)+0x161>
	  _M_deallocate_nodes(_M_buckets, _M_bucket_count);
 161:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 165:	48 8b 50 10          	mov    0x10(%rax),%rdx
 169:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 16d:	48 8b 48 08          	mov    0x8(%rax),%rcx
 171:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 175:	48 89 ce             	mov    %rcx,%rsi
 178:	48 89 c7             	mov    %rax,%rdi
 17b:	e8 00 00 00 00       	callq  180 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_rehash(unsigned long)+0x180>
	  _M_element_count = 0;
 180:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 184:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
 18b:	00 
	  __throw_exception_again;
 18c:	e8 00 00 00 00       	callq  191 <vtable for (anonymous namespace)::Basic_LockUnlock_Test+0x11>

Disassembly of section .text._ZNKSt3tr18__detail15_Hash_code_baseISsSt4pairIKSsbESt10_Select1stIS4_ESt8equal_toISsENS_4hashISsEENS0_18_Mod_range_hashingENS0_20_Default_ranged_hashELb0EE13_M_store_codeEPNS0_10_Hash_nodeIS4_Lb0EEEm:

0000000000000000 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_store_code(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*, unsigned long) const>:
      _M_compare(const _Key& __k, _Hash_code_type,
		 _Hash_node<_Value, false>* __n) const
      { return _M_eq(__k, _M_extract(__n->_M_v)); }

      void
      _M_store_code(_Hash_node<_Value, false>*, _Hash_code_type) const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
   c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      { }
  10:	5d                   	pop    %rbp
  11:	c3                   	retq   

Disassembly of section .text._ZNKSt10_Select1stISt4pairIKSsbEEclERS2_:

0000000000000000 <std::_Select1st<std::pair<std::string const, bool> >::operator()(std::pair<std::string const, bool>&) const>:
  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
					      typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
      { return __x.first; }
   c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  10:	5d                   	pop    %rbp
  11:	c3                   	retq   

Disassembly of section .text._ZNKSt8equal_toISsEclERKSsS2_:

0000000000000000 <std::equal_to<std::string>::operator()(std::string const&, std::string const&) const>:
  /// One of the @link comparison_functors comparison functors@endlink.
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      { return __x == __y; }
  14:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  18:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  1c:	48 89 d6             	mov    %rdx,%rsi
  1f:	48 89 c7             	mov    %rax,%rdi
  22:	e8 00 00 00 00       	callq  27 <std::equal_to<std::string>::operator()(std::string const&, std::string const&) const+0x27>
  27:	c9                   	leaveq 
  28:	c3                   	retq   

Disassembly of section .text._ZNKSt3tr110_HashtableISsSt4pairIKSsSsESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE22_M_get_Value_allocatorEv:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_get_Value_allocator() const>:
      allocator_type
      get_allocator() const
      { return allocator_type(_M_node_allocator); }

      _Value_allocator_type
      _M_get_Value_allocator() const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
      { return _Value_allocator_type(_M_node_allocator); }
  10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  14:	48 8d 50 04          	lea    0x4(%rax),%rdx
  18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1c:	48 89 d6             	mov    %rdx,%rsi
  1f:	48 89 c7             	mov    %rax,%rdi
  22:	e8 00 00 00 00       	callq  27 <std::tr1::_Hashtable<std::string, std::pair<std::string const, std::string>, std::allocator<std::pair<std::string const, std::string> >, std::_Select1st<std::pair<std::string const, std::string> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_get_Value_allocator() const+0x27>
  27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  2b:	c9                   	leaveq 
  2c:	c3                   	retq   

Disassembly of section .text._ZNSaISt4pairIKSsSsEED2Ev:

0000000000000000 <std::allocator<std::pair<std::string const, std::string> >::~allocator()>:

      ~allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::allocator<std::pair<std::string const, std::string> >::~allocator()+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZNSt4pairIKSsSsED2Ev:

0000000000000000 <std::pair<std::string const, std::string>::~pair()>:
    struct _Index_tuple;
#endif

  /// Struct holding two objects of arbitrary type.
  template<class _T1, class _T2>
    struct pair
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 18          	sub    $0x18,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  11:	48 83 c0 08          	add    $0x8,%rax
  15:	48 89 c7             	mov    %rax,%rdi
  18:	e8 00 00 00 00       	callq  1d <std::pair<std::string const, std::string>::~pair()+0x1d>
  1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  21:	48 89 c7             	mov    %rax,%rdi
  24:	e8 00 00 00 00       	callq  29 <std::pair<std::string const, std::string>::~pair()+0x29>
  29:	48 83 c4 18          	add    $0x18,%rsp
  2d:	5b                   	pop    %rbx
  2e:	5d                   	pop    %rbp
  2f:	c3                   	retq   
  30:	48 89 c3             	mov    %rax,%rbx
  33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  37:	48 89 c7             	mov    %rax,%rdi
  3a:	e8 00 00 00 00       	callq  3f <std::pair<std::string const, std::string>::~pair()+0x3f>
  3f:	48 89 d8             	mov    %rbx,%rax
  42:	48 89 c7             	mov    %rax,%rdi
  45:	e8 00 00 00 00       	callq  4a <(anonymous namespace)::Concurrency_counters_Test::me_+0x32>

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorISt4pairIKSsSsEE7destroyEPS3_:

0000000000000000 <__gnu_cxx::new_allocator<std::pair<std::string const, std::string> >::destroy(std::pair<std::string const, std::string>*)>:
        construct(pointer __p, _Args&&... __args)
	{ ::new((void *)__p) _Tp(std::forward<_Args>(__args)...); }
#endif

      void 
      destroy(pointer __p) { __p->~_Tp(); }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  14:	48 89 c7             	mov    %rax,%rdi
  17:	e8 00 00 00 00       	callq  1c <__gnu_cxx::new_allocator<std::pair<std::string const, std::string> >::destroy(std::pair<std::string const, std::string>*)+0x1c>
  1c:	c9                   	leaveq 
  1d:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorINSt3tr18__detail10_Hash_nodeISt4pairIKSsSsELb0EEEE10deallocateEPS7_m:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false> >::deallocate(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*, unsigned long)>:
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      { ::operator delete(__p); }
  14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  18:	48 89 c7             	mov    %rax,%rdi
  1b:	e8 00 00 00 00       	callq  20 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false> >::deallocate(std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false>*, unsigned long)+0x20>
  20:	c9                   	leaveq 
  21:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorIPN4base8TestCaseEEC2Ev:

0000000000000000 <__gnu_cxx::new_allocator<base::TestCase*>::new_allocator()>:

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	5d                   	pop    %rbp
   9:	c3                   	retq   

Disassembly of section .text._ZNSt10_Iter_baseIPPN4base8TestCaseELb0EE7_S_baseES3_:

0000000000000000 <std::_Iter_base<base::TestCase**, false>::_S_base(base::TestCase**)>:
  // untouched
  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return __it; }
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	5d                   	pop    %rbp
   d:	c3                   	retq   

Disassembly of section .text._ZSt12__niter_baseIPPN4base8TestCaseEENSt11_Niter_baseIT_E13iterator_typeES5_:

0000000000000000 <std::_Niter_base<base::TestCase**>::iterator_type std::__niter_base<base::TestCase**>(base::TestCase**)>:
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::_Niter_base<base::TestCase**>::iterator_type std::__niter_base<base::TestCase**>(base::TestCase**)+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZSt22__copy_move_backward_aILb0EPPN4base8TestCaseES3_ET1_T0_S5_S4_:

0000000000000000 <base::TestCase** std::__copy_move_backward_a<false, base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)>:
	}
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 30          	sub    $0x30,%rsp
   8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  10:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
	                     && __is_pointer<_BI1>::__value
	                     && __is_pointer<_BI2>::__value
			     && __are_same<_ValueType1, _ValueType2>::__value);
  14:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)

      return std::__copy_move_backward<_IsMove, __simple,
	                               _Category>::__copy_move_b(__first,
								 __last,
								 __result);
  18:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  1c:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  24:	48 89 ce             	mov    %rcx,%rsi
  27:	48 89 c7             	mov    %rax,%rdi
  2a:	e8 00 00 00 00       	callq  2f <base::TestCase** std::__copy_move_backward_a<false, base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x2f>
    }
  2f:	c9                   	leaveq 
  30:	c3                   	retq   

Disassembly of section .text._ZNKSt12_Vector_baseIPN4base8TestCaseESaIS2_EE19_M_get_Tp_allocatorEv:

0000000000000000 <std::_Vector_base<base::TestCase*, std::allocator<base::TestCase*> >::_M_get_Tp_allocator() const>:
      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	5d                   	pop    %rbp
   d:	c3                   	retq   

Disassembly of section .text._ZNK9__gnu_cxx13new_allocatorIPN4base8TestCaseEE8max_sizeEv:

0000000000000000 <__gnu_cxx::new_allocator<base::TestCase*>::max_size() const>:
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw() 
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return size_t(-1) / sizeof(_Tp); }
   8:	48 b8 ff ff ff ff ff 	movabs $0x1fffffffffffffff,%rax
   f:	ff ff 1f 
  12:	5d                   	pop    %rbp
  13:	c3                   	retq   

Disassembly of section .text._ZSt18uninitialized_copyIPPN4base8TestCaseES3_ET0_T_S5_S4_:

0000000000000000 <base::TestCase** std::uninitialized_copy<base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)>:
   *
   *  Like copy(), but does not require an initialized output range.
  */
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      typedef typename iterator_traits<_ForwardIterator>::value_type
	_ValueType2;

      return std::__uninitialized_copy<(__is_trivial(_ValueType1)
					&& __is_trivial(_ValueType2))>::
	__uninit_copy(__first, __last, __result);
  14:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  18:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  20:	48 89 ce             	mov    %rcx,%rsi
  23:	48 89 c7             	mov    %rax,%rdi
  26:	e8 00 00 00 00       	callq  2b <base::TestCase** std::uninitialized_copy<base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x2b>
    }
  2b:	c9                   	leaveq 
  2c:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorINSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEEC2Ev:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >::new_allocator()>:

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	5d                   	pop    %rbp
   9:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorIPNSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEE8allocateEmPKv:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::allocate(unsigned long, void const*)>:
      address(const_reference __x) const { return std::__addressof(__x); }

      // NB: __n is permitted to be 0.  The C++ standard says nothing
      // about what the return value is when __n == 0.
      pointer
      allocate(size_type __n, const void* = 0)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      { 
	if (__n > this->max_size())
  14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  18:	48 89 c7             	mov    %rax,%rdi
  1b:	e8 00 00 00 00       	callq  20 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::allocate(unsigned long, void const*)+0x20>
  20:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  24:	0f 92 c0             	setb   %al
  27:	84 c0                	test   %al,%al
  29:	74 05                	je     30 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::allocate(unsigned long, void const*)+0x30>
	  std::__throw_bad_alloc();
  2b:	e8 00 00 00 00       	callq  30 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::allocate(unsigned long, void const*)+0x30>

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  34:	48 c1 e0 03          	shl    $0x3,%rax
  38:	48 89 c7             	mov    %rax,%rdi
  3b:	e8 00 00 00 00       	callq  40 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::allocate(unsigned long, void const*)+0x40>
      }
  40:	c9                   	leaveq 
  41:	c3                   	retq   

Disassembly of section .text._ZSt4fillIPPNSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEES7_EvT_S9_RKT0_:

0000000000000000 <void std::fill<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>* const&)>:
   *  types filling contiguous areas of memory, this becomes an inline call
   *  to @c memset or @c wmemset.
  */
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 28          	sub    $0x28,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  11:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
      // concept requirements
      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
				  _ForwardIterator>)
      __glibcxx_requires_valid_range(__first, __last);

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
  15:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  19:	48 89 c7             	mov    %rax,%rdi
  1c:	e8 00 00 00 00       	callq  21 <void std::fill<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>* const&)+0x21>
  21:	48 89 c3             	mov    %rax,%rbx
  24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  28:	48 89 c7             	mov    %rax,%rdi
  2b:	e8 00 00 00 00       	callq  30 <void std::fill<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>* const&)+0x30>
  30:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  34:	48 89 de             	mov    %rbx,%rsi
  37:	48 89 c7             	mov    %rax,%rdi
  3a:	e8 00 00 00 00       	callq  3f <void std::fill<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>* const&)+0x3f>
		    __value);
    }
  3f:	48 83 c4 28          	add    $0x28,%rsp
  43:	5b                   	pop    %rbx
  44:	5d                   	pop    %rbp
  45:	c3                   	retq   

Disassembly of section .text._ZNKSt3tr110_HashtableISsSt4pairIKSsbESaIS3_ESt10_Select1stIS3_ESt8equal_toISsENS_4hashISsEENS_8__detail18_Mod_range_hashingENSB_20_Default_ranged_hashENSB_20_Prime_rehash_policyELb0ELb0ELb1EE22_M_get_Value_allocatorEv:

0000000000000000 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_get_Value_allocator() const>:
      allocator_type
      get_allocator() const
      { return allocator_type(_M_node_allocator); }

      _Value_allocator_type
      _M_get_Value_allocator() const
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
      { return _Value_allocator_type(_M_node_allocator); }
  10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  14:	48 8d 50 04          	lea    0x4(%rax),%rdx
  18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  1c:	48 89 d6             	mov    %rdx,%rsi
  1f:	48 89 c7             	mov    %rax,%rdi
  22:	e8 00 00 00 00       	callq  27 <std::tr1::_Hashtable<std::string, std::pair<std::string const, bool>, std::allocator<std::pair<std::string const, bool> >, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, std::tr1::__detail::_Prime_rehash_policy, false, false, true>::_M_get_Value_allocator() const+0x27>
  27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  2b:	c9                   	leaveq 
  2c:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorISt4pairIKSsbEE7destroyEPS3_:

0000000000000000 <__gnu_cxx::new_allocator<std::pair<std::string const, bool> >::destroy(std::pair<std::string const, bool>*)>:
        construct(pointer __p, _Args&&... __args)
	{ ::new((void *)__p) _Tp(std::forward<_Args>(__args)...); }
#endif

      void 
      destroy(pointer __p) { __p->~_Tp(); }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  14:	48 89 c7             	mov    %rax,%rdi
  17:	e8 00 00 00 00       	callq  1c <__gnu_cxx::new_allocator<std::pair<std::string const, bool> >::destroy(std::pair<std::string const, bool>*)+0x1c>
  1c:	c9                   	leaveq 
  1d:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorINSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEE10deallocateEPS7_m:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >::deallocate(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*, unsigned long)>:
	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      { ::operator delete(__p); }
  14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  18:	48 89 c7             	mov    %rax,%rdi
  1b:	e8 00 00 00 00       	callq  20 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >::deallocate(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*, unsigned long)+0x20>
  20:	c9                   	leaveq 
  21:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorINSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEE8allocateEmPKv:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >::allocate(unsigned long, void const*)>:
      address(const_reference __x) const { return std::__addressof(__x); }

      // NB: __n is permitted to be 0.  The C++ standard says nothing
      // about what the return value is when __n == 0.
      pointer
      allocate(size_type __n, const void* = 0)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
      { 
	if (__n > this->max_size())
  14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  18:	48 89 c7             	mov    %rax,%rdi
  1b:	e8 00 00 00 00       	callq  20 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >::allocate(unsigned long, void const*)+0x20>
  20:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  24:	0f 92 c0             	setb   %al
  27:	84 c0                	test   %al,%al
  29:	74 05                	je     30 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >::allocate(unsigned long, void const*)+0x30>
	  std::__throw_bad_alloc();
  2b:	e8 00 00 00 00       	callq  30 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >::allocate(unsigned long, void const*)+0x30>

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
  30:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  34:	48 89 d0             	mov    %rdx,%rax
  37:	48 01 c0             	add    %rax,%rax
  3a:	48 01 d0             	add    %rdx,%rax
  3d:	48 c1 e0 03          	shl    $0x3,%rax
  41:	48 89 c7             	mov    %rax,%rdi
  44:	e8 00 00 00 00       	callq  49 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >::allocate(unsigned long, void const*)+0x49>
      }
  49:	c9                   	leaveq 
  4a:	c3                   	retq   

Disassembly of section .text._ZNSt4pairIKSsbEC2ERKS1_:

0000000000000000 <std::pair<std::string const, bool>::pair(std::pair<std::string const, bool> const&)>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  18:	48 89 d6             	mov    %rdx,%rsi
  1b:	48 89 c7             	mov    %rax,%rdi
  1e:	e8 00 00 00 00       	callq  23 <std::pair<std::string const, bool>::pair(std::pair<std::string const, bool> const&)+0x23>
  23:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  27:	0f b6 50 08          	movzbl 0x8(%rax),%edx
  2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  2f:	88 50 08             	mov    %dl,0x8(%rax)
  32:	c9                   	leaveq 
  33:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorISt4pairIKSsbEE9constructEPS3_RKS3_:

0000000000000000 <__gnu_cxx::new_allocator<std::pair<std::string const, bool> >::construct(std::pair<std::string const, bool>*, std::pair<std::string const, bool> const&)>:
      { return size_t(-1) / sizeof(_Tp); }

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 402. wrong new expression in [some_] allocator::construct
      void 
      construct(pointer __p, const _Tp& __val) 
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	41 55                	push   %r13
   6:	41 54                	push   %r12
   8:	53                   	push   %rbx
   9:	48 83 ec 28          	sub    $0x28,%rsp
   d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  11:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  15:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
      { ::new((void *)__p) _Tp(__val); }
  19:	4c 8b 65 d0          	mov    -0x30(%rbp),%r12
  1d:	4c 89 e6             	mov    %r12,%rsi
  20:	bf 10 00 00 00       	mov    $0x10,%edi
  25:	e8 00 00 00 00       	callq  2a <__gnu_cxx::new_allocator<std::pair<std::string const, bool> >::construct(std::pair<std::string const, bool>*, std::pair<std::string const, bool> const&)+0x2a>
  2a:	48 89 c3             	mov    %rax,%rbx
  2d:	48 85 db             	test   %rbx,%rbx
  30:	74 2a                	je     5c <__gnu_cxx::new_allocator<std::pair<std::string const, bool> >::construct(std::pair<std::string const, bool>*, std::pair<std::string const, bool> const&)+0x5c>
  32:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  36:	48 89 c6             	mov    %rax,%rsi
  39:	48 89 df             	mov    %rbx,%rdi
  3c:	e8 00 00 00 00       	callq  41 <__gnu_cxx::new_allocator<std::pair<std::string const, bool> >::construct(std::pair<std::string const, bool>*, std::pair<std::string const, bool> const&)+0x41>
  41:	eb 19                	jmp    5c <__gnu_cxx::new_allocator<std::pair<std::string const, bool> >::construct(std::pair<std::string const, bool>*, std::pair<std::string const, bool> const&)+0x5c>
  43:	49 89 c5             	mov    %rax,%r13
  46:	4c 89 e6             	mov    %r12,%rsi
  49:	48 89 df             	mov    %rbx,%rdi
  4c:	e8 00 00 00 00       	callq  51 <__gnu_cxx::new_allocator<std::pair<std::string const, bool> >::construct(std::pair<std::string const, bool>*, std::pair<std::string const, bool> const&)+0x51>
  51:	4c 89 e8             	mov    %r13,%rax
  54:	48 89 c7             	mov    %rax,%rdi
  57:	e8 00 00 00 00       	callq  5c <__gnu_cxx::new_allocator<std::pair<std::string const, bool> >::construct(std::pair<std::string const, bool>*, std::pair<std::string const, bool> const&)+0x5c>
  5c:	48 83 c4 28          	add    $0x28,%rsp
  60:	5b                   	pop    %rbx
  61:	41 5c                	pop    %r12
  63:	41 5d                	pop    %r13
  65:	5d                   	pop    %rbp
  66:	c3                   	retq   

Disassembly of section .text._ZNKSt3tr18__detail15_Hash_code_baseISsSt4pairIKSsbESt10_Select1stIS4_ESt8equal_toISsENS_4hashISsEENS0_18_Mod_range_hashingENS0_20_Default_ranged_hashELb0EE15_M_bucket_indexEPKNS0_10_Hash_nodeIS4_Lb0EEEm:

0000000000000000 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_bucket_index(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> const*, unsigned long) const>:
      _M_bucket_index(const _Key&, _Hash_code_type __c,
		      std::size_t __n) const
      { return _M_h2(__c, __n); }

      std::size_t
      _M_bucket_index(const _Hash_node<_Value, false>* __p,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 38          	sub    $0x38,%rsp
   9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
   d:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  11:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
		      std::size_t __n) const
      { return _M_h2(_M_h1(_M_extract(__p->_M_v)), __n); }
  15:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  1d:	48 89 d6             	mov    %rdx,%rsi
  20:	48 89 c7             	mov    %rax,%rdi
  23:	e8 00 00 00 00       	callq  28 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_bucket_index(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> const*, unsigned long) const+0x28>
  28:	48 89 c2             	mov    %rax,%rdx
  2b:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  2f:	48 89 d6             	mov    %rdx,%rsi
  32:	48 89 c7             	mov    %rax,%rdi
  35:	e8 00 00 00 00       	callq  3a <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_bucket_index(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> const*, unsigned long) const+0x3a>
  3a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  3e:	48 8d 50 02          	lea    0x2(%rax),%rdx
  42:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  46:	48 89 c6             	mov    %rax,%rsi
  49:	48 89 d7             	mov    %rdx,%rdi
  4c:	e8 00 00 00 00       	callq  51 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_bucket_index(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> const*, unsigned long) const+0x51>
  51:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  55:	48 8d 4a 03          	lea    0x3(%rdx),%rcx
  59:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  5d:	48 89 c6             	mov    %rax,%rsi
  60:	48 89 cf             	mov    %rcx,%rdi
  63:	e8 00 00 00 00       	callq  68 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_bucket_index(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> const*, unsigned long) const+0x68>
  68:	48 89 c3             	mov    %rax,%rbx
  6b:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  6f:	48 89 c7             	mov    %rax,%rdi
  72:	e8 00 00 00 00       	callq  77 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_bucket_index(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> const*, unsigned long) const+0x77>
  77:	48 89 d8             	mov    %rbx,%rax
  7a:	48 83 c4 38          	add    $0x38,%rsp
  7e:	5b                   	pop    %rbx
  7f:	5d                   	pop    %rbp
  80:	c3                   	retq   
  81:	48 89 c3             	mov    %rax,%rbx
  84:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  88:	48 89 c7             	mov    %rax,%rdi
  8b:	e8 00 00 00 00       	callq  90 <std::tr1::__detail::_Hash_code_base<std::string, std::pair<std::string const, bool>, std::_Select1st<std::pair<std::string const, bool> >, std::equal_to<std::string>, std::tr1::hash<std::string>, std::tr1::__detail::_Mod_range_hashing, std::tr1::__detail::_Default_ranged_hash, false>::_M_bucket_index(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> const*, unsigned long) const+0x90>
  90:	48 89 d8             	mov    %rbx,%rax
  93:	48 89 c7             	mov    %rax,%rdi
  96:	e8 00 00 00 00       	callq  9b <(anonymous namespace)::Concurrency_counters_Test::me_+0x83>

Disassembly of section .text._ZSteqIcEN9__gnu_cxx11__enable_ifIXsrSt9__is_charIT_E7__valueEbE6__typeERKSbIS3_St11char_traitsIS3_ESaIS3_EESC_:

0000000000000000 <__gnu_cxx::__enable_if<std::__is_char<char>::__value, bool>::__type std::operator==<char>(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)>:
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	41 54                	push   %r12
   6:	53                   	push   %rbx
   7:	48 83 ec 10          	sub    $0x10,%rsp
   b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	       const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
	      && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
						    __lhs.size())); }
  13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  17:	48 89 c7             	mov    %rax,%rdi
  1a:	e8 00 00 00 00       	callq  1f <__gnu_cxx::__enable_if<std::__is_char<char>::__value, bool>::__type std::operator==<char>(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)+0x1f>
  1f:	48 89 c3             	mov    %rax,%rbx
  22:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  26:	48 89 c7             	mov    %rax,%rdi
  29:	e8 00 00 00 00       	callq  2e <__gnu_cxx::__enable_if<std::__is_char<char>::__value, bool>::__type std::operator==<char>(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)+0x2e>
  2e:	48 39 c3             	cmp    %rax,%rbx
  31:	75 43                	jne    76 <__gnu_cxx::__enable_if<std::__is_char<char>::__value, bool>::__type std::operator==<char>(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)+0x76>
  33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  37:	48 89 c7             	mov    %rax,%rdi
  3a:	e8 00 00 00 00       	callq  3f <__gnu_cxx::__enable_if<std::__is_char<char>::__value, bool>::__type std::operator==<char>(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)+0x3f>
  3f:	49 89 c4             	mov    %rax,%r12
  42:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  46:	48 89 c7             	mov    %rax,%rdi
  49:	e8 00 00 00 00       	callq  4e <__gnu_cxx::__enable_if<std::__is_char<char>::__value, bool>::__type std::operator==<char>(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)+0x4e>
  4e:	48 89 c3             	mov    %rax,%rbx
  51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  55:	48 89 c7             	mov    %rax,%rdi
  58:	e8 00 00 00 00       	callq  5d <__gnu_cxx::__enable_if<std::__is_char<char>::__value, bool>::__type std::operator==<char>(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)+0x5d>
  5d:	4c 89 e2             	mov    %r12,%rdx
  60:	48 89 de             	mov    %rbx,%rsi
  63:	48 89 c7             	mov    %rax,%rdi
  66:	e8 00 00 00 00       	callq  6b <__gnu_cxx::__enable_if<std::__is_char<char>::__value, bool>::__type std::operator==<char>(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)+0x6b>
  6b:	85 c0                	test   %eax,%eax
  6d:	75 07                	jne    76 <__gnu_cxx::__enable_if<std::__is_char<char>::__value, bool>::__type std::operator==<char>(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)+0x76>
  6f:	b8 01 00 00 00       	mov    $0x1,%eax
  74:	eb 05                	jmp    7b <__gnu_cxx::__enable_if<std::__is_char<char>::__value, bool>::__type std::operator==<char>(std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, std::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)+0x7b>
  76:	b8 00 00 00 00       	mov    $0x0,%eax
  7b:	48 83 c4 10          	add    $0x10,%rsp
  7f:	5b                   	pop    %rbx
  80:	41 5c                	pop    %r12
  82:	5d                   	pop    %rbp
  83:	c3                   	retq   

Disassembly of section .text._ZNSaISt4pairIKSsSsEEC2INSt3tr18__detail10_Hash_nodeIS1_Lb0EEEEERKSaIT_E:

0000000000000000 <std::allocator<std::pair<std::string const, std::string> >::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false> >(std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false> > const&)>:

      allocator(const allocator& __a) throw()
      : __glibcxx_base_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  14:	48 89 c7             	mov    %rax,%rdi
  17:	e8 00 00 00 00       	callq  1c <std::allocator<std::pair<std::string const, std::string> >::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false> >(std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, std::string>, false> > const&)+0x1c>
  1c:	c9                   	leaveq 
  1d:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorISt4pairIKSsSsEED2Ev:

0000000000000000 <__gnu_cxx::new_allocator<std::pair<std::string const, std::string> >::~new_allocator()>:
      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	5d                   	pop    %rbp
   9:	c3                   	retq   

Disassembly of section .text._ZNSt20__copy_move_backwardILb0ELb1ESt26random_access_iterator_tagE13__copy_move_bIPN4base8TestCaseEEEPT_PKS6_S9_S7_:

0000000000000000 <base::TestCase** std::__copy_move_backward<false, true, std::random_access_iterator_tag>::__copy_move_b<base::TestCase*>(base::TestCase* const*, base::TestCase* const*, base::TestCase**)>:
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 30          	sub    $0x30,%rsp
   8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  10:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
        {
	  const ptrdiff_t _Num = __last - __first;
  14:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1c:	48 89 d1             	mov    %rdx,%rcx
  1f:	48 29 c1             	sub    %rax,%rcx
  22:	48 89 c8             	mov    %rcx,%rax
  25:	48 c1 f8 03          	sar    $0x3,%rax
  29:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	  if (_Num)
  2d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  32:	74 2a                	je     5e <base::TestCase** std::__copy_move_backward<false, true, std::random_access_iterator_tag>::__copy_move_b<base::TestCase*>(base::TestCase* const*, base::TestCase* const*, base::TestCase**)+0x5e>
	    __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
  34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  38:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  3f:	00 
  40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  44:	48 c1 e0 03          	shl    $0x3,%rax
  48:	48 f7 d8             	neg    %rax
  4b:	48 03 45 d8          	add    -0x28(%rbp),%rax
  4f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  53:	48 89 ce             	mov    %rcx,%rsi
  56:	48 89 c7             	mov    %rax,%rdi
  59:	e8 00 00 00 00       	callq  5e <base::TestCase** std::__copy_move_backward<false, true, std::random_access_iterator_tag>::__copy_move_b<base::TestCase*>(base::TestCase* const*, base::TestCase* const*, base::TestCase**)+0x5e>
	  return __result - _Num;
  5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  62:	48 c1 e0 03          	shl    $0x3,%rax
  66:	48 f7 d8             	neg    %rax
  69:	48 03 45 d8          	add    -0x28(%rbp),%rax
	}
  6d:	c9                   	leaveq 
  6e:	c3                   	retq   

Disassembly of section .text._ZNSt20__uninitialized_copyILb1EE13__uninit_copyIPPN4base8TestCaseES5_EET0_T_S7_S6_:

0000000000000000 <base::TestCase** std::__uninitialized_copy<true>::__uninit_copy<base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)>:
  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 20          	sub    $0x20,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
		      _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
  14:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  18:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  20:	48 89 ce             	mov    %rcx,%rsi
  23:	48 89 c7             	mov    %rax,%rdi
  26:	e8 00 00 00 00       	callq  2b <base::TestCase** std::__uninitialized_copy<true>::__uninit_copy<base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x2b>
  2b:	c9                   	leaveq 
  2c:	c3                   	retq   

Disassembly of section .text._ZNK9__gnu_cxx13new_allocatorIPNSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEE8max_sizeEv:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::max_size() const>:
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw() 
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return size_t(-1) / sizeof(_Tp); }
   8:	48 b8 ff ff ff ff ff 	movabs $0x1fffffffffffffff,%rax
   f:	ff ff 1f 
  12:	5d                   	pop    %rbp
  13:	c3                   	retq   

Disassembly of section .text._ZSt12__niter_baseIPPNSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEENSt11_Niter_baseIT_E13iterator_typeESA_:

0000000000000000 <std::_Niter_base<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**>::iterator_type std::__niter_base<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**>(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**)>:
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }
   c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  10:	48 89 c7             	mov    %rax,%rdi
  13:	e8 00 00 00 00       	callq  18 <std::_Niter_base<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**>::iterator_type std::__niter_base<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**>(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**)+0x18>
  18:	c9                   	leaveq 
  19:	c3                   	retq   

Disassembly of section .text._ZSt8__fill_aIPPNSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEES7_EN9__gnu_cxx11__enable_ifIXsrSt11__is_scalarIT0_E7__valueEvE6__typeET_SG_RKSC_:

0000000000000000 <__gnu_cxx::__enable_if<std::__is_scalar<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::__value, void>::__type std::__fill_a<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>* const&)>:
    }
    
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
   c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
  10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  14:	48 8b 00             	mov    (%rax),%rax
  17:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
      for (; __first != __last; ++__first)
  1b:	eb 10                	jmp    2d <__gnu_cxx::__enable_if<std::__is_scalar<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::__value, void>::__type std::__fill_a<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>* const&)+0x2d>
	*__first = __tmp;
  1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  21:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  25:	48 89 10             	mov    %rdx,(%rax)
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
	     const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
  28:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
  2d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  31:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  35:	0f 95 c0             	setne  %al
  38:	84 c0                	test   %al,%al
  3a:	75 e1                	jne    1d <__gnu_cxx::__enable_if<std::__is_scalar<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>::__value, void>::__type std::__fill_a<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>*>(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>* const&)+0x1d>
	*__first = __tmp;
    }
  3c:	5d                   	pop    %rbp
  3d:	c3                   	retq   

Disassembly of section .text._ZNSaISt4pairIKSsbEEC2INSt3tr18__detail10_Hash_nodeIS1_Lb0EEEEERKSaIT_E:

0000000000000000 <std::allocator<std::pair<std::string const, bool> >::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >(std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> > const&)>:
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 10          	sub    $0x10,%rsp
   8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  14:	48 89 c7             	mov    %rax,%rdi
  17:	e8 00 00 00 00       	callq  1c <std::allocator<std::pair<std::string const, bool> >::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >(std::allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> > const&)+0x1c>
  1c:	c9                   	leaveq 
  1d:	c3                   	retq   

Disassembly of section .text._ZNK9__gnu_cxx13new_allocatorINSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEEE8max_sizeEv:

0000000000000000 <__gnu_cxx::new_allocator<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false> >::max_size() const>:
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw() 
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return size_t(-1) / sizeof(_Tp); }
   8:	48 b8 aa aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaa,%rax
   f:	aa aa 0a 
  12:	5d                   	pop    %rbp
  13:	c3                   	retq   

Disassembly of section .text._ZN9__gnu_cxx13new_allocatorISt4pairIKSsSsEEC2Ev:

0000000000000000 <__gnu_cxx::new_allocator<std::pair<std::string const, std::string> >::new_allocator()>:

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	5d                   	pop    %rbp
   9:	c3                   	retq   

Disassembly of section .text._ZSt4copyIPPN4base8TestCaseES3_ET0_T_S5_S4_:

0000000000000000 <base::TestCase** std::copy<base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)>:
   *  Note that the end of the output range is permitted to be contained
   *  within [first,last).
  */
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 28          	sub    $0x28,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  11:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	    typename iterator_traits<_II>::value_type>)
      __glibcxx_requires_valid_range(__first, __last);

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
	      (std::__miter_base(__first), std::__miter_base(__last),
	       __result));
  15:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  19:	48 89 c7             	mov    %rax,%rdi
  1c:	e8 00 00 00 00       	callq  21 <base::TestCase** std::copy<base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x21>
  21:	48 89 c3             	mov    %rax,%rbx
  24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  28:	48 89 c7             	mov    %rax,%rdi
  2b:	e8 00 00 00 00       	callq  30 <base::TestCase** std::copy<base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x30>
  30:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  34:	48 89 de             	mov    %rbx,%rsi
  37:	48 89 c7             	mov    %rax,%rdi
  3a:	e8 00 00 00 00       	callq  3f <base::TestCase** std::copy<base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x3f>
    }
  3f:	48 83 c4 28          	add    $0x28,%rsp
  43:	5b                   	pop    %rbx
  44:	5d                   	pop    %rbp
  45:	c3                   	retq   

Disassembly of section .text._ZNSt10_Iter_baseIPPNSt3tr18__detail10_Hash_nodeISt4pairIKSsbELb0EEELb0EE7_S_baseES8_:

0000000000000000 <std::_Iter_base<std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**, false>::_S_base(std::tr1::__detail::_Hash_node<std::pair<std::string const, bool>, false>**)>:
  // untouched
  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
      { return __it; }
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	5d                   	pop    %rbp
   d:	c3                   	retq   

Disassembly of section .text._ZSt14__copy_move_a2ILb0EPPN4base8TestCaseES3_ET1_T0_S5_S4_:

0000000000000000 <base::TestCase** std::__copy_move_a2<false, base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)>:
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
		   istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	41 54                	push   %r12
   6:	53                   	push   %rbx
   7:	48 83 ec 20          	sub    $0x20,%rsp
   b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  13:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
					     std::__niter_base(__last),
					     std::__niter_base(__result)));
  17:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  1b:	48 89 c7             	mov    %rax,%rdi
  1e:	e8 00 00 00 00       	callq  23 <base::TestCase** std::__copy_move_a2<false, base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x23>
  23:	49 89 c4             	mov    %rax,%r12
  26:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  2a:	48 89 c7             	mov    %rax,%rdi
  2d:	e8 00 00 00 00       	callq  32 <base::TestCase** std::__copy_move_a2<false, base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x32>
  32:	48 89 c3             	mov    %rax,%rbx
  35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  39:	48 89 c7             	mov    %rax,%rdi
  3c:	e8 00 00 00 00       	callq  41 <base::TestCase** std::__copy_move_a2<false, base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x41>
  41:	4c 89 e2             	mov    %r12,%rdx
  44:	48 89 de             	mov    %rbx,%rsi
  47:	48 89 c7             	mov    %rax,%rdi
  4a:	e8 00 00 00 00       	callq  4f <base::TestCase** std::__copy_move_a2<false, base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x4f>
    }
  4f:	48 83 c4 20          	add    $0x20,%rsp
  53:	5b                   	pop    %rbx
  54:	41 5c                	pop    %r12
  56:	5d                   	pop    %rbp
  57:	c3                   	retq   

Disassembly of section .text._ZSt13__copy_move_aILb0EPPN4base8TestCaseES3_ET1_T0_S5_S4_:

0000000000000000 <base::TestCase** std::__copy_move_a<false, base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)>:
	}
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 30          	sub    $0x30,%rsp
   8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  10:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
	                     && __is_pointer<_II>::__value
	                     && __is_pointer<_OI>::__value
			     && __are_same<_ValueTypeI, _ValueTypeO>::__value);
  14:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)

      return std::__copy_move<_IsMove, __simple,
	                      _Category>::__copy_m(__first, __last, __result);
  18:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  1c:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  24:	48 89 ce             	mov    %rcx,%rsi
  27:	48 89 c7             	mov    %rax,%rdi
  2a:	e8 00 00 00 00       	callq  2f <base::TestCase** std::__copy_move_a<false, base::TestCase**, base::TestCase**>(base::TestCase**, base::TestCase**, base::TestCase**)+0x2f>
    }
  2f:	c9                   	leaveq 
  30:	c3                   	retq   

Disassembly of section .text._ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIPN4base8TestCaseEEEPT_PKS6_S9_S7_:

0000000000000000 <base::TestCase** std::__copy_move<false, true, std::random_access_iterator_tag>::__copy_m<base::TestCase*>(base::TestCase* const*, base::TestCase* const*, base::TestCase**)>:
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 83 ec 30          	sub    $0x30,%rsp
   8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  10:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
        {
	  const ptrdiff_t _Num = __last - __first;
  14:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1c:	48 89 d1             	mov    %rdx,%rcx
  1f:	48 29 c1             	sub    %rax,%rcx
  22:	48 89 c8             	mov    %rcx,%rax
  25:	48 c1 f8 03          	sar    $0x3,%rax
  29:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	  if (_Num)
  2d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  32:	74 1f                	je     53 <base::TestCase** std::__copy_move<false, true, std::random_access_iterator_tag>::__copy_m<base::TestCase*>(base::TestCase* const*, base::TestCase* const*, base::TestCase**)+0x53>
	    __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
  34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  38:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  3f:	00 
  40:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  44:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  48:	48 89 ce             	mov    %rcx,%rsi
  4b:	48 89 c7             	mov    %rax,%rdi
  4e:	e8 00 00 00 00       	callq  53 <base::TestCase** std::__copy_move<false, true, std::random_access_iterator_tag>::__copy_m<base::TestCase*>(base::TestCase* const*, base::TestCase* const*, base::TestCase**)+0x53>
	  return __result + _Num;
  53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  57:	48 c1 e0 03          	shl    $0x3,%rax
  5b:	48 03 45 d8          	add    -0x28(%rbp),%rax
	}
  5f:	c9                   	leaveq 
  60:	c3                   	retq   
